# 网络基础

## 1.TCP/IP 网络模型有哪几层？
**1. 应用层**：专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等，而且应用层是工作在操作系统中的*用户态*，传输层及以下则工作在*内核态*。

通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。把应用层交互的数据单元称为**报文**。

**2.传输层**：应用层的数据包会传给传输层，传输层是为应用层提供网络支持的。在传输层会有两个传输协议，分别是 TCP 和 UDP。

主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。**一台机可同时运行多个线程，因此运输层有复用和分用的功能。**

**3.网络层**：不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层。网络层最常使用的是 IP 协议。

任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 **IP 数据报**，简称**数据报**。

**4.网络接口层（链路层）**：生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 **MAC 头部**，并封装成数据帧（Data frame）发送到网络上。

数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。

**OSI模型（七层）**：应用层、表示层、会话层（前三层统一表示为应用层）、传输层、网络层、数据链路层、物理层(后两层统一表示为网络接口层)

>- 应用层，负责给应用程序提供统一的接口；
>- 表示层，负责把数据转换成兼容另一个系统能识别的格式；
>- 会话层，负责建立、管理和终止表示层实体之间的通信会话；
>- 传输层，负责端到端的数据传输；
>- 网络层，负责数据的路由、转发、分片；
>- 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；
>- 物理层，负责在物理网络中传输数据帧；



## 2.简单说下每一层对应的网络协议有哪些？
**应用层：**

- 超文本传输协议：HTTP
- 文件传输协议：FTP
- 简单邮件传输协议：SMTP
- 域名系统：DNS
- 安全外壳协议：SSH
- 动态主机配置协议：DHCP
- 远程登录协议：TELNET

**传输层：**

- 传输控制协议：TCP
- 用户数据报文协议：UDP

**网络层：**

- 网际协议：IP
- ARP：地址转换协议
- RARP：反向地址转换协议
- ICMP：Internet 控制报文协议
- IGMP：Internet 组管理协议
- RIP：路由信息协议
- OSPF：分布式链路状态协议
- BGP：边界网关协议


**数据链路层：**

- 自动重传请求协议：ARQ
- 停止等待协议：CSMA/CD
- 点对点协议：PPP


**物理层：**

- 中继器
- 集线器
- 网线
- HUB

## 3.键入网址到网页显示，期间发生了什么？
1.要**对 URL 进行解析**（URL 实际上是请求服务器里的文件资源）；
> 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件

2.对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，根据这些信息来**生成 HTTP 请求消息**（GET, POST）；

3.**查询服务器域名对应的 IP 地址**（解析DNS域名），因为委托操作系统发送消息时，必须提供通信对象的 IP 地址；
    
> DNS 服务器专门保存了 Web 服务器域名与 IP 的对应关系；
> DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。

4.通过 DNS 获取到 IP 后，就可以**把 HTTP 的传输工作交给操作系统中的协议栈**(应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作)；

> 协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。


>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
>此外 IP 中还包括 ICMP 协议和 ARP 协议。

> - ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
> - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。
一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：

> 0800 ： IP 协议
> 0806 ： ARP 协议


5.发送 http 请求（网卡、交换机、路由器）

6.服务器处理请求（MAC->IP->TCP头->HTTP 进程），并返回响应（HTTP 响应报文）

7.接收响应并显示网页






## 4.Linux 系统是如何收发网络包的？
当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。

**Linux发包**：应用程序会调用 Socket 发送数据包的接口，内核会申请一个 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区，然后网络协议栈从 Socket 发送缓冲区中取出 sk_buff，先进入传输层，如果使用的是 TCP 协议发送数据，会先拷贝一个sk_buff 副本 ，然后为副本添加TCP头部，本来的sk_buff就留在传输层，接着sk_buff副本在网络层添加上IP头部，然后在网络接口层添加上帧头（帧头包括了MAC头部）和帧尾，最后将 sk_buff 放到网卡的发送队列中。随后会触发「软中断」告诉网卡驱动程序，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 Ring Buffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。当数据发送完成以后，网卡会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 Ring Buffer 内存。


而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。

**Linux收包**：网卡收到网络包之后会通过 DMA（直接存储器访问） 技术将网络包写入 RingBuffer 环形缓冲区，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。硬件中断函数先暂时屏蔽中断(下一次就直接写入内存而不通知CPU)，再发起软中断，软中断调用 ksoftirqd 线程从 Ring Buffer 中获取一个数据帧，用 sk_buffer(socket_buffer，一种数据类型)表示，然后由网络协议栈处理，先进入网络接口层，去掉帧头和帧尾，再进入网络层，去掉IP头部，接着进入传输层去掉TCP 头或 UDP 头，根据四元组「源 IP、目的 IP、源端口、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。最后，应用层程序调用 Socket 接口，将缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。



## 5.发送网络数据的时候，涉及几次内存拷贝操作？
第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。

第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。

第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。


# HTTP 相关

## 5.HTTP 是什么？
HTTP 是**超文本传输协议**，也就是HyperText Transfer Protocol。
由三个部分组成：

- 超文本：传输的内容
- 传输：两点之间传输数据的约定和规范
- 协议：计算机交流通信的规范，以及相关的各种控制和错误处理方式；

HTTP 协议是一个双向协议


## 6.HTTP 常见的状态码有哪些？
| | 具体含义 | 常见的状态码  |
| - | - | - |
| 1xx | 提示信息，是协议处理中的一种中间状态，还需要后续操作 |  |
| 2xx | 成功，报文已经收到，并被正确处理 | 200，204，206 |
| 3xx | 重定向，资源位置发生变动，需要客户端重新发送请求| 301，302，304  |
| 4xx | 客户端错误，请求报文有误，服务器无法处理 | 400，403，404 |
| 5xx | 服务器错误，服务器在处理请求时内部发生了错误 | 500，501，502，503 |


- 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
- 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#7.HTTP 常见字段有哪些？
**Host 字段**：
客户端发送请求时，用来指定服务器的域名。

**Content-Length 字段**：
服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。

**Connection 字段**：
最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

> HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

**Content-Type 字段**：
用于服务器回应时，告诉客户端，本次数据是什么格式。

**Content-Encoding 字段**：
说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式


**Accept 字段**：
声明自己可以接受哪些数据格式


## 8.GET 和 POST 有什么区别？
GET 的语义是**从服务器获取指定的资源**。
> GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。

POST 的语义是**根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。
> POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

## 9.GET 和 POST 方法都是安全和幂等的吗？
- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

**GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是**安全的**，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。

POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全的**，且多次提交数据就会创建多个资源，所以**不是幂等的**。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。

## 10.GET 请求可以带 body 吗？
RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

## 11.HTTP 缓存有哪些实现方式？
强制缓存和协商缓存

**强制缓存**指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
`Cache-Control`， 是一个相对时间；
`Expires`，是一个绝对时间；Cache-Control 的优先级高于 Expires 。第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小。后续服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。


**协商缓存**就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

**协商缓存的两种实现都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。**

## 12.HTTP/1.1 的优缺点？
HTTP 优点：「简单、灵活和易于扩展、应用广泛和跨平台」；

HTTP 缺点：「无状态、明文传输」，「不安全」


## 13.HTTP/1.1 的性能如何？

HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式

1.长连接：
减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

2.管道网络传输：
在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

3.队头阻塞：
当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞。

HTTP/1.1 的性能一般般


## 14.HTTP 与 HTTPS 有哪些区别？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则**解决 HTTP 不安全的缺陷**，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。（Secure Sockets Layer，SSL；Transport Layer Security，TLS）
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 15.SSL/TLS 协议基本流程

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

**TLS 的「握手阶段」涉及四次通信：**

1. 由客户端向服务器发起加密通信请求，也就是 ClientHello 请求：客户端生产的随机数（Client Random），客户端支持的密码套件列表。
2. 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello：服务器生产的随机数（Server Random），确认的密码套件列表，服务器的数字证书。
3. 客户端回应：客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA（证书认证机构） 公钥，确认服务器的数字证书的真实性。向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

4. 服务器的最后回应：服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」，然后，向客户端发送最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。

## 16.HTTP/1.1、HTTP/2、HTTP/3 演变？


HTTP/2 相比 HTTP/1.1 性能上的改进：

- 头部压缩：消除头部重复的部分
- 二进制格式：头信息和数据体都是二进制，并且统称为帧（frame）--->头信息帧（Headers Frame）和数据帧（Data Frame）
- 并发传输：引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接（Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号）
- 服务器主动推送资源：服务端不再是被动地响应，可以主动向客户端发送消息

HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。

HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！

- 无队头阻塞：当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。
- 更快的连接建立
- 连接迁移


## 17.HTTP/1.1 如何优化？
- 尽量避免发送 HTTP 请求（缓存）；
- 在需要发送 HTTP 请求时，考虑如何减少请求次数（减少重定向请求次数、合并请求、延迟发送请求）；
- 减少服务器的 HTTP 响应的数据大小（无损压缩、有损压缩）；


## 18.RPC和HTTP的区别？
RPC（Remote Procedure Call），又叫做**远程过程调用**。它本身并不是一个具体的协议，而是一种调用方式。

虽然大部分 RPC 协议底层使用 TCP，但实际上它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。

**1.服务发现**

- HTTP ：知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。
- RPC ：一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。

**2.底层连接形式**

- HTTP：默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。
- RPC：也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用

**3.传输的内容**

- HTTP：内容非常多的冗余，显得非常啰嗦
- RPC：定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为。


## 19.WebSocket是什么？
WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）

它实现了浏览器与服务器**全双工通信**，能更好的节省服务器资源和带宽并达到实时通讯的目的（Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据）

Websocket是一个持久化的协议

websocket 约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似 tcp 的连接，从而方便它们之间的通信；在 websocket 出现之前，we b交互一般是基于 http 协议的短连接或者长连接；
websocket是一种全新的协议，不属于 http 无状态协议，协议名为"ws"




## 20.websocket 与 http的关系？
**相同点：**

- 都是基于tcp的，都是可靠性传输协议
- 都是应用层协议

**不同点：**

- WebSocket 是双向通信协议，模拟Socket协议，可以双向发送或接受信息；HTTP是单向的
- WebSocket 是需要浏览器和服务器握手进行建立连接的；而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。

<font color="#F100">WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。</font>

[什么是websocket？](https://blog.csdn.net/weixin_47428270/article/details/126639625)




----------

# TCP

## 21.为什么需要 TCP 协议？ TCP 工作在哪一层？
IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

TCP 是一个工作在**传输层**的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

## 22.什么是 TCP ？

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

**面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；

**可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；

**字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

## 23.什么是 TCP 连接？
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为**连接**。

建立一个 TCP 连接是需要客户端与服务端达成下述三个信息的共识：

- Socket：由 IP 地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制

## 24.如何唯一确定一个 TCP 连接？
TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

## 25.有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？
客户端 IP 和端口是可变的，其理论值是：客户端的IP数 × 客户端的端口数

对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。

服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：

**文件描述符限制**，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：

- **系统级**：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；
- **用户级**：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；
- **进程级**：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；

**内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。


## 26.UDP 和 TCP 有什么区别？
TCP 的全称叫**传输控制协议（Transmission Control Protocol）**，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能**可靠地**传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它**实时性**相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以。

**1.连接**
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。

**2.服务对象**
TCP 是一对一的两点服务，即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信。

**3.可靠性**
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个可靠的传输协议。

**4. 拥塞控制、流量控制**
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

**5.首部开销**
TCP首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

**6.传输方式**
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

**7.分片不同**
TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP 文件传输；
- HTTP / HTTPS；

UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等；
- 视频、音频等多媒体通信；
- 广播通信；

## 27.TCP 和 UDP 可以使用同一个端口吗？
可以。

传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。
TCP 和 UDP，在内核中是两个完全独立的软件模块。
当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

因此， TCP/UDP 各自的端口号也相互独立，二者并不冲突。

## 28.TCP 三次握手过程是怎样的？
- 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态；
- 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
- 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，**这次报文可以携带客户到服务端的数据**，之后客户端处于 ESTABLISHED 状态。
- 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。


<font color = "#F100">第三次握手是可以携带数据的，前两次握手是不可以携带数据的</font>

## 29.TCP 需要三次握手的原因？

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号（接收方可以去除重复的数据；
接收方可以根据数据包的序列号按序接收；
可以标识发送出去的数据包中， 哪些是已经被对方收到的<通过 ACK 报文中的序列号知道>；）
- 三次握手才可以避免资源浪费

## 30.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
-** MTU**：一个网络包的最大长度，以太网中一般为 1500 字节；
- **MSS**：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

如果在TCP的整个报文（头部+数据）交给IP层进行分片，当某一个IP分片丢失后，接收方的 IP 层就无法组装成一个完整的TCP报文，也就无法将数据报文送给TCP层，所以接收方不会响应ACK给发送方，因为发送方迟迟收不到ACK确认报文，所以就会触发超时重传，就会重发整个TCP报文(头部+数据)。

当 TCP 层发现数据超过 MSS 时，则会先进行分片，分片后的形成的 IP 包自然不会超过 MTU，也就不用 IP 进行分片了。此时，如果一个TCP分片丢失后，进行重发也是MSS为单位的，而不用重发所有数据，大大增加了重传的效率。

## 31.三次握手出现问题

**当第一次握手丢失了，客户端会发生超时重传：**
重传 SYN 报文，而且*重传的 SYN 报文的序列号都是一样的*

**当第二次握手丢失了，客户端和服务端都会超时重传：**

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。

**第三次握手丢失了，服务端超时重传：**
重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
*ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文*。


## 32.TCP 四次挥手过程是怎样的？
- 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。
- 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
- 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。


## 33.四次挥手出现问题
**第一次挥手丢失：**
客户端迟迟收不到被动方的 ACK 的话，也就会触发**超时重传机制（时间为上一次超时时间的2倍），重传 FIN 报文**，重发次数由 tcp_orphan_retries 参数控制。

**服务端的第二次挥手丢失**：
客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。（ACK不会重传）

>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

> 对于 close 函数关闭的连接，由于无法再发送和接收数据，所以 FIN_WAIT2  状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。
>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。


>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（**tcp_fin_timeout 无法控制 shutdown 关闭的连接**）


**第三次挥手丢失**：
服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭，迟迟收不到这个 ACK，服务端就会重发 FIN 报文（超时重传）。

**第四次挥手丢失：**
如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制。

客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会**重置定时器**。

达到重传次数上限后，如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。


## 34.为什么 TIME_WAIT 等待的时间是 2MSL？
MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个  TTL  （Time to Live，生存时间）字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。

TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。

TIME_WAIT 等待 2 倍的 MSL，是因为网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。


## 35.为什么需要 TIME_WAIT 状态？
- 1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收（**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**）：
TIME_WAIT 的 2MSL 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
- 2.保证「被动关闭连接」的一方，能被正确的关闭：**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**。

## 36.如果已经建立了连接，但是服务端的进程崩溃会发生什么？
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以**即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程**。


## 37.TCP滑动窗口大小由哪一方决定？
接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

## 38.接收窗口和发送窗口的大小是相等的吗？
并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

## 39.什么是TCP流量控制？
两个应用程序通过 TCP 协议在网络中传输数据时，双方在硬件性能和软件性能上均可能存在差异，导致双方处理数据的速度不一致。当发送方的发送速度低于接收方接的处理速度时，不会出现问题。而当发送方的发送速度高于接收方的处理速度时，接收方会抛弃暂时无法“安置”的数据包。由于这些丢弃的数据包得不到确认，发送方会重新发送它们，直到他们被成功接收，造成资源浪费。TCP流量控制就是确保发送方的发送速度不要超出接收方的处理能力。

发送发和接收方都维护一个数据池来处理数据，称之为Buffer。发送方不断地将要发送的数据送入sender buffer，接收方不断地从receiver buffer里获取数据。

当接收方的receiver buffer已满时，发送方则暂时停止发送数据。


## 40.流量控制和拥塞控制的不同？

- 流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。
- 拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络

只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。

拥塞控制主要是四个算法：

- 慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1；
- 拥塞避免：拥塞窗口大于慢启动门限（ssthresh）时会启动拥塞避免算法（每当收到一个 ACK 时，cwnd 增加 1/cwnd）；
- 拥塞发生：超时重传（ssthresh 设为 cwnd/2，cwnd 重置为初始值），快速重传（cwnd = cwnd/2 ，ssthresh = cwnd；进入快速恢复算法）
- 快速恢复：

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
重传丢失的数据包；
如果再收到重复的 ACK，那么 cwnd 增加 1；
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

## 41.Nagle 算法是如何避免大量 TCP 小数据报文的传输？
Nagle 算法做了一些策略来避免过多的小数据报文发送，这可提高传输效率。

MSS：最大报文段长度

	if 有数据要发送 {
	    if 可用窗口大小 >= MSS and 可发送的数据 >= MSS {
	    	立刻发送MSS大小的数据
	    } else {
	        if 有未确认的数据 {
	            将数据放入缓存等待接收ACK
	        } else {
	            立刻发送数据
	        }
	    }
	}

使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才能可以发送数据：

- 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；
- 条件二：收到之前发送数据的 ack 回包；

## 42.延迟确认是什么？

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK


## 43.什么是 TCP 半连接队列和全连接队列？
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。


## 44.如何优化 TCP?
[https://blog.csdn.net/m0_69305074/article/details/126302550](https://blog.csdn.net/m0_69305074/article/details/126302550)

**1.TCP 三次握手的性能提升**

- 调整 SYN 报文的重传次数
- 调整 SYN 半连接队列长度
- 调整 SYN+ACK 报文的重传次数
- 调整 accpet 队列长度
- 绕过三次握手

**客户端优化：**可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限；

**服务端优化：**当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。

**TCP Fast Open：** 当TCP连接使用完之后，客户端再次向服务器请求建立连接，报文中可以记录此前的Fast Open Cookie。服务器对Cookie进行校验之后，如果Cookie有效，就可以将数据给到程序处理，相当于**绕过了三次握手**，可以更快的建立连接。

**2.TCP 四次挥手的性能提升**

- 调整 FIN 报文重传次数
- 调整 FIN_WAIT2 状态的时间（只适用 close 函数关闭的连接）
- 调整孤儿连接的上限个数（只适用 close 函数关闭的连接）
- 调整 time_wait 状态的上限个数
- 复用 time_wait 状态的连接(只适用客户端)

**主动方：** 当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭；或者在建立新连接时，复用处于 TIME_WAIT 状态的连接（打开 tcp_tw_reuse 参数）<只用于客户端（建立连接的发起方），因为是在调用 connect() 时起作用的>；或者某些情况跳过四次挥手（用 close 发送RST信号）

**被动方：** 回复 ACK 后进入 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报文。



**3.TCP 数据传输的性能提升**

- 扩大窗口大小
- 调整发送缓冲区范围
- 调整接收缓冲区范围
- 打开接收缓冲区动态调节
- 调整内存范围

系统会为每个连接建立缓冲区， 接收缓冲区可以根据系统空闲内存的大小来调节接收窗口。

发送缓冲区的调节功能是自动开启的，接收缓冲区设置 tcp_moderate_rcvbuf=1 表示开启调节功能。

高并发服务中，可以调整缓冲区的动态调整可以达到最大宽带延积。如果服务是网络IO型的话，可以调大tcp_mem的上限，让TCP连接可以使用更多的系统内存，有利于提高并发。



## 45.调用 close 函数和 shutdown 函数有什么区别？
调用了 close 函数意味着完全断开连接，完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接]。

shutdown 函数可以控制只关闭一个方向的连接。

## 46.如果连接双方同时关闭连接，会怎么样？
由于 TCP 是双全工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 FIN 报文。

两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态；接下来，双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 `CLOSING` 的新状态，它替代了 FIN_WAIT2 状态。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。


## 47.为什么 TCP 是面向字节流的协议？
 TCP 是**面向字节流**的协议，UDP 是**面向报文**的协议，是因为操作系统对 TCP 和 UDP 协议的**发送方的机制不同**

- 当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。

- 当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。


## 48.如何解决粘包？
粘包的问题出现是因为不知道一个用户消息的边界在哪

- 固定长度的消息（每个用户消息都是固定长度的）；
- 特殊字符作为边界（两个用户消息之间插入一个特殊的字符串）；
- 自定义消息结构（自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大）。

## 49.为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？
- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

## 50.SYN 报文什么时候情况下会被丢弃？
1. 开启 tcp_tw_recycle 参数，并且在 NAT（Network Address Translation） 环境下，造成 SYN 报文被丢弃

如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；

如果客户端网络环境是用了 NAT 网关，那么客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。

1. TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃


## 51.已建立连接的TCP，收到SYN会发生什么？
**1. 客户端的 SYN 报文里的端口号与历史连接不相同**

如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。

如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。

如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。

**2. 客户端的 SYN 报文里的端口号与历史连接相同**

处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。

接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。


## 52.四次挥手中收到乱序的 FIN 包会如何处理？
在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「**乱序队列**」，并不会进入到 TIME_WAIT 状态。

等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，**如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文**，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。


## 53.在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？

关键是要看 SYN 的「序列号和时间戳」是否合法：

- 如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。
- 如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。

> 合法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。

>非法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。


## 54.TCP 连接，一端断电和进程崩溃有什么区别？

**TCP 保活机制（keepalive）**可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。

**在没有使用 TCP 保活机制且双方不传输数据的情况下**，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是**在内核完成，并不需要进程的参与**，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。

所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。

**因此，**

如果「**客户端进程崩溃**」，

- 客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手。

如果「**客户端主机宕机**」，

- 如果服务端会发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；
- 如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？
如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；
如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。


## 55.拔掉网线后， 原本的 TCP 连接还存在吗？
**有数据传输的情况：**

- 在客户端拔掉网线后，如果服务端发送了数据报文，那么在服务端重传次数没有达到最大值之前，客户端就插回了网线，那么双方原本的 TCP 连接还是能正常存在，就好像什么事情都没有发生。
- 在客户端拔掉网线后，如果服务端发送了数据报文，在客户端插回网线之前，服务端重传次数达到了最大值时，服务端就会断开 TCP 连接。等到客户端插回网线后，向服务端发送了数据，因为服务端已经断开了与客户端相同四元组的 TCP 连接，所以就会回 RST 报文，客户端收到后就会断开 TCP 连接。至此， 双方的 TCP 连接都断开了。

**没有数据传输的情况：**

- 如果双方都没有开启 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。
- 如果双方都开启了 TCP keepalive 机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。


## 56.tcp_tw_reuse 是什么？
在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的。
因此，客户端（主动关闭连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务器建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务器建立连接了。

Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接：

- net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，如果内核选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。所以该选项只适用于连接发起方。
- net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收，该参数在 NAT 的网络下是不安全的！


tcp_tw_reuse 的作用是**让客户端快速复用处于 TIME_WAIT 状态的端口，相当于跳过了 TIME_WAIT 状态**，这可能会出现这样的两个问题：

- 历史 RST 报文可能会终止后面相同四元组的连接，因为 PAWS 检查到即使 RST 是过期的，也不会丢弃。
- 如果第四次挥手的 ACK 报文丢失了，有可能被动关闭连接的一方不能被正常的关闭；


>PAWS 机制（ tcp_timestamps 选项）的作用是**防止 TCP 包中的序列号发生绕回**（带上发送时的时间戳）。因为TCP 这个 SEQ 号是有限的，一共 32 bit，SEQ 开始是递增，溢出之后从 0 开始再次依次递增，所以当 SEQ 号出现溢出后单纯通过 SEQ 号无法标识数据包的唯一性，某个数据包延迟或因重发而延迟时可能导致连接传递的数据被破坏。因此加上时间戳。



## 57.HTTPS 中 TLS 和 TCP 能同时握手吗？
HTTPS 是先进行 TCP 三次握手，再进行 TLS  四次握手

同时握手需要下面这两个条件同时满足才可以：

- 客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；
- 客户端和服务端已经完成过一次通信；

## 58.TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？
- HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销；
- TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制，，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

## 59.TCP 有什么缺陷？
- 升级 TCP 的工作很困难（TCP 协议是在内核中实现的，应用程序只能使用不能修改，如果要想升级 TCP 协议，那么只能升级内核）；
- TCP 建立连接的延迟（基于 TCP 实现的应用协议，都是需要先建立三次握手才能进行数据传输）；
- TCP 存在队头阻塞问题（TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的）；
- 网络迁移需要重新建立 TCP 连接（网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接）；


## 60.如何基于 UDP 协议实现可靠传输？

可以在UDP的基础上实现一些机制来增加可靠性

1. **应用层确认机制**：在应用层上，可以实现自定义的确认机制。发送方在发送数据后等待接收方的确认消息，如果在一定时间内未收到确认，则重新发送数据。这样可以确保数据的可靠传输。
1. **数据校验和重传**：在UDP数据包中添加校验和字段，接收方在接收数据时计算校验和并与发送方的校验和进行比较。如果不匹配，则要求发送方重新发送数据。
1. **序列号和确认号**：类似于TCP协议的序列号和确认号机制，发送方给每个数据包分配一个唯一的序列号，接收方收到数据后发送确认消息，并在其中包含确认号。发送方根据确认号判断哪些数据包已经被成功接收，可以进行相应的重传。
1. **超时重传**：发送方可以设置一个超时计时器，如果在指定时间内未收到确认消息，则认为数据丢失，触发重传操作。
1. **流量控制和拥塞控制**：通过控制发送数据的速率和接收数据的处理速度，可以避免网络拥塞和数据丢失。这可以通过动态调整发送速率、使用滑动窗口等方法来实现。


**QUIC 协议，已经应用在了 HTTP/3**

- QUIC 也是**需要三次握手来建立连接**的，主要目的是为了协商连接 ID。协商出连接 ID 后，后续传输时，双方只需要固定住连接 ID，从而实现连接迁移功能。（Long Packet Header 用于首次建立连接；Short Packet Header 用于日常传输数据。）
- Short Packet Header 中的 **Packet Number 是每个报文独一无二的编号，它是严格递增的**，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值（可以更加精确计算 RTT，没有 TCP 重传的歧义性问题）。
- QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动；
- 一个 Packet 报文中可以存放多个 QUIC Frame。每一个 Frame 都有明确的类型，针对类型的不同，功能也不同，自然格式也不同。


举例 Stream 类型的 Frame 格式，Stream 可以认为就是一条 HTTP 请求：

- Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；
- Offset 作用：类似于 TCP 协议中的 Seq 序号，保证数据的顺序性和可靠性；
- Length 作用：指明了 Frame 数据的长度。

Frame Header 这一层，通过 Stream ID + Offset 字段信息实现数据的有序性，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致。


## 61.什么情况会出现三次挥手？
当被动关闭方在 TCP 挥手过程中，「没有数据要发送」并且「**开启了 TCP 延迟确认机制**」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

**TCP 延迟确认机制**

当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 TCP 延迟确认。 TCP 延迟确认的策略：

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK。


因为延迟机制的存在，收到客户端的fin，服务端不会立马回ack，因为服务端收到了fin，这时候应用程序的read就会返回0，如果没用数据要发送，一般就是直接调用 close 了，如果在ack延迟的这段时间，刚好马上调用了close，于是就可以和 fin一起发送，也就是第二次挥手和第三次挥手合并发送了。


## 62.TCP 序列号和确认号是如何变化的？

- **序列号**：在建立连接时由内核生成的随机数作为其初始值，通过 SYN 报文传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。
- **确认号**：指下一次「期望」收到的数据的序列号，发送端收到接收方发来的 ACK 确认报文以后，就可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。
- **控制位**：用来标识 TCP 报文是什么类型的报文，比如是 SYN 报文、数据报文、ACK 报文，FIN 报文等。


发送的 TCP 报文：

**公式一**：序列号 = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。
**公式二**：确认号 = 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。


##  TCP 和 UDP 分别对应的常见应用层协议有哪些？
**1.TCP 对应的应用层协议**

- **FTP**：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。
- **Telnet**：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。
- **SMTP**：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。
- **POP3**：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。
- **HTTP**：从 Web 服务器传输超文本到本地浏览器的传送协议。

**2.UDP 对应的应用层协议**

- **DNS**：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。
- **SNMP**：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- **TFTP(Trival File Transfer Protocal)**：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。


## 谈谈你对停止等待协议的理解？
停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

# IP

## 63.IPv6 相比 IPv4 的首部改进

- 取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
- 取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。
- 取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。

## 64.ICMP 是什么？
ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。

ICMP 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。

ICMP 报文是**封装在 IP 包里面**，它工作在网络层，是 IP 协议的助手。

ICMP 包头的类型字段，大致可以分为两大类：

- 一类是用于诊断的查询消息，也就是「查询报文类型」
- 另一类是通知出错原因的错误消息，也就是「差错报文类型」


## 64.什么是127.0.0.1？
这是个 IPV4 地址。

IPV4 地址有 32 位，一个字节有 8 位，共 4 个字节。

其中127 开头的都属于回环地址，也是 IPV4 的特殊地址。

## 65.什么是 ping？
尝试发送一个小小的消息到目标机器上，判断目的机器是否可达，其实也就是判断目标机器网络是否能连通。

ping应用的底层，用的是网络层的ICMP协议。

虽然ICMP协议和IP协议都属于网络层协议，但其实ICMP也是利用了IP协议进行消息的传输。

## 66.0.0.1 和 localhost 以及 0.0.0.0 有区别吗
首先 localhost 就不叫 IP，它是一个**域名**，就跟 "baidu.com",是一个形式的东西，只不过默认会把它解析为 127.0.0.1 ，当然这可以在 /etc/hosts 文件下进行修改。

所以默认情况下，使用 localhost 跟使用 127.0.0.1 确实是没区别的。

其次就是 0.0.0.0，执行 ping 0.0.0.0 ，是会失败的，因为它在IPV4中表示的是无效的目标地址。但如果 listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。


##67.ARP 协议的工作原理？
ARP（Address Resolution Protocol）协议是一种在局域网中解析MAC地址的协议。

网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。

此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。


## 68.谈下你对 IP 地址分类的理解？
**IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异**。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。

**每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID**。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：

- A 类地址：以 0 开头，第一个字节范围：0~127；
- B 类地址：以 10 开头，第一个字节范围：128~191；
- C 类地址：以 110 开头，第一个字节范围：192~223；
- D 类地址：以 1110 开头，第一个字节范围为 224~239；
- E 类地址：以 1111 开头，保留地址


# 其他

## 什么是粘包？
1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；
2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。

基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。


## TCP 黏包是怎么产生的？

**发送方产生粘包**

采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

**接收方产生粘包**

接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

## 怎么解决拆包和粘包？
分包机制一般有两个通用的解决方法：

1. 特殊字符控制；
2. 在包头首都添加数据包的长度。

如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。

tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。

## forward 和 redirect 的区别？
Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。

**直接转发方式（Forward）**：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。

**间接转发方式（Redirect）**：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。

## 谈谈你对域名缓存的了解？
为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。**当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息**。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。

不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。

## HTTP 和 HTTPS 的区别？
1. **开销**：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；
2. **资源消耗**：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；
3. **端口不同**：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；
4. **安全性**：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

## HTTPS 的优缺点？
**优点：**

1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

**缺点：**

1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；
2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；
5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。


## 什么是数字签名？
为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。


## 什么是数字证书？
对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

## 什么是对称加密和非对称加密？
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。


## Session和Cookie的区别？
Cookie是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个Cookie，客户端就把Cookie保存起来。在客户端下次向同一服务器再发起请求时，Cookie被携带发送到服务器。服务器就是根据这个Cookie来确认身份的。

Session 指的就是服务器和客户端一次会话的过程。Session 利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个 Session 结束时，其实就是意味着这个Cookie就过期了。Session对象存储着特定用户会话所需的属性及配置信息。

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在Cookie信息，如果存在，则自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID查找对应的 Session信息，如果没有找到，说明用户没有登录或者登录失效，如果找到Session证明用户已经登录可执行后面操作。

## 有了IP地址，为什么还要用MAC地址？
标识网络中的一台计算机，比较常用的就是IP地址和MAC地址，但**计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改**，所以一般会把IP地址和MAC地址组合起来使用。

- 那只使用MAC地址不用IP地址行不行呢？不行的！因为最早就是MAC地址先出现的，并且当时并不用 IP 地址，**只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂**，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。
- 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样**路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间**，是无法实现的。

IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。


