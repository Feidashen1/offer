# 网络基础

## 1.TCP/IP 网络模型有哪几层？
**1. 应用层**：专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等，而且应用层是工作在操作系统中的*用户态*，传输层及以下则工作在*内核态*。

通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。把应用层交互的数据单元称为**报文**。

**2.传输层**：应用层的数据包会传给传输层，传输层是为应用层提供网络支持的。在传输层会有两个传输协议，分别是 TCP 和 UDP。

主要任务就是负责向两台主机进程之间的通信提供通用的**数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。**一台机可同时运行多个线程，因此运输层有复用和分用的功能。**

**3.网络层**：不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层。网络层最常使用的是 IP 协议。

任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 **IP 数据报**，简称**数据报**。

**4.网络接口层（链路层）**：生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 **MAC 头部**，并封装成数据帧（Data frame）发送到网络上。

数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。

**OSI模型（七层）**：应用层、表示层、会话层（前三层统一表示为应用层）、传输层、网络层、数据链路层、物理层(后两层统一表示为网络接口层)

>- 应用层，负责给应用程序提供统一的接口；
>- 表示层，负责把数据转换成兼容另一个系统能识别的格式；
>- 会话层，负责建立、管理和终止表示层实体之间的通信会话；
>- 传输层，负责端到端的数据传输；
>- 网络层，负责数据的路由、转发、分片；
>- 数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；
>- 物理层，负责在物理网络中传输数据帧；



## 2.简单说下每一层对应的网络协议有哪些？
**应用层：**

- 超文本传输协议：HTTP
- 文件传输协议：FTP
- 简单邮件传输协议：SMTP
- 域名系统：DNS
- 安全外壳协议：SSH
- 动态主机配置协议：DHCP
- 远程登录协议：TELNET

**传输层：**

- 传输控制协议：TCP
- 用户数据报文协议：UDP

**网络层：**

- 网际协议：IP
- ARP：地址转换协议
- RARP：反向地址转换协议
- ICMP：Internet 控制报文协议
- IGMP：Internet 组管理协议
- RIP：路由信息协议
- OSPF：分布式链路状态协议
- BGP：边界网关协议


**数据链路层：**

- 自动重传请求协议：ARQ
- 停止等待协议：CSMA/CD
- 点对点协议：PPP


**物理层：**

- 中继器
- 集线器
- 网线
- HUB

## 3.键入网址到网页显示，期间发生了什么？
1.要**对 URL 进行解析**（URL 实际上是请求服务器里的文件资源）；
> 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件

2.对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，根据这些信息来**生成 HTTP 请求消息**（GET, POST）；

3.**查询服务器域名对应的 IP 地址**（解析DNS域名），因为委托操作系统发送消息时，必须提供通信对象的 IP 地址；
    
> DNS 服务器专门保存了 Web 服务器域名与 IP 的对应关系；
> DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。

4.通过 DNS 获取到 IP 后，就可以**把 HTTP 的传输工作交给操作系统中的协议栈**(应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作)；

> 协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。


>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
>此外 IP 中还包括 ICMP 协议和 ARP 协议。

> - ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
> - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。
一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：

> 0800 ： IP 协议
> 0806 ： ARP 协议


5.发送 http 请求（网卡、交换机、路由器）

6.服务器处理请求（MAC->IP->TCP头->HTTP 进程），并返回响应（HTTP 响应报文）

7.接收响应并显示网页






## 4.Linux 系统是如何收发网络包的？
当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。

**Linux发包**：应用程序会调用 Socket 发送数据包的接口，内核会申请一个 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区，然后网络协议栈从 Socket 发送缓冲区中取出 sk_buff，先进入传输层，如果使用的是 TCP 协议发送数据，会先拷贝一个sk_buff 副本 ，然后为副本添加TCP头部，本来的sk_buff就留在传输层，接着sk_buff副本在网络层添加上IP头部，然后在网络接口层添加上帧头（帧头包括了MAC头部）和帧尾，最后将 sk_buff 放到网卡的发送队列中。随后会触发「软中断」告诉网卡驱动程序，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 Ring Buffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。当数据发送完成以后，网卡会触发一个硬中断来释放内存，主要是释放 sk_buff 内存和清理 Ring Buffer 内存。


而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。

**Linux收包**：网卡收到网络包之后会通过 DMA（直接存储器访问） 技术将网络包写入 RingBuffer 环形缓冲区，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。硬件中断函数先暂时屏蔽中断(下一次就直接写入内存而不通知CPU)，再发起软中断，软中断调用 ksoftirqd 线程从 Ring Buffer 中获取一个数据帧，用 sk_buffer(socket_buffer，一种数据类型)表示，然后由网络协议栈处理，先进入网络接口层，去掉帧头和帧尾，再进入网络层，去掉IP头部，接着进入传输层去掉TCP 头或 UDP 头，根据四元组「源 IP、目的 IP、源端口、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。最后，应用层程序调用 Socket 接口，将缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。



## 5.发送网络数据的时候，涉及几次内存拷贝操作？
第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。

第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。

第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。


# HTTP 相关

## 5.HTTP 是什么？
HTTP 是**超文本传输协议**，也就是HyperText Transfer Protocol。
由三个部分组成：

- 超文本：传输的内容
- 传输：两点之间传输数据的约定和规范
- 协议：计算机交流通信的规范，以及相关的各种控制和错误处理方式；

HTTP 协议是一个双向协议


## 6.HTTP 常见的状态码有哪些？
| | 具体含义 | 常见的状态码  |
| - | - | - |
| 1xx | 提示信息，是协议处理中的一种中间状态，还需要后续操作 |  |
| 2xx | 成功，报文已经收到，并被正确处理 | 200，204，206 |
| 3xx | 重定向，资源位置发生变动，需要客户端重新发送请求| 301，302，304  |
| 4xx | 客户端错误，请求报文有误，服务器无法处理 | 400，403，404 |
| 5xx | 服务器错误，服务器在处理请求时内部发生了错误 | 500，501，502，503 |


- 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
- 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

#7.HTTP 常见字段有哪些？
**Host 字段**：
客户端发送请求时，用来指定服务器的域名。

**Content-Length 字段**：
服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。

**Connection 字段**：
最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。

> HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

**Content-Type 字段**：
用于服务器回应时，告诉客户端，本次数据是什么格式。

**Content-Encoding 字段**：
说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式


**Accept 字段**：
声明自己可以接受哪些数据格式


## 8.GET 和 POST 有什么区别？
GET 的语义是**从服务器获取指定的资源**。
> GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。

POST 的语义是**根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。
> POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

## 9.GET 和 POST 方法都是安全和幂等的吗？
- 在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

**GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是**安全的**，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。

POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全的**，且多次提交数据就会创建多个资源，所以**不是幂等的**。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。

## 10.GET 请求可以带 body 吗？
RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

## 11.HTTP 缓存有哪些实现方式？
强制缓存和协商缓存

**强制缓存**指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
`Cache-Control`， 是一个相对时间；
`Expires`，是一个绝对时间；Cache-Control 的优先级高于 Expires 。第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小。后续服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。


**协商缓存**就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

**协商缓存的两种实现都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。**

## 12.HTTP/1.1 的优缺点？
HTTP 优点：「简单、灵活和易于扩展、应用广泛和跨平台」；

HTTP 缺点：「无状态、明文传输」，「不安全」


## 13.HTTP/1.1 的性能如何？

HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式

1.长连接：
减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

2.管道网络传输：
在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

3.队头阻塞：
当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞。

HTTP/1.1 的性能一般般


## 14.HTTP 与 HTTPS 有哪些区别？
- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则**解决 HTTP 不安全的缺陷**，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。（Secure Sockets Layer，SSL；Transport Layer Security，TLS）
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 15.SSL/TLS 协议基本流程

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

**TLS 的「握手阶段」涉及四次通信：**

1. 由客户端向服务器发起加密通信请求，也就是 ClientHello 请求：客户端生产的随机数（Client Random），客户端支持的密码套件列表。
2. 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello：服务器生产的随机数（Server Random），确认的密码套件列表，服务器的数字证书。
3. 客户端回应：客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA（证书认证机构） 公钥，确认服务器的数字证书的真实性。向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

4. 服务器的最后回应：服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」，然后，向客户端发送最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。

## 16.HTTP/1.1、HTTP/2、HTTP/3 演变？


HTTP/2 相比 HTTP/1.1 性能上的改进：

- 头部压缩：消除头部重复的部分
- 二进制格式：头信息和数据体都是二进制，并且统称为帧（frame）--->头信息帧（Headers Frame）和数据帧（Data Frame）
- 并发传输：引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接（Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号）
- 服务器主动推送资源：服务端不再是被动地响应，可以主动向客户端发送消息

HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。

HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！

- 无队头阻塞：当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。
- 更快的连接建立
- 连接迁移


## 17.HTTP/1.1 如何优化？
- 尽量避免发送 HTTP 请求（缓存）；
- 在需要发送 HTTP 请求时，考虑如何减少请求次数（减少重定向请求次数、合并请求、延迟发送请求）；
- 减少服务器的 HTTP 响应的数据大小（无损压缩、有损压缩）；


## 18.RPC和HTTP的区别？
RPC（Remote Procedure Call），又叫做**远程过程调用**。它本身并不是一个具体的协议，而是一种调用方式。

虽然大部分 RPC 协议底层使用 TCP，但实际上它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。

**1.服务发现**

- HTTP ：知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。
- RPC ：一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。

**2.底层连接形式**

- HTTP：默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。
- RPC：也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用

**3.传输的内容**

- HTTP：内容非常多的冗余，显得非常啰嗦
- RPC：定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为。


## 19.WebSocket是什么？
WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）

它实现了浏览器与服务器**全双工通信**，能更好的节省服务器资源和带宽并达到实时通讯的目的（Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据）

Websocket是一个持久化的协议

websocket 约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似 tcp 的连接，从而方便它们之间的通信；在 websocket 出现之前，we b交互一般是基于 http 协议的短连接或者长连接；
websocket是一种全新的协议，不属于 http 无状态协议，协议名为"ws"




## 20.websocket 与 http的关系？
**相同点：**

- 都是基于tcp的，都是可靠性传输协议
- 都是应用层协议

**不同点：**

- WebSocket 是双向通信协议，模拟Socket协议，可以双向发送或接受信息；HTTP是单向的
- WebSocket 是需要浏览器和服务器握手进行建立连接的；而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。

<font color="#F100">WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。</font>

[什么是websocket？](https://blog.csdn.net/weixin_47428270/article/details/126639625)




----------

# TCP

## 21.为什么需要 TCP 协议？ TCP 工作在哪一层？
IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

TCP 是一个工作在**传输层**的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

## 22.什么是 TCP ？

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

**面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；

**可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；

**字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

## 23.什么是 TCP 连接？
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为**连接**。

建立一个 TCP 连接是需要客户端与服务端达成下述三个信息的共识：

- Socket：由 IP 地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制

## 24.如何唯一确定一个 TCP 连接？
TCP 四元组可以唯一的确定一个连接，四元组包括如下：

- 源地址
- 源端口
- 目的地址
- 目的端口

源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

## 25.有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？
客户端 IP 和端口是可变的，其理论值是：客户端的IP数 × 客户端的端口数

对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。

服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：

**文件描述符限制**，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：

- **系统级**：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；
- **用户级**：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；
- **进程级**：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；

**内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。


## 26.UDP 和 TCP 有什么区别？
TCP 的全称叫**传输控制协议（Transmission Control Protocol）**，大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能**可靠地**传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它**实时性**相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以。

**1.连接**
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。

**2.服务对象**
TCP 是一对一的两点服务，即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信。

**3.可靠性**
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
UDP 是尽最大努力交付，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个可靠的传输协议。

**4. 拥塞控制、流量控制**
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

**5.首部开销**
TCP首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

**6.传输方式**
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

**7.分片不同**
TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP 文件传输；
- HTTP / HTTPS；

UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等；
- 视频、音频等多媒体通信；
- 广播通信；

## 27.TCP 和 UDP 可以使用同一个端口吗？
可以。

传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。
TCP 和 UDP，在内核中是两个完全独立的软件模块。
当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。

因此， TCP/UDP 各自的端口号也相互独立，二者并不冲突。

## 28.TCP 三次握手过程是怎样的？
- 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态；
- 客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
- 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，**这次报文可以携带客户到服务端的数据**，之后客户端处于 ESTABLISHED 状态。
- 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。


<font color = "#F100">第三次握手是可以携带数据的，前两次握手是不可以携带数据的</font>

## 29.TCP 需要三次握手的原因？

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号（接收方可以去除重复的数据；
接收方可以根据数据包的序列号按序接收；
可以标识发送出去的数据包中， 哪些是已经被对方收到的<通过 ACK 报文中的序列号知道>；）
- 三次握手才可以避免资源浪费

## 30.既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
-** MTU**：一个网络包的最大长度，以太网中一般为 1500 字节；
- **MSS**：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

如果在TCP的整个报文（头部+数据）交给IP层进行分片，当某一个IP分片丢失后，接收方的 IP 层就无法组装成一个完整的TCP报文，也就无法将数据报文送给TCP层，所以接收方不会响应ACK给发送方，因为发送方迟迟收不到ACK确认报文，所以就会触发超时重传，就会重发整个TCP报文(头部+数据)。

当 TCP 层发现数据超过 MSS 时，则会先进行分片，分片后的形成的 IP 包自然不会超过 MTU，也就不用 IP 进行分片了。此时，如果一个TCP分片丢失后，进行重发也是MSS为单位的，而不用重发所有数据，大大增加了重传的效率。

## 31.三次握手出现问题

**当第一次握手丢失了，客户端会发生超时重传：**
重传 SYN 报文，而且*重传的 SYN 报文的序列号都是一样的*

**当第二次握手丢失了，客户端和服务端都会超时重传：**

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。

**第三次握手丢失了，服务端超时重传：**
重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。
*ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文*。


## 32.TCP 四次挥手过程是怎样的？
- 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，也即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。
- 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
- 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。


## 33.四次挥手出现问题
**第一次挥手丢失：**
客户端迟迟收不到被动方的 ACK 的话，也就会触发**超时重传机制（时间为上一次超时时间的2倍），重传 FIN 报文**，重发次数由 tcp_orphan_retries 参数控制。

**服务端的第二次挥手丢失**：
客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。（ACK不会重传）

>当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 FIN_WAIT2 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。

> 对于 close 函数关闭的连接，由于无法再发送和接收数据，所以 FIN_WAIT2  状态不可以持续太久，而 tcp_fin_timeout 控制了这个状态下连接的持续时长，默认值是 60 秒。
>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。


>如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态（**tcp_fin_timeout 无法控制 shutdown 关闭的连接**）


**第三次挥手丢失**：
服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭，迟迟收不到这个 ACK，服务端就会重发 FIN 报文（超时重传）。

**第四次挥手丢失：**
如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制。

客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会**重置定时器**。

达到重传次数上限后，如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。


## 34.为什么 TIME_WAIT 等待的时间是 2MSL？
MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个  TTL  （Time to Live，生存时间）字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。

TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。

TIME_WAIT 等待 2 倍的 MSL，是因为网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。


## 35.为什么需要 TIME_WAIT 状态？
- 1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收（**序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**）：
TIME_WAIT 的 2MSL 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
- 2.保证「被动关闭连接」的一方，能被正确的关闭：**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**。

## 36.如果已经建立了连接，但是服务端的进程崩溃会发生什么？
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以**即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程**。


## 37.TCP滑动窗口大小由哪一方决定？
接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

## 38.接收窗口和发送窗口的大小是相等的吗？
并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。

因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

## 39.什么是TCP流量控制？
两个应用程序通过 TCP 协议在网络中传输数据时，双方在硬件性能和软件性能上均可能存在差异，导致双方处理数据的速度不一致。当发送方的发送速度低于接收方接的处理速度时，不会出现问题。而当发送方的发送速度高于接收方的处理速度时，接收方会抛弃暂时无法“安置”的数据包。由于这些丢弃的数据包得不到确认，发送方会重新发送它们，直到他们被成功接收，造成资源浪费。TCP流量控制就是确保发送方的发送速度不要超出接收方的处理能力。

发送发和接收方都维护一个数据池来处理数据，称之为Buffer。发送方不断地将要发送的数据送入sender buffer，接收方不断地从receiver buffer里获取数据。

当接收方的receiver buffer已满时，发送方则暂时停止发送数据。


## 40.流量控制和拥塞控制的不同？

- 流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。
- 拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络

只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。

拥塞控制主要是四个算法：

- 慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1；
- 拥塞避免：拥塞窗口大于慢启动门限（ssthresh）时会启动拥塞避免算法（每当收到一个 ACK 时，cwnd 增加 1/cwnd）；
- 拥塞发生：超时重传（ssthresh 设为 cwnd/2，cwnd 重置为初始值），快速重传（cwnd = cwnd/2 ，ssthresh = cwnd；进入快速恢复算法）
- 快速恢复：

拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
重传丢失的数据包；
如果再收到重复的 ACK，那么 cwnd 增加 1；
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

## 41.Nagle 算法是如何避免大量 TCP 小数据报文的传输？
Nagle 算法做了一些策略来避免过多的小数据报文发送，这可提高传输效率。

MSS：最大报文段长度

	if 有数据要发送 {
	    if 可用窗口大小 >= MSS and 可发送的数据 >= MSS {
	    	立刻发送MSS大小的数据
	    } else {
	        if 有未确认的数据 {
	            将数据放入缓存等待接收ACK
	        } else {
	            立刻发送数据
	        }
	    }
	}

使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才能可以发送数据：

- 条件一：要等到窗口大小 >= MSS 并且 数据大小 >= MSS；
- 条件二：收到之前发送数据的 ack 回包；

## 42.延迟确认是什么？

- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK


## 43.什么是 TCP 半连接队列和全连接队列？
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。


## 44.如何优化 TCP?
[https://blog.csdn.net/m0_69305074/article/details/126302550](https://blog.csdn.net/m0_69305074/article/details/126302550)

**1.TCP 三次握手的性能提升**

- 调整 SYN 报文的重传次数
- 调整 SYN 半连接队列长度
- 调整 SYN+ACK 报文的重传次数
- 调整 accpet 队列长度
- 绕过三次握手

**客户端优化：**可以根据网络的稳定性和目标服务器的繁忙程度修改 SYN 的重传次数，调整客户端的三次握手时间上限；

**服务端优化：**当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。

**TCP Fast Open：** 当TCP连接使用完之后，客户端再次向服务器请求建立连接，报文中可以记录此前的Fast Open Cookie。服务器对Cookie进行校验之后，如果Cookie有效，就可以将数据给到程序处理，相当于**绕过了三次握手**，可以更快的建立连接。

**2.TCP 四次挥手的性能提升**

- 调整 FIN 报文重传次数
- 调整 FIN_WAIT2 状态的时间（只适用 close 函数关闭的连接）
- 调整孤儿连接的上限个数（只适用 close 函数关闭的连接）
- 调整 time_wait 状态的上限个数
- 复用 time_wait 状态的连接(只适用客户端)

**主动方：** 当 TIME_WAIT 的连接数量超过该参数时，新关闭的连接就不再经历 TIME_WAIT 而直接关闭；或者在建立新连接时，复用处于 TIME_WAIT 状态的连接（打开 tcp_tw_reuse 参数）<只用于客户端（建立连接的发起方），因为是在调用 connect() 时起作用的>；或者某些情况跳过四次挥手（用 close 发送RST信号）

**被动方：** 回复 ACK 后进入 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报文。



**3.TCP 数据传输的性能提升**

- 扩大窗口大小
- 调整发送缓冲区范围
- 调整接收缓冲区范围
- 打开接收缓冲区动态调节
- 调整内存范围

系统会为每个连接建立缓冲区， 接收缓冲区可以根据系统空闲内存的大小来调节接收窗口。

发送缓冲区的调节功能是自动开启的，接收缓冲区设置 tcp_moderate_rcvbuf=1 表示开启调节功能。

高并发服务中，可以调整缓冲区的动态调整可以达到最大宽带延积。如果服务是网络IO型的话，可以调大tcp_mem的上限，让TCP连接可以使用更多的系统内存，有利于提高并发。



## 45.调用 close 函数和 shutdown 函数有什么区别？
调用了 close 函数意味着完全断开连接，完全断开不仅指无法传输数据，而且也不能发送数据。 此时，调用了 close 函数的一方的连接叫做「孤儿连接]。

shutdown 函数可以控制只关闭一个方向的连接。

## 46.如果连接双方同时关闭连接，会怎么样？
由于 TCP 是双全工的协议，所以是会出现两方同时关闭连接的现象，也就是同时发送了 FIN 报文。

两方发送 FIN 报文时，都认为自己是主动方，所以都进入了 FIN_WAIT1 状态；接下来，双方在等待 ACK 报文的过程中，都等来了 FIN 报文。这是一种新情况，所以连接会进入一种叫做 `CLOSING` 的新状态，它替代了 FIN_WAIT2 状态。接着，双方内核回复 ACK 确认对方发送通道的关闭后，进入 TIME_WAIT 状态，等待 2MSL 的时间后，连接自动关闭。


## 47.为什么 TCP 是面向字节流的协议？
 TCP 是**面向字节流**的协议，UDP 是**面向报文**的协议，是因为操作系统对 TCP 和 UDP 协议的**发送方的机制不同**

- 当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。

- 当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。


## 48.如何解决粘包？
粘包的问题出现是因为不知道一个用户消息的边界在哪

- 固定长度的消息（每个用户消息都是固定长度的）；
- 特殊字符作为边界（两个用户消息之间插入一个特殊的字符串）；
- 自定义消息结构（自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大）。

## 49.为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？
- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；

## 50.






## .ARP 协议的工作原理？
ARP（Address Resolution Protocol）协议是一种在局域网中解析MAC地址的协议。


## 谈下你对 IP 地址分类的理解？


## TCP 的主要特点是什么？


## UDP 的主要特点是什么？



## TCP 和 UDP 的区别？



## TCP 和 UDP 分别对应的常见应用层协议有哪些？



## 详细说下 TCP 三次握手的过程？



## 为什么两次握手不可以呢？



## 为什么不需要四次握手？



## Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？


## 传了 SYN，为什么还要传 ACK？



## 详细说下 TCP 四次挥手的过程？



## 为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？



## 为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?


## 保活计时器的作用？



## TCP 协议是如何保证可靠传输的？



## 谈谈你对停止等待协议的理解？



## 谈谈你对 ARQ 协议的理解？


## 谈谈你对滑动窗口的了解？


## 谈下你对流量控制的理解？


## 谈下你对 TCP 拥塞控制的理解？使用了哪些算法？



## 什么是粘包？


## TCP 黏包是怎么产生的？



## 怎么解决拆包和粘包？



## 你对 HTTP 状态码有了解吗？


## forward 和 redirect 的区别？


## HTTP 方法有哪些？


## 说下 GET 和 POST 的区别？


## 在浏览器中输入 URL 地址到显示主页的过程？



## DNS 的解析过程？


## 谈谈你对域名缓存的了解？


## 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？


## 谈下 HTTP 1.0 和 1.1、1.2 的主要变化？


## HTTPS 的工作过程？


## HTTP 和 HTTPS 的区别？


## HTTPS 的优缺点？

## 什么是数字签名？


## 什么是数字证书？


