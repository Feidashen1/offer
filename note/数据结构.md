# 复杂度
## 1.尾递归的空间复杂度是 O(1) 吗？
理论上，尾递归函数的空间复杂度可以优化至 𝑂(1) 。不过绝大多数编程语言（例如 Java、Python、C++、Go、C# 等）不支持自动优化尾递归，因此通常认为空间复杂度是 O(n) 。


## 2.函数和方法这两个术语的区别是什么？
「函数 function」可以被独立执行，所有参数都以显式传递。

「方法 method」与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。


# 数据结构
## 1.为什么哈希表同时包含线性数据结构和非线性数据结构？
哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。

从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。

## 2. char 类型的长度是 1 字节吗？
char 类型的长度由编程语言采用的编码方法决定。例如，Java、JavaScript、TypeScript、C# 都采用 UTF‑16编码（保存 Unicode 码点），因此 char 类型的长度为 2 字节。


## 3.基于数组实现的数据结构也称“静态数据结构”是否有歧义？栈也可以进行出栈和入栈等操作，这些操作都是“动态”的。

栈确实可以实现动态的数据操作，但**数据结构仍然是“静态”（长度不可变）的**。

尽管基于数组的数据结构可以动态地添加或删除元素，但它们的容量是固定的。如果数据量超出了预分配的大小，就需要创建一个新的更大的数组，并将旧数组的内容复制到新数组中。

## 4.在构建栈（队列）的时候，未指定它的大小，为什么它们是“静态数据结构”呢？
在高级编程语言中，我们无须人工指定栈（队列）的初始容量，这个工作由类内部自动完成。例如，Java 的ArrayList 的初始容量通常为 10。另外，扩容操作也是自动实现的。


# 数组和链表

## 1.数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？
存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。

1. **分配和释放效率**：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。
2. **大小限制**：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。
3. **灵活性**：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。


## 2.为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？
链表由节点组成，节点之间通过引用（指针）连接，各个节点可以存储不同类型的数据，例如 int 、 double 、string 、 object 等。

相对地，数组元素则必须是相同类型的，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节 和 8 字节，此时就不能用以下公式计算偏移量了，因为数组中包含了两种“元素长度”。

**元素内存地址 = 数组内存地址（首元素内存地址） + 元素长度 * 元素索引**

## 3.删除节点后，是否需要把 P.next 设为 None 呢？
不修改 P.next 也可以。从该链表的角度看，从头节点遍历到尾节点已经不会遇到 P 了。这意味着节点 P 已经从链表中删除了，此时节点 P 指向哪里都不会对该链表产生影响。

从垃圾回收的角度看，对于 Java、Python、Go 等拥有自动垃圾回收机制的语言来说，节点 P 是否被回收取决于是否仍存在指向它的引用，而不是 P.next 的值。在 C 和 C++ 等语言中，我们需要手动释放节点内存。

## 4.在链表中插入和删除操作的时间复杂度是 O(1) 。但是增删之前都需要 O(n) 的时间查找元素，那为什么时间复杂度不是 O(n) 呢？

如果是先查找元素、再删除元素，时间复杂度确实是 O(n) 。然而，链表的 O(1) 增删的优势可以在其他应用上得到体现。

例如，双向队列适合使用链表实现，我们维护一个指针变量始终指向头节点、尾节点，每次插入与删除操作都是 O(1) 。

## 5.在列表末尾添加元素是否时时刻刻都为O(1)？
如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 O(n) 。

## 6.列表的出现极大地提高了数组的实用性，但可能导致部分内存空间浪费”，这里的空间浪费是指额外增加的变量如容量、长度、扩容倍数所占的内存吗？

这里的空间浪费主要有两方面含义：

- 一方面，列表都会设定一个初始长度，我们不一定需要用这么多；
- 另一方面，为了防止频繁扩容，扩容一般会乘以一个系数，比如 ×1.5 。这样一来，也会出现很多空位，我们通常不能完全填满它们。


## 7.C++ STL 里面的 std::list 已经实现了双向链表，但好像一些算法书上不怎么直接使用它，是不是因为有什么局限性呢？

一方面，我们往往更青睐使用数组实现算法，而只在必要时才使用链表，主要有两个原因。

- **空间开销**：由于每个元素需要两个额外的指针（一个用于前一个元素，一个用于后一个元素），所以std::list 通常比 std::vector 更占用空间。
-  **缓存不友好**：由于数据不是连续存放的，因此 std::list 对缓存的利用率较低。一般情况下， std::vector的性能会更好。

另一方面，必要使用链表的情况主要是二叉树和图。栈和队列往往会使用编程语言提供的 stack 和 queue ，而非链表。


##8.初始化列表 res = [0] * self.size() 操作，会导致 res 的每个元素引用相同的地址吗？

不会。但二维数组会有这个问题，例如初始化二维列表 res = [[0] * self.size()] ，则多次引用了同一个列表 [0] 。


## 9.在删除节点中，需要断开该节点与其后继节点之间的引用指向吗？
从数据结构与算法（做题）的角度看，不断开没有关系，只要保证程序的逻辑是正确的就行。

从标准库的角度看，断开更加安全、逻辑更加清晰。如果不断开，假设被删除节点未被正常回收，那么它会影响后继节点的内存回收。


# 栈与队列
## 1.浏览器的前进后退是否是双向链表实现？
浏览器的前进后退功能本质上是“栈”的体现。当用户访问一个新页面时，该页面会被添加到栈顶；当用户点击后退按钮时，该页面会从栈顶弹出。使用双向队列可以方便地实现一些额外操作。

## 2.在出栈后，是否需要释放出栈节点的内存？
如果后续仍需要使用弹出节点，则不需要释放内存。

## 3.双向队列像是两个栈拼接在了一起，它的用途是什么？
双向队列就像是栈和队列的组合或两个栈拼在了一起。它表现的是栈 + 队列的逻辑，因此可以实现栈与队列的所有应用，并且更加灵活。

## 4.撤销（undo）和反撤销（redo）具体是如何实现的？
使用两个栈，栈 A 用于撤销，栈 B 用于反撤销。

1. 每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。
2. 当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。
3. 当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。


# 哈希表
## 1.哈希表的时间复杂度在什么情况下是 O(n) ？
当哈希冲突比较严重时，哈希表的时间复杂度会退化至 O(n)。

当哈希函数设计得比较好、容量设置比较合理、冲突比较平均时，时间复杂度是 O(1) 。我们使用编程语言内置的哈希表时，通常认为时间复杂度是 O(1) 。

## 2.为什么不使用哈希函数 f(x) = x 呢？这样就不会有冲突了。
在 f(x) = x 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。
然而，输入空间通常远大于输出空间（数组长度），因此哈希函数的最后一步往往是对数组长度取模。

换句话说，**哈希表的目标是将一个较大的状态空间映射到一个较小的空间**，并提供 𝑂(1) 的查询效率。

## 3.哈希表底层实现是数组、链表、二叉树，但为什么效率可以比它们更高呢？
首先，哈希表的时间效率变高，但空间效率变低了。哈希表有相当一部分内存未使用。

其次，只是在特定使用场景下时间效率变高了。如果一个功能能够在相同的时间复杂度下使用数组或链表实现，那么通常比哈希表更快。这是因为哈希函数计算需要开销，时间复杂度的常数项更大。

最后，哈希表的时间复杂度可能发生劣化。例如在链式地址中，我们采取在链表或红黑树中执行查找操作，仍然有退化至 O(n) 时间的风险。


## 4.多次哈希有不能直接删除元素的缺陷吗？标记为已删除的空间还能再次使用吗？

多次哈希是开放寻址的一种，开放寻址法都有不能直接删除元素的缺陷，需要通过标记删除。

标记为已删除的空间可以再次使用。当将新元素插入哈希表，并且通过哈希函数找到标记为已删除的位置时，该位置可以被新元素使用。这样做既能保持哈希表的探测序列不变，又能保证哈希表的空间使用率。

## 5.为什么在线性探测中，查找元素的时候会出现哈希冲突呢？

查找的时候通过哈希函数找到对应的桶和键值对，发现 key 不匹配，这就代表有哈希冲突。因此，线性探测法会根据预先设定的步长依次向下查找，直至找到正确的键值对或无法找到跳出为止。


## 6.为什么哈希表扩容能够缓解哈希冲突？
哈希函数的最后一步往往是对数组长度 k 取模（取余），让输出值落在数组索引范围内；在扩容后，数组长度 n 发生变化，而 key 对应的索引也可能发生变化。原先落在同一个桶的多个 key ，在扩容后可能会被分配到多个桶中，从而实现哈希冲突的缓解。



# 堆

## 1.数据结构的“堆”与内存管理的“堆”是同一个概念吗？
两者不是同一个概念，只是碰巧都叫“堆”。
计算机系统内存中的堆是动态内存分配的一部分，程序在运行时可以使用它来存储数据。程序可以请求一定量的堆内存，用于存储如对象和数组等复杂结构。当这些数据不再需要时，程序需要释放这些内存，以防止内存泄漏。

相较于栈内存，堆内存的管理和使用需要更谨慎，使用不当可能会导致内存泄漏和野指针等问题。

# 树
## 1.如何从一组输入数据构建一棵二叉搜索树？根节点的选择是不是很重要？

是的，构建树的方法已在二叉搜索树代码中的 build_tree() 方法中给出。至于根节点的选择，我们通常会
将输入数据排序，然后将中点元素作为根节点，再递归地构建左右子树。这样做可以最大程度保证树的平衡
性。

## 2.对于只有一个节点的二叉树，树的高度和根节点的深度都是 0 吗？
是的，因为高度和深度通常定义为“经过的边的数量”。


## 3.二叉树中的插入与删除一般由一套操作配合完成，这里的“一套操作”指什么呢？可以理解为资源的子节点的资源释放吗？

拿二叉搜索树来举例，删除节点操作要分三种情况处理，其中每种情况都需要进行多个步骤的节点操作。


## 4.为什么 DFS 遍历二叉树有前、中、后三种顺序，分别有什么用呢？
顺序和逆序遍历数组类似，前序、中序、后序遍历是三种二叉树遍历方法，我们可以使用它们得到一个特定顺序的遍历结果。例如在二叉搜索树中，由于节点大小满足 左子节点值 < 根节点值 < 右子节点值 ，因此我们只要按照“左 → 根 → 右”的优先级遍历树，就可以获得有序的节点序列。

## 5.右旋操作是处理失衡节点 node 、 child 、 grand_child 之间的关系，那 node 的父节点和 node 原来的连接不需要维护吗？右旋操作后岂不是断掉了？
需要从递归的视角来看这个问题。右旋操作 right_rotate(root) 传入的是子树的根节点，最终 return child 返回旋转之后的子树的根节点。子树的根节点和其父节点的连接是在该函数返回后完成的，不
属于右旋操作的维护范围。

## 6.在 C++ 中，函数被划分到 private 和 public 中，这方面有什么考量吗？为什么要将 height() 函数和updateHeight() 函数分别放在 public 和 private 中呢？
主要看方法的使用范围，如果方法只在类内部使用，那么就设计为 private 。例如，用户单独调用 updateHeight() 是没有意义的，它只是插入、删除操作中的一步。而 height() 是访问节点高度，类似于 vector.size() ，因此设置成 public 以便使用。


## 7.广度优先遍历到最底层之前，队列中的节点数量是 2^ℎ 吗？
是的，例如高度 ℎ = 2 的满二叉树，其节点总数 𝑜 = 7 ，则底层节点数量 4 = 2^ℎ = (n + 1)/2 。



