# C++

----------

## 1.C++ 在 main() 函数执行前，后执行了哪些操作?
main 函数执行之前，主要就是初始化系统相关资源：

1. 设置栈指针：栈分配相关的位置，用来放一些局部变量和其他数据；
2. 初始化 static 静态和 global 全局变量，即 data 段的内容：**把全局和静态变量初始化**；
3. 将未初始化部分的全局变量赋初值：数值型 short，int，long 等为0，bool 为FALSE，指针为NULL，等等，即 .bss 段的内容：**将未设置初值的全局变量赋初值**；
4. 全局对象初始化，在main之前调用构造函数；
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。

在执行完 main 函数后：执行全局的析构函数，要销毁堆内存，关闭标准输入，输出，错误流。

## 2. 结构体内存对齐问题
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐(若有double成员，按8字节对齐)

**内存对齐：** 一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。

**内存对齐的原则：**

- 对于结构体的各个成员，<font color="#F100">除了第一个成员的偏移量为 0 外，其余成员的偏移量是 **其实际长度** 的整数倍，如果不是，则在前一个成员后面补充字节。</font>
- 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，<font color="#F100">**保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍**。</font>
- 如程序中有  `#pragma pack(n)` 预编译指令，则所有成员对齐以 n 字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。

[https://www.cnblogs.com/hyacinthLJP/p/16041690.html](https://www.cnblogs.com/hyacinthLJP/p/16041690.html)

- C++ `alignas` 用来**指定**对象的对齐字节数。效果和__attribute__((aligned(n)))一样，对齐值必须是 2 的幂，`alignas` 指定的对齐要求不能低于类型的自然对齐要求。；
- C++ `alignof` 用来**查看**对象的对齐字节数。用法类似于sizeof。

[http://t.csdnimg.cn/P5cZl](http://t.csdnimg.cn/P5cZl)

## 3. 指针和引用的区别
C++ 指针和引用的区别在于：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

- 指针是存储变量地址的变量；引用是变量的别名；
- 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错；
- 指针变量定义时可以初始化为 NULL；引用不能初始化为 NULL，不然报错；
- const 修饰指针变量，const 放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const 放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const 修饰引用，const 放在&之前，不能修改引用所表示的变量的值；const 放在 & 之后，const 的作用被忽略，可以修改引用所表示的变量的值。
- 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名。
- sizeof 运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 指针可以有多级，引用只有一级。
- 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。


> 指针的大小并不是固定的，它取决于运行程序的计算机架构。 在 32 位系统中，一个指针通常占用 4 个字节（32 bits / 8 bits per byte = 4 bytes）。 而在 64 位系统中，一个指针则占用 8 个字节（64 bits / 8 bits per byte = 8 bytes）。

## 4.在传递函数参数时，什么时候使用引用，什么时候使用指针，什么时候按值传递呢？
对于使用传递的值而不做修改的函数：

- 如果数据量很小，如内置数据类型或小型结构，则按值传递；
- 如果数据对象是数组，则使用指针，并将指针申明为指向 `const` 的指针(如`void fun(const int * arr, int length)`)；
- 如果数据对象是较大的结构，则使用 `const` 指针或 `const` 引用；
- 如果数据对象是类对象，则使用 `const` 引用。传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用引用，如`int* randomArr(int& length)`，别人看到这个声明就知道此函数内部会修改 `length` 的值；
- 如果数据对象是数组，则只能使用指针；
- 如果数据对象是结构体，则使用引用或指针；
- 如果数据对象是类对象，则使用引用；

总结：

- <font color="#A100">需要**返回函数内局部变量的内存的时候用指针**。使用指针传递参数需要先开辟内存，用完要释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
- 对栈空间大小比较敏感的场景（比如使用递归）要使用引用。**使用引用传递的时候不需要创建临时变量**，开销会更小。
- 类对象作为参数传递的时候使用引用，这是cpp类对象传递的标准方式。</font>


## 5. 堆和栈的区别
1. **申请方式不同**：
栈由系统自动分配；
堆是自己申请和释放的。
2. **申请大小限制不同**：
栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定（可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改）；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。【栈空间默认是4M，堆区一般是 1G - 4G】
3. **申请效率不同**：
栈由系统分配，速度快，不会有碎片；
堆由程序员分配，速度慢，且会有碎片。
4. **使用方法不同**：堆一般是底层用` malloc `通过` brk() `系统调用从堆分配内存；栈一般就是直接定义，就是分配，简单的 `esp, ebp` 指针的移动。
5. **存放内容不同**：堆一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排；栈在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的 C 编译器中，**参数是由右往左入栈（占位符确定参数个数）**，然后是函数中的局部变量。
【[http://t.csdnimg.cn/b0Tcu](http://t.csdnimg.cn/b0Tcu)】
6. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了**栈的效率比较高**。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
7. 堆地址向上生长（低到高），栈地址向下生长（高到低），因为计算机总是先从低地址开始读，所以，栈先进后出，堆先进先出。


[http://t.csdnimg.cn/sV3N5](http://t.csdnimg.cn/sV3N5)

## 6.区别指针类型
	int *p[10]
	int (*p)[10]
	int *p(int)
	int (*p)(int)

1. `int *p[10]`表示指针数组，强调数组概念，是一数组变量，数组大小为 10，数组内每个元素都是指向 `int` 类型的指针变量（一个有十个指针的数组）。
1. `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 `int` 类型的数组，这个数组大小是10（一个指向有十个整型数据数组的指针）。
1. `int *p(int)`是函数声明，函数名是 `p`，参数是 `int` 类型的，返回值是`int *`类型的。
1. `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有 `int` 类型参数，并且返回值是 `int` 类型的。

**指针函数与函数指针：**

- **指针函数**：本质是一个函数，不过它的返回值是一个指针。【`ret *func(args, ...);`--`func` 是一个函数，`args` 是形参列表，`ret *` 作为一个整体，是 `func` 函数的返回值，是一个指针的形式。】
- **函数指针**：本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。【`ret (*p)(args, ...);` —`ret` 为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args` 为形参列表。其中`p`被称为函数指针变量 】


[http://t.csdnimg.cn/ItQSC](http://t.csdnimg.cn/ItQSC)


## 7.new/delete 与 malloc/free 的异同
- 相同点：都可用于内存的动态申请和释放；
- 不同点：
	- 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数；
	- new 自动计算要分配的空间大小，malloc 需要手动计算；
	- new 是类型安全的，malloc不是。
	- new 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为`operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用；
	- 后者需要库文件支持，前者不用；
	- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象。
	- malloc 和 free 返回的是 void 类型指针(必须进行类型转换)，new 和 delete 返回的是具体类型指针。

**new 的实现过程**：首先调用名为 `operator new` 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。

**delete 的实现过程**：对指针指向的对象运行适当的析构函数，然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。

## 8.malloc/free和new/delete释放后的内存系统会马上回收吗？
用户 `free` 掉的内存并不是都会马上归还给系统，`ptmalloc` 会统一管理 `heap` 和 `mmap` 映射区域中的空闲的 `chunk`，当用户进行下一次分配请求时，`ptmalloc` 会首先试图在空闲的 `chunk` 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。

`ptmalloc` 将相似大小的 `chunk` 用双向链表链接起来，这样的一个链表被称为一个 bin。`ptmalloc` 一共维护了 128 个 bin，并使用一个数组来存储这些 bin。

内存管理一般会有一个`free block list`，`free` 掉的东西就放在这里来，这里会尝试合并这些散乱的 `block`，而 `malloc` 首先找的也是` free block list`，而非从OS申请新的内存。【碎片问题：页大小固定，避免小内存一直分配，占据不同的页】

[http://t.csdnimg.cn/tjySr](http://t.csdnimg.cn/tjySr)


## 9.宏定义和函数有何区别？
- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于**直接插入**了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；
- 宏定义属于在结构中插入代码，**没有返回值**；函数调用具有返回值；
- 宏定义**参数没有类型**，不进行类型检查；函数参数具有类型，需要检查类型；
- 宏定义不要在最后加分号。

## 10.宏定义 和 typedef 区别?
- 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名；
- 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分；
- 宏不检查类型；typedef会检查数据类型；
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束；

注意对指针的操作，`typedef char*p_char`和`#define p_char char *`区别巨大：

	typedef (int*)  pINT;
	#define pINT2 int*

效果相同？实则不同！实践中见差别：`pINT a,b;`的效果同`int *a; int *b;`表示定义了两个整型指针变量；而`pINT2 a,b;`的效果同`int *a, b;`表示定义了一个整型指针变量 a 和整型变量 b。


## 11.变量声明和定义区别?
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其**分配存储空间**。
- 相同变量可以在**多处声明**(外部变量 `extern`)，但只能在**一处定义**。


## 12.strlen 和 sizeof 区别?
- `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数；
- `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是`\0'`的字符串；
- 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。

## 13.常量指针和指针常量区别?
- **指针常量**：是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的`int const `和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`；【**不能够通过指针修改内存数据**。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象】
- **常量指针**：是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值(也就是存放在指针中的地址)就不能在改变了，即不能中途改变指向，如`int *const p`。【**指针所指向的位置不能改变**，即指针本身是一个常量，但是指针所指向的内容可以改变。】

<font color="#F100">【以*为中间划一条线，看const修饰谁就谁就是常量。】</font>

[http://t.csdnimg.cn/q3F0U](http://t.csdnimg.cn/q3F0U)


## 14.C 语言和 C++ 的区别

1. **过程**：*C 编程语言不支持面向对象编程。因此，它不允许多态性、继承等。作为一种面向对象的语言，C++ 支持多态性和继承。*
2. **安全性**：*由于 C 语言不允许封装，数据变得可访问，其他实体可以破坏它。然而，C++ 支持封装，可以保护数据结构并根据需要使用它。*
3. **方法**：*C 编程语言鼓励自顶向下的方法，首先定义一个通用问题，然后将其分解为较小的任务。另一方面，C++ 鼓励自底向上的方法。这涉及首先识别和定义类，然后使用它们执行最初的任务。*
4. **输入/输出函数**：在 C 中，I/O 操作主要通过 C 标准库的标准 I/O 函数进行处理，如 printf() 和 scanf()。这些函数提供基本的格式化和读取功能，但缺少 C++ 中的一些高级功能；另一方面，C++ 通过使用 iostream 库中的对象扩展了 I/O 功能，这些对象称为**标准 I/O 流**。cout 流允许进行简单而灵活的输出操作，而 cin 流提供了增强的输入功能。C++ 流支持运算符重载，可方便地输出复杂数据类型并启用自定义格式选项。
5. **重载和覆盖**：方法覆盖允许子类重新定义从其祖先继承的函数。重载允许同一个函数有多个版本，每个版本具有唯一的参数。C 不支持这两者，但 C++ 支持。
6. **内存分配**：*C 编程依赖于两个关键函数——`calloc()`和`malloc()`——用于内存分配。相应的 free() 函数用于内存释放。C++使用new运算符进行动态内存分配，使用delete运算符进行释放。*
7. **编译**：C 和 C++ 的软件开发始于编写源代码。C文件的源代码具有`.c`扩展名，而 C++ 使用扩展名如`.cpp`或`.cxx`。这些源代码文件包含程序的指令和逻辑。


8. **变量**：通常，C编程语言使用两种类型的值：字面值和变量。C使用四种基本的变量类型：int、float、char和double。C++的主要变量类型包括bool、void和wchar_t。

9. **特点**：C编程语言是一种过程式、快速和高效的语言，具有模块化和丰富的内置运算符。与C不同，C++是一种过程式语言，具有OOP。此外，它是机器无关的、简单的和区分大小写的。
10. 在C++中，除了值和指针之外，**新增了引用**。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。

11. C++中的`try/catch/throw`异常处理机制取代了标准C中的`setjmp()`和`longjmp()`函数。

C编程语言是一种中级语言，而C++是一种高级语言。



[http://t.csdnimg.cn/X7tM2](http://t.csdnimg.cn/X7tM2)


## 15.C++中 struct 和 class 的区别？
相同点：

1. 两者都拥有成员函数、公有和私有部分；
1. 任何可以使用class完成的工作，同样可以使用struct完成。

不同点：

1. 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的；
2. class默认是private继承，而struct默认是public继承；
3. class 可以使用模板，而 struct 不能；


**引申：C++和C的struct区别**

- C 语言中：struct 是用户自定义数据类型(UDT)；C++中 struct 是抽象数据类型(ADT)，支持成员函数的定义，(**C++中的 struct 能继承，能实现多态**)
- C 中 struct 是没有权限的设置的，且 struct 中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且**成员不可以是函数**；C++中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public(为了与C兼容)；
- struct 作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中**必须在结构标记前加上struct**，才能做结构类型名(除:typedef struct class0;)；C++中结构体标记(结构体名)可以**直接作为结构体类型名使用**，此外结构体 struct 在C++ 中被当作类的一种特例；


[https://www.cnblogs.com/banluxinshou/p/11823158.html](https://www.cnblogs.com/banluxinshou/p/11823158.html)


## 16.define宏定义和const的区别？
角度1： 就定义常量说的话， const 定义的常数是**变量 也带类型**， #define 定义的只是个**常数 不带类型**。

角度2： 就起作用的阶段而言，#define 是在编译的**预处理阶段**起作用，而 const 是在 **编译、运行**的时候起作用。

角度3： 就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：

	#define N 2+3     // 我们预想的 N 值是 5，我们这样使用 
	Ndouble a = N/2;  // 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5
角度4： 就空间占用而言， 例如：

	#define PI 3.14     //预处理后 占用代码段空间
	const float PI=3.14;    // 本质上还是一个 float，占用数据段空间

角度5： 从代码**调试**的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了

角度6： 从是否可以再定义的角度而言，const 不足的地方，是与生俱来的，**const 不能重定义**，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义；【[const定义的对象属性可以改变](https://blog.csdn.net/Ain_z/article/details/109634087)】

[https://www.runoob.com/note/12963](https://www.runoob.com/note/12963)


## 17.C++ 中 const 和 static 的作用？
static

不考虑类的情况：

- 隐藏。所有不加 static 的全局变量和函数具有全局可见性，可以在其他文件中使用，**加了之后只能在该文件所在的编译模块中使用**；
- 默认**初始化为0**，包括未初始化的全局静态变量与局部静态变量，都存在**全局未初始化区**；
- 静态变量在函数内定义，**始终存在，且只进行一次初始化**，具有记忆性，其作用范围0与局部变量相同，函数退出后仍然存在，但不能使用

考虑类的情况：

- static 成员变量：**只与类关联**，不与类的对象关联。**定义时要分配空间，不能在类声明中初始化**，必须在类定义体外部初始化，**初始化时不需要标示为static**；可以被非static成员函数任意访问。
- static 成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问；


const

不考虑类的情况：

- const 常量在定义时必须初始化，之后无法更改；
- const 形参可以接收 const 和非 const 类型的实参，例如//i可以是int 型或者 const int型void fun(const int& i){ //...}

考虑类的情况：

- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化；
- const成员函数：const 对象不可以调用非 const 成员函数；非const对象都可以调用；不可以改变非 `mutable`(用该关键字声明的变量**可以在const成员函数中被修改)数据的值**）。


<font color="#A100">

const 定义的常量在超出其作用域之后其空间会被释放，而static 定义的静态常量在函数执行后不会释放其存储空间。</font>


类里的static cosnt 和 const static成员初始化：它们的初始化没有区别，虽然一个是静态常量一个是常量静态。静态都将存储在全局变量区域，其实最后结果都一样。可能在不同编译器内，不同处理，但最后结果都一样。  

[https://www.cnblogs.com/phpzhou/p/6390869.html](https://www.cnblogs.com/phpzhou/p/6390869.html)


## 18.C++的顶层 const 和底层 const?
**顶层const**：指的是 `const` 修饰的变量本身是一个常量，无法修改，指的是指针，就是`*`号的右边；

**底层const**：指的是 `const` 修饰的变量所指向的对象是一个常量，指的是所指变量，就是号的左边；

	int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
	const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
	const int b3 = 20; 		   //顶层const，b3是常量不可变
	const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
	const int& b5 = a;		   //用于声明引用变量，都是底层const

- 如果 const 右结合修饰的为 `类型` 或者 `*`，那这个 const 就是一个底层 const；
- 如果 const 右结合修饰的为 `标识符`，那这个 const 就是一个顶层 const。

主要区别：

- 被修饰的变量本身无法改变的 const 是顶层 const；
- 通过指针或引用等间接途径来限制目标内容不可变的 const 是底层 const。

顶层 const 表示指针本身（对象值）是个常量；
底层 const 表示指针所指的对象（地址）是一个常量。

## 19.数组名和指针(这里为指向数组首元素的指针)区别?
- 二者均可通过**增减偏移量来访问**数组中的元素；
- 数组名不是真正意义上的指针，可以理解为常量指针，所以数组名没有自增、自减等操作；指针是变量指针；
- **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但 sizeof 运算符不能再得到原数组的大小了**。

## 20.final 和 override 关键字
`final` 和 `override` 是C++11标准引入的两个关键字，它们为类的继承和多态机制提供了更多的控制权和明确性。

- `final` 关键字用于指示一个类或成员函数是最终的，**不能被继承或覆盖**，可以保护基类不被修改，防止滥用继承；
- `override` 关键字用于**明确指出**派生类中的成员函数旨在覆盖基类中的同名虚拟函数，并进行编译时类型检查。


## 21.拷贝初始化和直接初始化
- 如果**使用等号（=）**初始化一个变量，实际上执行的是“**拷贝初始化**”，编译器把等号右侧的初始值拷贝到新创建的对象中去。
- 与之相反，如果**不使用等号**，则执行的是“**直接初始化**”；

直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；

拷贝初始化实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中，通常用拷贝构造函数来完成；

**拷贝构造函数的形参必须是引用类型**的原因：如果不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环，造成错误。

使用 `explicit` 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

[https://blog.csdn.net/capecape/article/details/78276677](https://blog.csdn.net/capecape/article/details/78276677)


## 22.C++初始化与赋值的区别
初始化不是赋值，初始化的含义是在创建对象时赋予一个初值，而赋值是将对象的当前值擦除掉，以一个新值代替。

[http://t.csdnimg.cn/sBvrQ](http://t.csdnimg.cn/sBvrQ)

## 23.extern"C" 的用法
`extern "c" ` 的主要作用就是为了**能够正确实现 C++ 代码调用其他 C 语言代码**。加上 `extern “c”` 后，会指示**编译器这部分的代码按C语言，而不是C++的方式进行编译**。


由于C++支持函数重载，因**此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。


**extern "C"使用要点**：

- 可以是单一语句：`extern “C” double sqrt(double);`
- 可以是复合语句，相当于复合语句中的声明都加了 `extern “C”`：`extern “C”{ double sqrt(double); int min(int, int);}`
- 可以包含头文件，相当于头文件中的声明都加了extern “C” ：`extern “C”{＃include <cmath> }`
- 不可以将 extern “C” 添加在函数内部;
- 如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。


## 24.野指针和悬空指针
- **野指针**：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空；
- **悬空指针**：指针 free 或 delete 之后没有及时置空  => 释放操作后立即置空；

C++智能指针的本质就是避免悬空指针的产生。

## 25.C 和 C++ 的类型安全？
类型安全很大程度上可以等价于内存安全，**类型安全的代码不会试图访问自己没被授权的内存区域**。

<font color="#F100">**类型安全**是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据是用类型来解释的)。</font>

C 只在局部上下文中表现出类型安全；因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1，用boolean来解释就是true。

如果C++使用得当，它将远比C更有类型安全性。相比于C，C++提供了一些新的机制保障类型安全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*；
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
- C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。


Java语言是类型安全的，除非强制类型转换。

[http://t.csdnimg.cn/AlWSs](http://t.csdnimg.cn/AlWSs)


## 26.C++中的重载、重写(覆盖)和隐藏的区别？
**重载**：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，**重载不关心函数返回类型**。

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，注意**只要同名函数，不管参数列表是否相同，基类函数都会被隐藏**。

**重写(覆盖)**：是指派生类中存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。**只有函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 `virtual` 修饰，派生类可以没有。


## 27.C++有哪几种的构造函数
通常 C++中的构造函数可以分为5类：默认构造函数、普通构造函数、拷贝构造函数、转换构造函数、移动构造函数。

- **默认构造函数**：未提供显式初始值时，用来创建对象的构造函数`Student();//没有参数`；
- **普通构造函数**：C++用于构建类的新对象时需要调用的函数`Student(int num，int age）;//有参数`；
- **拷贝构造函数**：何时生成默认的拷贝构造函数；
- **转换构造函数**：一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象【string 类中可以找到使用转换构造函数的实用示例】；
- **移动构造函数**：以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。


委托构造函数是C++11引入的一个特性，它**允许一个构造函数调用同一类的另一个构造函数**，从而避免在类内部出现相似的初始化代码，提高代码的可维护性。在构造函数的初始化列表中使用` : `符号，可以调用同一类中的其他构造函数。

委托构造函数的调用必须出现在构造函数的初始化列表中。在构造函数主体中调用其他构造函数是不允许的。

## 28.浅拷贝和深拷贝的区别
**浅拷贝**：浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，**如果原来的指针所指向的资源释放了，我那么再释放浅拷贝的指针的资源就会出现错误**。

**深拷贝**：**深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值**，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

深拷贝和浅拷贝是指在赋值一个对象时，拷贝的深度不同。 在进行深拷贝时，会拷贝所有的属性，并且如果这些属性是对象，也会对这些对象进行深拷贝，直到最底层的基本数据类型为止。

## 29.内联函数和宏定义的区别
**宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的**。

而且**内联函数是真正的函数**，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

**内联函数有类型检测、语法判断等功能，而宏没有。**


## 30.public, protected 和 private 访问和继承权限 /public/protected/private 的区别?
**访问权限：**

- public:可以被任意实体访问；
- protected:只允许子类及本类的成员函数访问；
- private:只允许本类的成员函数访问；

**继承：**

1. public 继承不改变基类成员的访问权限；
2. private 继承使得基类所有成员在子类中的访问权限变为 private；
3. protected 继承将基类中public成员变为子类的protected成员，其它成员的访问 权限不变；
4. 基类中的 private 成员不受继承方式的影响，子类永远无权访问。


友元是一种**定义在类外部的普通函数，但它需要在类体内进行声明**，为了与该类的成员函数加以区别，在声明时前面加以关键字 `friend`。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

[【C++】友元函数和友元类（作用及优缺点）](http://t.csdnimg.cn/ThyG8)

## 31.如何用代码判断大小端存储？
- **大端存储**：是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中；
- **小端存储**：是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

<font color="#F100">想办法取出一个字节的内容，就可以知道是哪种存储方式。</font>

初始化一个 `16 进制` 的int型的数据，然后把它放在一个 `char` 类型的数组中，由于**十六进制的数据一位代表四个bit位**；`char` 型是8个bit位，那么十六进制的两位占一个 `char` 位，那么就可以把数据位分离。

**方法一：直接法**

	int main()
	{
		int a = 0x12345678;
		char i = a;
		printf("%x", i);
	}
定义一个十六进制的数据，数据类型为int型，之后定义一个char类型的数据，**int数据类型的大小为四个字节，而char类型的数据为一个字节，所以将int类型的数据赋值给char时会丢失三个字节的数据，char类型中存储的是int类型中低地址的数据**，这时候char类型获取的数据输出之后，如果输出的是12那就说明你低地址位置的数据是12，那就说明你的数据是大端存储，如果输出的结果是78那当前条件下就是小端存储。

**方法二：指针法**

	int main()
	{
	    int i = 0x1122;
		char* p = (char*)& i;
		if (p[0] == 0x22 && p[1] == 0x11) {
			cout << "little endian" << endl;
		}
		else if (p[0] == 0x11 && p[1] == 0x22) {
			cout << "big endian" << endl;
		}
	}

`*p`就是`p[0]`，把变量的地址强制类型转换为`char*`，这样就可以每次取出一个字节的内容，因为 `char` 的大小就是1个字节，`p[0]`和`p[1]`都表示一个 `char` 类型。

将`int*`类型的` &i`强制转换为了`char*`类型，但值没有改变（地址）；地址存储的值也未改变，`p` 就是表示的这个地址，但 `p` 是 `char*` 类型的变量，因此可以用`p[0]p[1]`去取，每一个`p[]`就是两个十六进制的数（也就是一个字节）。`p[0]`就是`0x22`, `p[1]`就是`0x11`。

**方法三：联合体法**

	int main(){
		union
		{
			int value;
			char union_bytes[ sizeof(int) ];
		} test;
		test.value = 0x0102;
		if (  ( test.union_bytes[ 0 ] == 1 ) && ( test.union_bytes[ 1 ] == 2 ) )
		{
			printf( "big endian\n" );
		}
		else if ( ( test.union_bytes[ 0 ] == 2 ) && ( test.union_bytes[ 1 ] == 1 ) )
		{
			printf( "little endian\n" );
		}
		else
		{
			printf( "unknown...\n" );
		}
	}
在联合体中定义一个 char 类型的变量和 int 类型的变量，利用二者所占同一段存储空间，可以通过引用联合体变量中的成员访问 `char`  类型的数据，取出一个字节的内容。

**在 `union` 中所有的数据成员共用一个空间**，而且是**从低位开始占用**，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，**共用体变量的内存空间大小是该变量中某个占用空间最大的那个成员所占的空间**。。

即上述的union虽然定义了两个成员，但其实这个union只占用了4个字节(32位机器中 int 所占的空间大小)，往 value 成员赋值（value完整是0x00000102），然后读取 union_bytes ，union_bytes[0]就是value的第一个字节，union_bytes[1]就是value的第二个字节。

[http://t.csdnimg.cn/lm2iI](http://t.csdnimg.cn/lm2iI)


## 32.volatile、mutable 和 explicit 关键字的用法？
volatile 关键字是一种类型修饰符，用它声明的类型变量**表示可以被某些编译器未知的因素更改**。

<font color="#F100">当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</font>


volatile 定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

多线程中被几个任务共享的变量需要定义为 volatile 类型。


volatile 限定符的用法和 const 很相似，它起到对类型额外修饰的作用；const 和volatile 限定符互相没什么影响，**某种类型可能既是 const 的也是 volatile 的**，此时它同时具有二者的属性。

只有 `volatile` 的成员函数才能被 `volatile` 的对象调用。

可以把一个非 volatile in t赋给 volatile int，但是不能把非 volatile 对象赋给一个volatile对象。

**mutable**

- 用 const 修饰的成员函数时，**const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量**，当成员变量类型符前用 `mutable` 修饰时例外。

-  常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰；


> 常函数不能对普通成员变量（除mutable修饰外）进行写操作 ；
> 常函数可以被普通对象或者常对象调用；
> 
> 常对象不能调用所有普通函数，只能调用常函数；
> 常对象可以读成员变量；
> 
> [http://t.csdnimg.cn/pOfDm](http://t.csdnimg.cn/pOfDm)


**explicit**

c++ 提供了关键字 `explicit`，禁止通过构造函数进行的隐式转换。声明为 `explicit` 的构造函数不能在隐式转换中使用。

- 是针对**单参数**的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。
-  explicit用于修饰构造函数，防止隐式转化。




[https://www.cnblogs.com/codemagiciant/p/17524184.html](https://www.cnblogs.com/codemagiciant/p/17524184.html)


## 33.什么情况下会调用拷贝构造函数？
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是**使用同一类中之前创建的对象来初始化新创建的对象**。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象；
- 复制对象把它作为参数传递给函数；
- 复制对象，并从函数返回这个对象；

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

## 34.C++中有几种类型的new（plain new\nothrow new\placement new)

**1. plain new**

言下之意就是普通的 `new`，就是我们常用的 `new`；

在C++中定义如下：

	void* operator new(std::size_t) throw(std::bad_alloc);
	void operator delete(void *) throw();
	Copy to clipboardErrorCopied
因此 plain new 在空间分配失败的情况下，抛出异常`std::bad_alloc`而不是返回 `NULL`，因此通过判断返回值是否为 `NULL` 是徒劳的。

**2.nothrow new**

	char *p = new(nothrow) char[10e11];
`nothrow new `在空间分配失败的情况下是不抛出异常，而是返回 `NULL`；


**3.placement new**

    ADT *q = new(p) ADT;
这种 new **允许在一块已经分配成功的内存上重新构造对象或对象数组。** `placement new`不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。

	void* operator new(size_t,void*);
	void operator delete(void*,void*);
	Copy to clipboardErrorCopied

`palcement new` 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组；

`placement new`构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为`placement new`构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。


## 35.C++的异常处理的方法