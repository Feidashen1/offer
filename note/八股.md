# C++

----------

## 1.C++ 在 main() 函数执行前，后执行了哪些操作?
main 函数执行之前，主要就是初始化系统相关资源：

1. 设置栈指针：栈分配相关的位置，用来放一些局部变量和其他数据；
2. 
3. 
4. 
5.  static 静态和 global 全局变量，即 data 段的内容：**把全局和静态变量初始化**；
3. 将未初始化部分的全局变量赋初值：数值型 short，int，long 等为0，bool 为FALSE，指针为NULL，等等，即 .bss 段的内容：**将未设置初值的全局变量赋初值**；
4. 全局对象初始化，在main之前调用构造函数；
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。

在执行完 main 函数后：执行全局的析构函数，要销毁堆内存，关闭标准输入，输出，错误流。

## 2. 结构体内存对齐问题
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐(若有double成员，按8字节对齐)

**内存对齐：** 一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。

**内存对齐的原则：**

- 对于结构体的各个成员，<font color="#F100">除了第一个成员的偏移量为 0 外，其余成员的偏移量是 **其实际长度** 的整数倍，如果不是，则在前一个成员后面补充字节。</font>
- 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，<font color="#F100">**保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍**。</font>
- 如程序中有  `#pragma pack(n)` 预编译指令，则所有成员对齐以 n 字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。

[https://www.cnblogs.com/hyacinthLJP/p/16041690.html](https://www.cnblogs.com/hyacinthLJP/p/16041690.html)

- C++ `alignas` 用来**指定**对象的对齐字节数。效果和__attribute__((aligned(n)))一样，对齐值必须是 2 的幂，`alignas` 指定的对齐要求不能低于类型的自然对齐要求。；
- C++ `alignof` 用来**查看**对象的对齐字节数。用法类似于sizeof。

使用<stddef.h>头文件中的，**offsetof 宏**，可以获得结构成员相对于结构开头的字节偏移量 `offserof(S,t)`，其中 `S` 是结构体，`t` 是结构体变量。

[http://t.csdnimg.cn/P5cZl](http://t.csdnimg.cn/P5cZl)

## 3. 指针和引用的区别
C++ 指针和引用的区别在于：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

- 指针是存储变量地址的变量；引用是变量的别名；
- 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错；
- 指针变量定义时可以初始化为 NULL；引用不能初始化为 NULL，不然报错；
- const 修饰指针变量，const 放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const 放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const 修饰引用，const 放在&之前，不能修改引用所表示的变量的值；const 放在 & 之后，const 的作用被忽略，可以修改引用所表示的变量的值。
- 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名。
- sizeof 运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 指针可以有多级，引用只有一级。
- 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。


> 指针的大小并不是固定的，它取决于运行程序的计算机架构。 在 32 位系统中，一个指针通常占用 4 个字节（32 bits / 8 bits per byte = 4 bytes）。 而在 64 位系统中，一个指针则占用 8 个字节（64 bits / 8 bits per byte = 8 bytes）。

## 4.在传递函数参数时，什么时候使用引用，什么时候使用指针，什么时候按值传递呢？
对于使用传递的值而不做修改的函数：

- 如果数据量很小，如内置数据类型或小型结构，则按值传递；
- 如果数据对象是数组，则使用指针，并将指针申明为指向 `const` 的指针(如`void fun(const int * arr, int length)`)；
- 如果数据对象是较大的结构，则使用 `const` 指针或 `const` 引用；
- 如果数据对象是类对象，则使用 `const` 引用。传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用引用，如`int* randomArr(int& length)`，别人看到这个声明就知道此函数内部会修改 `length` 的值；
- 如果数据对象是数组，则只能使用指针；
- 如果数据对象是结构体，则使用引用或指针；
- 如果数据对象是类对象，则使用引用；

总结：

- <font color="#A100">需要**返回函数内局部变量的内存的时候用指针**。使用指针传递参数需要先开辟内存，用完要释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
- 对栈空间大小比较敏感的场景（比如使用递归）要使用引用。**使用引用传递的时候不需要创建临时变量**，开销会更小。
- 类对象作为参数传递的时候使用引用，这是cpp类对象传递的标准方式。</font>


## 5. 堆和栈的区别
1. **申请方式不同**：
栈由系统自动分配；
堆是自己申请和释放的。
2. **申请大小限制不同**：
栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定（可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改）；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。【栈空间默认是4M，堆区一般是 1G - 4G】
3. **申请效率不同**：
栈由系统分配，速度快，不会有碎片；
堆由程序员分配，速度慢，且会有碎片。
4. **使用方法不同**：堆一般是底层用` malloc `通过` brk() `系统调用从堆分配内存；栈一般就是直接定义，就是分配，简单的 `esp, ebp` 指针的移动。
5. **存放内容不同**：堆一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排；栈在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的 C 编译器中，**参数是由右往左入栈（占位符确定参数个数）**，然后是函数中的局部变量。
【[http://t.csdnimg.cn/b0Tcu](http://t.csdnimg.cn/b0Tcu)】
6. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了**栈的效率比较高**。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
7. 堆地址向上生长（低到高），栈地址向下生长（高到低），因为计算机总是先从低地址开始读，所以，栈先进后出，堆先进先出。


[http://t.csdnimg.cn/sV3N5](http://t.csdnimg.cn/sV3N5)

## 6.区别指针类型
	int *p[10]
	int (*p)[10]
	int *p(int)
	int (*p)(int)

1. `int *p[10]`表示指针数组，强调数组概念，是一数组变量，数组大小为 10，数组内每个元素都是指向 `int` 类型的指针变量（一个有十个指针的数组）。
1. `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 `int` 类型的数组，这个数组大小是10（一个指向有十个整型数据数组的指针）。
1. `int *p(int)`是函数声明，函数名是 `p`，参数是 `int` 类型的，返回值是`int *`类型的。
1. `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有 `int` 类型参数，并且返回值是 `int` 类型的。

**指针函数与函数指针：**

- **指针函数**：本质是一个函数，不过它的返回值是一个指针。【`ret *func(args, ...);`--`func` 是一个函数，`args` 是形参列表，`ret *` 作为一个整体，是 `func` 函数的返回值，是一个指针的形式。】
- **函数指针**：本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。【`ret (*p)(args, ...);` —`ret` 为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args` 为形参列表。其中`p`被称为函数指针变量 】


[http://t.csdnimg.cn/ItQSC](http://t.csdnimg.cn/ItQSC)


## 7.new/delete 与 malloc/free 的异同
- 相同点：都可用于内存的动态申请和释放；
- 不同点：
	- 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数；
	- new 自动计算要分配的空间大小，malloc 需要手动计算；
	- new 是类型安全的，malloc不是。
	- new 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为`operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用；
	- 后者需要库文件支持，前者不用；
	- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象。
	- malloc 和 free 返回的是 void 类型指针(必须进行类型转换)，new 和 delete 返回的是具体类型指针。

**new 的实现过程**：首先调用名为 `operator new` 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。

**delete 的实现过程**：对指针指向的对象运行适当的析构函数，然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。

## 8.malloc/free和new/delete释放后的内存系统会马上回收吗？
用户 `free` 掉的内存并不是都会马上归还给系统，`ptmalloc` 会统一管理 `heap` 和 `mmap` 映射区域中的空闲的 `chunk`，当用户进行下一次分配请求时，`ptmalloc` 会首先试图在空闲的 `chunk` 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。

`ptmalloc` 将相似大小的 `chunk` 用双向链表链接起来，这样的一个链表被称为一个 bin。`ptmalloc` 一共维护了 128 个 bin，并使用一个数组来存储这些 bin。

内存管理一般会有一个`free block list`，`free` 掉的东西就放在这里来，这里会尝试合并这些散乱的 `block`，而 `malloc` 首先找的也是` free block list`，而非从OS申请新的内存。【碎片问题：页大小固定，避免小内存一直分配，占据不同的页】

[http://t.csdnimg.cn/tjySr](http://t.csdnimg.cn/tjySr)


## 9.宏定义和函数有何区别？
- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于**直接插入**了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；
- 宏定义属于在结构中插入代码，**没有返回值**；函数调用具有返回值；
- 宏定义**参数没有类型**，不进行类型检查；函数参数具有类型，需要检查类型；
- 宏定义不要在最后加分号。

## 10.宏定义 和 typedef 区别?
- 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名；
- 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分；
- 宏不检查类型；typedef会检查数据类型；
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束；

注意对指针的操作，`typedef char*p_char`和`#define p_char char *`区别巨大：

	typedef (int*)  pINT;
	#define pINT2 int*

效果相同？实则不同！实践中见差别：`pINT a,b;`的效果同`int *a; int *b;`表示定义了两个整型指针变量；而`pINT2 a,b;`的效果同`int *a, b;`表示定义了一个整型指针变量 a 和整型变量 b。


## 11.变量声明和定义区别?
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其**分配存储空间**。
- 相同变量可以在**多处声明**(外部变量 `extern`)，但只能在**一处定义**。


## 12.strlen 和 sizeof 区别?
- `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数；
- `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是`\0'`的字符串；
- 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。

## 13.常量指针和指针常量区别?
- **指针常量**：是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的`int const `和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`；【**不能够通过指针修改内存数据**。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象】
- **常量指针**：是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值(也就是存放在指针中的地址)就不能在改变了，即不能中途改变指向，如`int *const p`。【**指针所指向的位置不能改变**，即指针本身是一个常量，但是指针所指向的内容可以改变。】

<font color="#F100">【以*为中间划一条线，看const修饰谁就谁就是常量。】</font>

[http://t.csdnimg.cn/q3F0U](http://t.csdnimg.cn/q3F0U)


## 14.C 语言和 C++ 的区别

1. **过程**：*C 编程语言不支持面向对象编程。因此，它不允许多态性、继承等。作为一种面向对象的语言，C++ 支持多态性和继承。*
2. **安全性**：*由于 C 语言不允许封装，数据变得可访问，其他实体可以破坏它。然而，C++ 支持封装，可以保护数据结构并根据需要使用它。*
3. **方法**：*C 编程语言鼓励自顶向下的方法，首先定义一个通用问题，然后将其分解为较小的任务。另一方面，C++ 鼓励自底向上的方法。这涉及首先识别和定义类，然后使用它们执行最初的任务。*
4. **输入/输出函数**：在 C 中，I/O 操作主要通过 C 标准库的标准 I/O 函数进行处理，如 printf() 和 scanf()。这些函数提供基本的格式化和读取功能，但缺少 C++ 中的一些高级功能；另一方面，C++ 通过使用 iostream 库中的对象扩展了 I/O 功能，这些对象称为**标准 I/O 流**。cout 流允许进行简单而灵活的输出操作，而 cin 流提供了增强的输入功能。C++ 流支持运算符重载，可方便地输出复杂数据类型并启用自定义格式选项。
5. **重载和覆盖**：方法覆盖允许子类重新定义从其祖先继承的函数。重载允许同一个函数有多个版本，每个版本具有唯一的参数。C 不支持这两者，但 C++ 支持。
6. **内存分配**：*C 编程依赖于两个关键函数——`calloc()`和`malloc()`——用于内存分配。相应的 free() 函数用于内存释放。C++使用new运算符进行动态内存分配，使用delete运算符进行释放。*
7. **编译**：C 和 C++ 的软件开发始于编写源代码。C文件的源代码具有`.c`扩展名，而 C++ 使用扩展名如`.cpp`或`.cxx`。这些源代码文件包含程序的指令和逻辑。


8. **变量**：通常，C编程语言使用两种类型的值：字面值和变量。C使用四种基本的变量类型：int、float、char和double。C++的主要变量类型包括bool、void和wchar_t。

9. **特点**：C编程语言是一种过程式、快速和高效的语言，具有模块化和丰富的内置运算符。与C不同，C++是一种过程式语言，具有OOP。此外，它是机器无关的、简单的和区分大小写的。
10. 在C++中，除了值和指针之外，**新增了引用**。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。

11. C++中的`try/catch/throw`异常处理机制取代了标准C中的`setjmp()`和`longjmp()`函数。

C编程语言是一种中级语言，而C++是一种高级语言。



[http://t.csdnimg.cn/X7tM2](http://t.csdnimg.cn/X7tM2)


## 15.C++中 struct 和 class 的区别？
相同点：

1. 两者都拥有成员函数、公有和私有部分；
1. 任何可以使用class完成的工作，同样可以使用struct完成。

不同点：

1. 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的；
2. class默认是private继承，而struct默认是public继承；
3. class 可以使用模板，而 struct 不能；


**引申：C++和C的struct区别**

- C 语言中：struct 是用户自定义数据类型(UDT)；C++中 struct 是抽象数据类型(ADT)，支持成员函数的定义，(**C++中的 struct 能继承，能实现多态**)
- C 中 struct 是没有权限的设置的，且 struct 中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且**成员不可以是函数**；C++中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public(为了与C兼容)；
- struct 作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中**必须在结构标记前加上struct**，才能做结构类型名(除:typedef struct class0;)；C++中结构体标记(结构体名)可以**直接作为结构体类型名使用**，此外结构体 struct 在C++ 中被当作类的一种特例；


[https://www.cnblogs.com/banluxinshou/p/11823158.html](https://www.cnblogs.com/banluxinshou/p/11823158.html)


## 16.define宏定义和const的区别？
角度1： 就定义常量说的话， const 定义的常数是**变量 也带类型**， #define 定义的只是个**常数 不带类型**。

角度2： 就起作用的阶段而言，#define 是在编译的**预处理阶段**起作用，而 const 是在 **编译、运行**的时候起作用。

角度3： 就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：

	#define N 2+3     // 我们预想的 N 值是 5，我们这样使用 
	Ndouble a = N/2;  // 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5
角度4： 就空间占用而言， 例如：

	#define PI 3.14     //预处理后 占用代码段空间
	const float PI=3.14;    // 本质上还是一个 float，占用数据段空间

角度5： 从代码**调试**的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了

角度6： 从是否可以再定义的角度而言，const 不足的地方，是与生俱来的，**const 不能重定义**，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义；【[const定义的对象属性可以改变](https://blog.csdn.net/Ain_z/article/details/109634087)】

[https://www.runoob.com/note/12963](https://www.runoob.com/note/12963)


## 17.C++ 中 const 和 static 的作用？
static

不考虑类的情况：

- 隐藏。所有不加 static 的全局变量和函数具有全局可见性，可以在其他文件中使用，**加了之后只能在该文件所在的编译模块中使用**；
- 默认**初始化为0**，包括未初始化的全局静态变量与局部静态变量，都存在**全局未初始化区**；
- 静态变量在函数内定义，**始终存在，且只进行一次初始化**，具有记忆性，其作用范围0与局部变量相同，函数退出后仍然存在，但不能使用

考虑类的情况：

- static 成员变量：**只与类关联**，不与类的对象关联。**定义时要分配空间，不能在类声明中初始化**，必须在类定义体外部初始化，**初始化时不需要标示为static**；可以被非static成员函数任意访问。
- static 成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问；


const

不考虑类的情况：

- const 常量在定义时必须初始化，之后无法更改；
- const 形参可以接收 const 和非 const 类型的实参，例如//i可以是int 型或者 const int型void fun(const int& i){ //...}

考虑类的情况：

- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化；
- const成员函数：const 对象不可以调用非 const 成员函数；非const对象都可以调用；不可以改变非 `mutable`(用该关键字声明的变量**可以在const成员函数中被修改)数据的值**）。


<font color="#A100">

const 定义的常量在超出其作用域之后其空间会被释放，而static 定义的静态常量在函数执行后不会释放其存储空间。</font>


类里的static cosnt 和 const static成员初始化：它们的初始化没有区别，虽然一个是静态常量一个是常量静态。静态都将存储在全局变量区域，其实最后结果都一样。可能在不同编译器内，不同处理，但最后结果都一样。  

[https://www.cnblogs.com/phpzhou/p/6390869.html](https://www.cnblogs.com/phpzhou/p/6390869.html)


## 18.C++的顶层 const 和底层 const?
**顶层const**：指的是 `const` 修饰的变量本身是一个常量，无法修改，指的是指针，就是`*`号的右边；

**底层const**：指的是 `const` 修饰的变量所指向的对象是一个常量，指的是所指变量，就是号的左边；

	int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
	const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
	const int b3 = 20; 		   //顶层const，b3是常量不可变
	const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
	const int& b5 = a;		   //用于声明引用变量，都是底层const

- 如果 const 右结合修饰的为 `类型` 或者 `*`，那这个 const 就是一个底层 const；
- 如果 const 右结合修饰的为 `标识符`，那这个 const 就是一个顶层 const。

主要区别：

- 被修饰的变量本身无法改变的 const 是顶层 const；
- 通过指针或引用等间接途径来限制目标内容不可变的 const 是底层 const。

顶层 const 表示指针本身（对象值）是个常量；
底层 const 表示指针所指的对象（地址）是一个常量。

## 19.数组名和指针(这里为指向数组首元素的指针)区别?
- 二者均可通过**增减偏移量来访问**数组中的元素；
- 数组名不是真正意义上的指针，可以理解为常量指针，所以数组名没有自增、自减等操作；指针是变量指针；
- **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但 sizeof 运算符不能再得到原数组的大小了**。

## 20.final 和 override 关键字
`final` 和 `override` 是C++11标准引入的两个关键字，它们为类的继承和多态机制提供了更多的控制权和明确性。

- `final` 关键字用于指示一个类或成员函数是最终的，**不能被继承或覆盖**，可以保护基类不被修改，防止滥用继承；
- `override` 关键字用于**明确指出**派生类中的成员函数旨在覆盖基类中的同名虚拟函数，并进行编译时类型检查。


## 21.拷贝初始化和直接初始化
- 如果**使用等号（=）**初始化一个变量，实际上执行的是“**拷贝初始化**”，编译器把等号右侧的初始值拷贝到新创建的对象中去。
- 与之相反，如果**不使用等号**，则执行的是“**直接初始化**”；

直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；

拷贝初始化实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中，通常用拷贝构造函数来完成；

**拷贝构造函数的形参必须是引用类型**的原因：如果不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环，造成错误。

使用 `explicit` 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

[https://blog.csdn.net/capecape/article/details/78276677](https://blog.csdn.net/capecape/article/details/78276677)


## 22.C++初始化与赋值的区别
初始化不是赋值，初始化的含义是在创建对象时赋予一个初值，而赋值是将对象的当前值擦除掉，以一个新值代替。

[http://t.csdnimg.cn/sBvrQ](http://t.csdnimg.cn/sBvrQ)

## 23.extern"C" 的用法
`extern "c" ` 的主要作用就是为了**能够正确实现 C++ 代码调用其他 C 语言代码**。加上 `extern “c”` 后，会指示**编译器这部分的代码按C语言，而不是C++的方式进行编译**。


由于C++支持函数重载，因**此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。


**extern "C"使用要点**：

- 可以是单一语句：`extern “C” double sqrt(double);`
- 可以是复合语句，相当于复合语句中的声明都加了 `extern “C”`：`extern “C”{ double sqrt(double); int min(int, int);}`
- 可以包含头文件，相当于头文件中的声明都加了extern “C” ：`extern “C”{＃include <cmath> }`
- 不可以将 extern “C” 添加在函数内部;
- 如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。


## 24.野指针和悬空指针
- **野指针**：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空；
- **悬空指针**：指针 free 或 delete 之后没有及时置空  => 释放操作后立即置空；

C++智能指针的本质就是避免悬空指针的产生。

## 25.C 和 C++ 的类型安全？
类型安全很大程度上可以等价于内存安全，**类型安全的代码不会试图访问自己没被授权的内存区域**。

<font color="#F100">**类型安全**是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据是用类型来解释的)。</font>

C 只在局部上下文中表现出类型安全；因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1，用boolean来解释就是true。

如果C++使用得当，它将远比C更有类型安全性。相比于C，C++提供了一些新的机制保障类型安全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*；
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
- C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。


Java语言是类型安全的，除非强制类型转换。

[http://t.csdnimg.cn/AlWSs](http://t.csdnimg.cn/AlWSs)


## 26.C++中的重载、重写(覆盖)和隐藏的区别？
**重载**：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，**重载不关心函数返回类型**。

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，注意**只要同名函数，不管参数列表是否相同，基类函数都会被隐藏**。

**重写(覆盖)**：是指派生类中存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。**只有函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 `virtual` 修饰，派生类可以没有。


## 27.C++有哪几种的构造函数
通常 C++中的构造函数可以分为5类：默认构造函数、普通构造函数、拷贝构造函数、转换构造函数、移动构造函数。

- **默认构造函数**：未提供显式初始值时，用来创建对象的构造函数`Student();//没有参数`；
- **普通构造函数**：C++用于构建类的新对象时需要调用的函数`Student(int num，int age）;//有参数`；
- **拷贝构造函数**：何时生成默认的拷贝构造函数；
- **转换构造函数**：一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象【string 类中可以找到使用转换构造函数的实用示例】；
- **移动构造函数**：以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。


委托构造函数是C++11引入的一个特性，它**允许一个构造函数调用同一类的另一个构造函数**，从而避免在类内部出现相似的初始化代码，提高代码的可维护性。在构造函数的初始化列表中使用` : `符号，可以调用同一类中的其他构造函数。

委托构造函数的调用必须出现在构造函数的初始化列表中。在构造函数主体中调用其他构造函数是不允许的。

## 28.浅拷贝和深拷贝的区别
**浅拷贝**：浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，**如果原来的指针所指向的资源释放了，我那么再释放浅拷贝的指针的资源就会出现错误**。

**深拷贝**：**深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值**，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

深拷贝和浅拷贝是指在赋值一个对象时，拷贝的深度不同。 在进行深拷贝时，会拷贝所有的属性，并且如果这些属性是对象，也会对这些对象进行深拷贝，直到最底层的基本数据类型为止。

## 29.内联函数和宏定义的区别
**宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的**。

而且**内联函数是真正的函数**，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

**内联函数有类型检测、语法判断等功能，而宏没有。**


## 30.public, protected 和 private 访问和继承权限 /public/protected/private 的区别?
**访问权限：**

- public:可以被任意实体访问；
- protected:只允许子类及本类的成员函数访问；
- private:只允许本类的成员函数访问；

**继承：**

1. public 继承不改变基类成员的访问权限；
2. private 继承使得基类所有成员在子类中的访问权限变为 private；
3. protected 继承将基类中public成员变为子类的protected成员，其它成员的访问 权限不变；
4. 基类中的 private 成员不受继承方式的影响，子类永远无权访问。


友元是一种**定义在类外部的普通函数，但它需要在类体内进行声明**，为了与该类的成员函数加以区别，在声明时前面加以关键字 `friend`。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

[【C++】友元函数和友元类（作用及优缺点）](http://t.csdnimg.cn/ThyG8)

## 31.如何用代码判断大小端存储？
- **大端存储**：是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中；
- **小端存储**：是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

<font color="#F100">想办法取出一个字节的内容，就可以知道是哪种存储方式。</font>

初始化一个 `16 进制` 的int型的数据，然后把它放在一个 `char` 类型的数组中，由于**十六进制的数据一位代表四个bit位**；`char` 型是8个bit位，那么十六进制的两位占一个 `char` 位，那么就可以把数据位分离。

**方法一：直接法**

	int main()
	{
		int a = 0x12345678;
		char i = a;
		printf("%x", i);
	}
定义一个十六进制的数据，数据类型为int型，之后定义一个char类型的数据，**int数据类型的大小为四个字节，而char类型的数据为一个字节，所以将int类型的数据赋值给char时会丢失三个字节的数据，char类型中存储的是int类型中低地址的数据**，这时候char类型获取的数据输出之后，如果输出的是12那就说明你低地址位置的数据是12，那就说明你的数据是大端存储，如果输出的结果是78那当前条件下就是小端存储。

**方法二：指针法**

	int main()
	{
	    int i = 0x1122;
		char* p = (char*)& i;
		if (p[0] == 0x22 && p[1] == 0x11) {
			cout << "little endian" << endl;
		}
		else if (p[0] == 0x11 && p[1] == 0x22) {
			cout << "big endian" << endl;
		}
	}

`*p`就是`p[0]`，把变量的地址强制类型转换为`char*`，这样就可以每次取出一个字节的内容，因为 `char` 的大小就是1个字节，`p[0]`和`p[1]`都表示一个 `char` 类型。

将`int*`类型的` &i`强制转换为了`char*`类型，但值没有改变（地址）；地址存储的值也未改变，`p` 就是表示的这个地址，但 `p` 是 `char*` 类型的变量，因此可以用`p[0]p[1]`去取，每一个`p[]`就是两个十六进制的数（也就是一个字节）。`p[0]`就是`0x22`, `p[1]`就是`0x11`。

**方法三：联合体法**

	int main(){
		union
		{
			int value;
			char union_bytes[ sizeof(int) ];
		} test;
		test.value = 0x0102;
		if (  ( test.union_bytes[ 0 ] == 1 ) && ( test.union_bytes[ 1 ] == 2 ) )
		{
			printf( "big endian\n" );
		}
		else if ( ( test.union_bytes[ 0 ] == 2 ) && ( test.union_bytes[ 1 ] == 1 ) )
		{
			printf( "little endian\n" );
		}
		else
		{
			printf( "unknown...\n" );
		}
	}
在联合体中定义一个 char 类型的变量和 int 类型的变量，利用二者所占同一段存储空间，可以通过引用联合体变量中的成员访问 `char`  类型的数据，取出一个字节的内容。

**在 `union` 中所有的数据成员共用一个空间**，而且是**从低位开始占用**，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，**共用体变量的内存空间大小是该变量中某个占用空间最大的那个成员所占的空间**。。

即上述的union虽然定义了两个成员，但其实这个union只占用了4个字节(32位机器中 int 所占的空间大小)，往 value 成员赋值（value完整是0x00000102），然后读取 union_bytes ，union_bytes[0]就是value的第一个字节，union_bytes[1]就是value的第二个字节。

[http://t.csdnimg.cn/lm2iI](http://t.csdnimg.cn/lm2iI)


## 32.volatile、mutable 和 explicit 关键字的用法？
volatile 关键字是一种类型修饰符，用它声明的类型变量**表示可以被某些编译器未知的因素更改**。

<font color="#F100">当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</font>


volatile 定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

多线程中被几个任务共享的变量需要定义为 volatile 类型。


volatile 限定符的用法和 const 很相似，它起到对类型额外修饰的作用；const 和volatile 限定符互相没什么影响，**某种类型可能既是 const 的也是 volatile 的**，此时它同时具有二者的属性。

只有 `volatile` 的成员函数才能被 `volatile` 的对象调用。

可以把一个非 volatile in t赋给 volatile int，但是不能把非 volatile 对象赋给一个volatile对象。

**mutable**

- 用 const 修饰的成员函数时，**const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量**，当成员变量类型符前用 `mutable` 修饰时例外。

-  常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰；


> 常函数不能对普通成员变量（除mutable修饰外）进行写操作 ；
> 常函数可以被普通对象或者常对象调用；
> 
> 常对象不能调用所有普通函数，只能调用常函数；
> 常对象可以读成员变量；
> 
> [http://t.csdnimg.cn/pOfDm](http://t.csdnimg.cn/pOfDm)


**explicit**

c++ 提供了关键字 `explicit`，禁止通过构造函数进行的隐式转换。声明为 `explicit` 的构造函数不能在隐式转换中使用。

- 是针对**单参数**的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。
-  explicit用于修饰构造函数，防止隐式转化。




[https://www.cnblogs.com/codemagiciant/p/17524184.html](https://www.cnblogs.com/codemagiciant/p/17524184.html)


## 33.什么情况下会调用拷贝构造函数？
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是**使用同一类中之前创建的对象来初始化新创建的对象**。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象；
- 复制对象把它作为参数传递给函数；
- 复制对象，并从函数返回这个对象；

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

## 34.C++中有几种类型的new（plain new\nothrow new\placement new)

**1. plain new**

言下之意就是普通的 `new`，就是我们常用的 `new`；

在C++中定义如下：

	void* operator new(std::size_t) throw(std::bad_alloc);
	void operator delete(void *) throw();
	Copy to clipboardErrorCopied
因此 plain new 在空间分配失败的情况下，抛出异常`std::bad_alloc`而不是返回 `NULL`，因此通过判断返回值是否为 `NULL` 是徒劳的。

**2.nothrow new**

	char *p = new(nothrow) char[10e11];
`nothrow new `在空间分配失败的情况下是不抛出异常，而是返回 `NULL`；


**3.placement new**

    ADT *q = new(p) ADT;
这种 new **允许在一块已经分配成功的内存上重新构造对象或对象数组。** `placement new`不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。

	void* operator new(size_t,void*);
	void operator delete(void*,void*);
	Copy to clipboardErrorCopied

`palcement new` 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组；

`placement new`构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为`placement new`构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。


## 35.C++的异常处理的方法
- try、throw 和 catch 关键字`try...(throw)...catch...`；
- 函数的异常声明列表：在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表`int fun() throw(int,double,A,B,C) {...};`
这种写法表名函数可能会抛出 `int,double` 型或者A、B、C三种类型的异常，如果 `throw` 中为空表明不会抛出任何异常，如果没有 `throw` 则可能抛出任何异常【在C++11这种做法已经被摒弃，而后者则被C++11的 noexcept （noexcept 的一个作用是**阻止异常的传播，提高安全性**）异常声明所代替：`void func() noexcept {...}//等价于void func() throw(){...}`】；
- C++标准异常类 `exception`：C++标准提供了一组标准异常类，这些类以基类 Exception 开始，标准程序库抛出的所有异常，都派生于该基类，该基类提供一个成员函数 what()，用于返回错误信息（返回类型为 const char*）。

【析构函数默认也是noexcept的】

[https://www.cnblogs.com/QG-whz/p/5136883.html](https://www.cnblogs.com/QG-whz/p/5136883.html)
[https://www.cnblogs.com/suozhiyuan/p/12528891.html#_label0](https://www.cnblogs.com/suozhiyuan/p/12528891.html#_label0)

## 36.值传递、指针传递、引用传递的区别和效率

**传值**： 函数参数压栈的是参数的副本。  
任何的修改是在副本上作用，没有作用在原来的变量上。  

**传指针**：压栈的是指针变量的副本。    
当你对指针解指针操作时，其值是指向原来的那个变量，所以**对原来变量操作**。  

**传引用**：压栈的是引用的副本。由于引用是指向某个变量的，对引用的操作其实就是**对他指向的变量的操作**。

**传递效率上**： 调用被调函数的代码将实参传递到被调函数体内的过程。 
指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。 

**执行效率上**：在被调用的函数体内执行时的效率。    
因为传值调用时，当值被传到函数体内，临时对象生成以后，所有的执行任务都是通过**直接寻址**的方式执行的，而指针和大多数情况下的引用则是以**间接寻址**的方式执行的，所以实际的执行效率会比传值调用要低；如果函数体内对参数传过来的变量进行操作比较频繁，执行总次数又多的情况下，传址调用和大多数情况下的引用参数传递会造成比较明显的执行效率损失。

[https://www.cnblogs.com/ywliao/articles/8127531.html](https://www.cnblogs.com/ywliao/articles/8127531.html)

## 37.C++ 全局变量和 static 变量初始化问题
- 全局变量、文件域中的静态变量、类中的成员静态变量在 main 函数执行前初始化；局部变量中的静态变量在第一次调用时初始化。


**在 C 语言中是编译期初始化并分配内存**，故不能用变量给静态局部变量赋值，只能用常量。

**在C++中是第一次执行时初始化**，因为 C++ 引入了对象的概念，对象一般需要构造函数，无法简单的分配内存，故可以用变量赋值，并且在**第一次使用时初始化**。


- 初始化顺序：对于编译单元（同一个文件）的全局变量来讲，初始化顺序跟声明的顺序一致。销毁顺序则相反。
对于不同编译单元的全局变量，初始化顺序不确定。对于不同编译单元的全局变量互相引用的情况应避免。

解决不同文件相互引用全局变量初始化顺序不确定问题：可以通过函数调用，引用的时候不直接引用全局变量，而是放在一个函数中。**函数中的全局变量在调用时初始化**。


**类的静态成员变量声明和定义**   
静态成员变量不属于任何一个对象，对象的数据中不应该包含静态成员的数据。所以在**定义类的时候不会给静态变量分配内存只是声明**，因此就要在其他地方分配即定义。

> 定义与声明的区别  
**声明**：只是向程序表面变明的类型和名字。    
**定义**：为变量分配内存，也可以顺便初始化。程序中变量有且只有一个定义（更能说明为什么要在类外再定义下类的静态成员变量了）





## 38.new 和 malloc 的区别
1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；
2、使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；而malloc则需要显式地指出所需内存的尺寸。  
3、 new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 new 是符合类型安全性的操作符。而malloc内存分配成功则是返回`void*`需要**通过强制类型转换将`void*`指针转换成我们需要的类型**。  
4、new 内存分配失败时，会抛出 `bac_alloc` 异常。malloc分配内存失败时返回NULL。  
5、 new 会先调用`operator new`函数，申请足够的内存(通常底层使用malloc实现)。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用operator delete函数释放内存(通常底层使用free实现)。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做**自定义类型对象构造和析构工作**。


## 39.delete p、delete [] p、allocator都有什么作用?
- delete p是用于释放由 new 运算符分配的单个对象的内存。
- 如果使用 new[] 运算符创建了一个对象数组，那么应该使用delete [] p 来释放内存，而不是 delete p。【delete[] p是用于释放由`new[]`运算符分配的对象数组的内存。在释放内存时，delete[] p会**调用每个对象的析构函数**，然后释放整个数组的内存（delete[时，数组中的元素按**逆序**的顺序进行销毁）】。

- new在内存分配上面有一些局限性，new 的机制是将内存分配和对象构造组合在一起同样的，delete 也是将对象析构和内存释放组合在一起的。allocator 将这两部分分开进行， **allocator 申请一部分内存，不进行初始化对象**，只有当需要的时候才进行初始化操作。

[https://www.cnblogs.com/codemagiciant/p/17524217.html](https://www.cnblogs.com/codemagiciant/p/17524217.html)


allocator的主要作用如下：

1.**内存分配**：allocator负责为容器中的元素分配内存。它使用动态内存分配机制（如new和malloc）从堆上分配内存，并返回指向分配内存的指针。

2.**内存释放**：当元素被从容器中移除或容器被销毁时，allocator负责释放先前分配的内存。它使用delete和free等函数释放先前分配的内存。

3.**对象构造和析构**：allocator还负责在分配的内存空间中构造和析构对象。当新元素被添加到容器中时，allocator使用元素的构造函数来创建对象，并在元素被移除时调用析构函数来销毁对象。

4.**内存对齐**：allocator还负责按照特定的内存对齐方式来分配内存，以确保对象的起始地址满足对齐要求。这对于某些类型的对象（如带有对齐要求的结构体）非常重要。


## 40.new和delete的实现原理，delete是如何知道释放内存的大小的？
new 和 delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。

C++ 的做法是在分配数组空间时多分**配了4个字节的大小，专门保存数组的大小**，在 delete 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。



[http://t.csdnimg.cn/NX0dG](http://t.csdnimg.cn/NX0dG)


## 41.malloc、realloc、calloc的区别
malloc 申请的空间的值是随机初始化的；  
calloc 申请的空间的值是初始值为0；  
realloc 给动态分配的空间分配额外的空间，用于扩充容量。


## 42.malloc与free的实现原理?
`malloc` 小于`128k`的内存，使用 `brk` 分配内存，将「堆顶」指针往高地址推；`malloc` 大于 `128k` 的内存，使用 `mmap` 分配内存，在堆和之间找一块空闲内存分配；

**brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。** 

**malloc分配内存之后，只是分配了虚拟内存，还没有映射到物理内存，只有当访问申请的内存的时候，才会发生缺页中断，分配对应的物理内存**

当最高地址空间的空闲内存超过128K(可由M TRIM THRESHOLD选项调节)时，执行内存紧缩操作(trim)。【调用`sbrk(-size)`将内存归还操作系统】


[https://jacktang816.github.io/post/mallocandfree/](https://jacktang816.github.io/post/mallocandfree/)


## 43.类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？
**赋值初始化**，通过在函数体内进行赋值初始化；  
**列表初始化**，在冒号后使用初始化列表进行初始化。

主要区别在于：  
<font color = blue>对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的；  </font>
列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)，那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说**初始化这个数据成员此时函数体还未执行**。


一个派生类构造函数的执行顺序如下：  
① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）；  
② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）；  
③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）；  
④ 派生类自己的构造函数。


方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，**C++的赋值操作是会产生临时对象的**。临时对象的出现会降低程序的效率。


## 44.有哪些情况必须用到成员列表初始化？作用是什么？
1.**必须使用成员初始化**的四种情况：  
① 当初始化一个引用成员时；  
② 当初始化一个常量成员时；  
③ 当调用一个基类的构造函数，而它拥有一组参数时；  
④ 当调用一个成员类的构造函数，而它拥有一组参数时；  

**成员初始化列表做了什么**：  
① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；  
② list 中的项目顺序是**由类中的成员声明顺序决定**的，不是由初始化列表的顺序决定的。

## 45.C++中新增了string，它与C语言中的 char * 有什么区别吗？它是如何实现的？
string 继承自 `basic_string`，其实是对 `char* `进行了封装，封装的 string 包含了 `char*` 数组，容量长度等等属性。

`string` 可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间 (`2*n`) 然后将原字符串拷贝过去，并加上新增的内容。


## 46.什么是内存泄露，如何检测与避免？
**内存泄露**  
一般我们常说的内存泄漏是指**堆内存的泄漏**。  
堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定）内存块，使用完后必须显式释放的内存。应用程序般使用 malloc、realloc、new 等函数从堆中分配到块内存，
**使用完后，程序必须负责相应的调用 free 或 delete 释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏**。

避免内存泄露的几种方式  
计数法：使用 new 或者 malloc 时，让该数+1，delete 或 free 时，该数 -1，程序执行完打印这个计数，如果不为 0 则表示存在内存泄露；  
一定要将基类的析构函数声明为虚函数【否则不会调用派生类的析构函数，要能够保证继承关系中最高的基类的析构函数是虚的（具有传递性）】；  
对象数组的释放一定要用delete []；  
有 new 就有delete，有 malloc 就有 free，保证它们一定成对出现；

检测工具  
Linux下可以使用Valgrind工具；  
Windows下可以使用CRT库。

## 47.对象复用的了解，零拷贝的了解
**对象复用是指将已经创建的对象进行重复使用，而不是创建新的对象。**  

在面向对象编程中，对象复用可以通过以下几种方式实现：  
1.**对象池** ：对象池是一种常见的对象复用方式，它可以将已经创建的对象保存起来，并在需要时将其重新使用。  
2.**模板类和模板对象** ：模板类和模板对象可以将一些公共的行为封装在类和对象中，从而实现对象的复用。  
3.**类的成员变量** ：类的成员变量可以是类的实例对象，这样可以将对象的状态和行为保存在类的成员变量中，从而实现对象的复用。  
4.**对象的静态变量** ：对象的静态变量可以是类的实例对象，这样可以将对象的状态和行为保存在类的静态变量中，从而实现对象的复用。

**零拷贝是指在程序运行过程中，对对象的复制和初始化过程中，只复制对象的引用而不复制对象本身**。  
这样可以避免对象的内存分配和释放过程，从而提高程序的性能。零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。  
实现零拷贝的方法有多种，其中最常见的是使用**C++中的智能指针和垃圾回收器**。


## 48.介绍面向对象的三大特性，并且举例说明
**1.封装**  
C++中的封装是指将属性和方法包装在一个类中，并通过访问控制符来限制外部对类的访问。封装可以提高代码的可维护性和安全性，同时也可以实现多态性。


**2.继承**  
C++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。


**3.多态**
同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）【允许将子类类型的指针赋值给父类类型的指针（向上转换）】。

实现多态有二种方式：覆盖（override），重载（overload）。

## 48.C++的四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast

**为什么C++需要四种类型转换？**  
**1.隐式转换缺点**：  

- 可能会导致数据精度丢失：当将一个数据类型转换为另一个数据类型时，可能会发生精度丢失，例如将一个浮点数转换为整数时，小数部分会被截断。
- 可能导致未定义行为：隐式转换可能会导致未定义行为，例如将一个指针类型转换为整数类型可能会导致未定义行为。
- 代码不够清晰：隐式转换可能会使代码不够清晰，因为它不需要在代码中明确地指定转换的类型。

【C++中提供了 `explicit` 关键字，在构造函数声明的时候加上 `explicit` 关键字，能够**禁止隐式转换**】


**2.显式转换缺点：**

- 可能会导致数据失真：当使用显式转换将一个数据类型转换为另一个数据类型时，可能会导致数据失真，例如将一个整数转换为浮点数时，小数部分可能会出现不准确的情况。
- 可能会导致代码不够清晰：显式转换需要程序员在代码中明确地指定转换的类型，这可能会使代码不够清晰，同时也增加了代码的复杂性。


C++中的类型转换包括**自动类型转换**、**强制类型转换**、**类型解析转换**和**类型推断转换**。

- **static_cast**（编译时类型检查）：`static_cast < type-id > ( expression )`，将 `expression` 转换为 `type-id` 类型。  
<font color = red>static_cast 是静态类型转换，发生在编译期。这种转换不会进行运行时的动态检查（RTTI），因而这种转换可能是不安全的。 </font>
- **const_cast**：`const_cast` 只能改变运算对象的**底层 const**，用来移除变量的 `const` 或 `volatile` 限定符。  
注意：`const_cast` 是不能用来执行任何类型的转换的，比如只能将 `const char* p` 转换成` char* p`，而不能转成 `int* p`。
- **reinterpret_cast**：`reinterpret_cast` 可以将指针类型任意转换，甚至是不相关的类之间（既不检查指针所指向的内容，也不检查指针类型本身）【旧式强制类型转换执行与reinterpret_cast类似的功能】；
- **dynamic_cast**：`dynamic_cast` 只能用于指向类的指针和引用(或void*)。它的目的是确保类型转换的结果指向目标指针类型的有效完整对象。  
`dynamic_cast` 主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性（）

> 何为安全性？  
> 即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL，之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。


C++中层次类型转换中无非两种：上行转换和下行转换

- 对于上行转换，`static_cast` 和 `dynamic_cast` 效果一样，都安全；
- 对于下行转换：你必须确定要转换的数据确实是目标类型的数据，即需要注意要转换的父类类型指针是否真的指向子类对象，如果是，`static_cast` 和 `dynamic_cast` 都能成功；如果不是 `static_cast` 能返回，但是不安全，可能会出现访问越界错误，而 `dynamic_cast` 在运行时类型检查过程中，判定该过程不能转换，返回NULL。



[https://www.cnblogs.com/codemagiciant/p/17544722.html](https://www.cnblogs.com/codemagiciant/p/17544722.html)

## 49.C++函数调用的压栈过程
1. 当函数从入口函数 `main` 函数开始执行时，编译器会将我们操作系统的运行状态，`main` 函数的返回地址、`main` 的参数、`mian` 函数中的变量、进行依次压栈；
2. 当 `main` 函数开始调用 `func()` 函数时，编译器此时会将 `main` 函数的运行状态进行压栈，再将 `func()` 函数的返回地址、`func()` 函数的参数从右到左、`func()`  定义变量依次压栈；
3. 当 `func()` 调用 `f()` 的时候，编译器此时会将 `func()` 函数的运行状态进行压栈，再将的返回地址 `f()` 函数的参数从右到左、`f()`定义变量依次压栈。

**函数的调用过程**  
1)从栈空间分配存储空间；  
2)从实参的存储空间复制值到形参栈空间；  
3)进行运算


## 50. 写 C++ 代码时有一类错误是 coredump，很常见，你遇到过吗？怎么调试这个错误？
coredump 是程序由于异常或者 bug 在运行时异常退出或者终止，在一定的条件下生成的一个叫做 core 的文件，这个 **core 文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等**。对这个文件进行分析**可以定位到程序异常的时候对应的堆栈调用信息**。

【使用gdb命令对core文件进行调试】：`gdb [可执行文件名] [core文件名]`


## 51.说说移动构造函数
移动构造是C++11标准中提供的一种新的构造方法。  

移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为 `nullptr`，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。即提高程序的执行效率，节省内存消耗。

移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是**移动构造函数的初值是一个右值引用**。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个 **move 语句，就是将一个左值变成一个将亡值**。

> 何为左值？能用取址符号 & 取出地址的皆为左值，剩下的都是右值。
> std::move() 能把左值强制转换为右值。
> 【匿名变量一律属于右值】

[C++中的左值、纯右值、将亡值](https://www.cnblogs.com/zpcdbky/p/5275959.html)

[http://t.csdnimg.cn/zleoS](http://t.csdnimg.cn/zleoS)

## 52.C++中将临时变量作为返回值时的处理过程
首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，**当函数退出时，临时变量出栈，即临时变量已经被销毁**，临时变量占用的**内存空间没有被清空，但是可以被分配给其他变量**，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了。  
函数调用结束后，**返回值被临时存储到寄存器中**，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系。
如果我们需要返回值，一般使用赋值语句就可以了。

## 53.静态类型和动态类型，静态绑定和动态绑定的介绍
- **静态类型**：对象在声明时采用的类型，在编译期既已确定；
- **动态类型**：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；
- **静态绑定**：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
- **动态绑定**：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

从上面的定义也可以看出，**非虚函数一般都是静态绑定，而虚函数都是动态绑定**（如此才可实现多态性）。

<font color="#F100">绝对不要重新定义一个继承而来的 `virtual` 函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而 `virtual` 函数却是动态绑定。</font>

[https://www.cnblogs.com/lizhenghn/p/3657717.html](https://www.cnblogs.com/lizhenghn/p/3657717.html)


## 54.指针加减计算要注意什么?
	int *a, *b, c;
	a = (int*)0x500;
	b = (int*)0x520;
	c = b - a;
	printf("%d\n", c); // 8
	a += 0x020;
	c = b - a;
	printf("%d\n", c); // -24

首先变量 `a` 和 `b` 都是以 `16` 进制的形式初始化，将它们转成 `10` 进制分别是`1280(5*16^2=1280)`和`1312(5*16^2+2*16=1312)`，那么它们的差值为`32`，也就是说a和b所指向的地址之间间隔`32`个位，但是考虑到是 `int` 类型占 `4` 位，所以 `c` 的值为`32/4=8`

`a `自增`16`进制 `0x20` 之后，其实际地址变为`1280+2*16*4=1408`，(`因为一个int占4位，所以要乘4`)，这样它们的差值就变成了`1312-1280=-96`，所以`c`的值就变成了`-96/4=-24`。

<font color=blue> 需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成 10 进制计算，计算结果除以类型长度取得结果 </font>

## 55.怎样判断两个浮点数是否相等？
浮点数在内存中的存储有舍入误差，在计算机中用近似表示某个实数；
所以不能用`==`来判断两个浮点数是否相等，而是

	const double eps = 1e-8;
	
	if(abs(a-b) <= eps)  相等
	else 不相等

**对于两个浮点数比较只能通过相减并与预先设定的精度比较**，记得要取绝对值。浮点数与 0 的比较也应该注意。与浮点数的表示方式有关。


**结构体变量比较是否相等**  
1.重载了“==”操作符；  

	struct foo {
	
	  int a;
	  int b;
	
	  bool operator==(const foo& rhs) *//* *操作运算符重载*
	
	  {
	    return( a == rhs.a) && (b == rhs.b);
	  }
	};
2.元素的话，一个个比；  
3.指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真;





## 56.C++中的指针参数传递和引用参数传递有什么区别?底层原理你知道吗?
**1) 指针参数传递本质上是值传递，它所传递的是一个地址值。**

值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。  
值传递的特点是，被调函数对形式参数的任何操作都是作为**局部变量**进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

 
**2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。**

被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。  
因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

**3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。**

而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

 

**4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。**

指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。  
符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。


[https://www.cnblogs.com/crbhf/p/15004480.html](https://www.cnblogs.com/crbhf/p/15004480.html)

## 57.类如何实现只能静态分配和只能动态分配？
1.前者是把 `new`、`delete` 运算符重载为 `private` 属性。后者是把构造、析构函数设为 `protected` 属性，再用子类来动态创建；

2.建立类的对象有两种方式：

① 静态建立，例如 A a;

静态建立一个类对象，就是由编译器为对象在栈空间中分配内存。使用这种方法，是直接调用类的构造函数。

② 动态建立，例如 A *p = new A();

动态建立一个类对象，就是使用 `new` 运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行`operator new()`函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；

<font color=red>**只有使用new运算符，对象才会被建立在堆上**</font>，因此只要限制 `new` 运算符就可以实现类对象只能建立在栈上，可以将 `new` 运算符设为私有。

## 58.继承机制中对象之间如何转换？指针和引用之间如何转换?
**1. 向上类型转换**  
将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。

**2. 向下类型转换**  
将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI（运行时类型识别（Run-Time Type Identification，RTTI））技术，用 `dynamic_cast` 进行向下类型转换。

**指针和引用之间怎么转换：**  

- 指针转引用：把指针用`*`就可以转换成对象，可以用在引用参数当中。
- 引用转指针：把引用类型的对象用`&`取地址就获得指针了。

[https://www.cnblogs.com/swk0918/p/14444983.html](https://www.cnblogs.com/swk0918/p/14444983.html)

## 59.知道C++中的组合吗？它与继承相比有什么优缺点吗？
**继承：**  
优点：是子类可以重写父类的方法来方便地实现对父类的扩展。  
缺点：

- 父类的内部细节对子类是可见的；
- 子类从父类继承的方法在编译时就确定下来了，无法在运行期间改变从父类继承的方法的行为；
- 如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。
- 子类与父类是一种高耦合，违背了面向对象思想。

**组合**   
设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。  
优点：

- 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
- 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
- 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值


缺点：

- 容易产生过多的对象；
- 为了能组合多个对象，必须仔细对接口进行定义。

[http://t.csdnimg.cn/sU2LO](http://t.csdnimg.cn/sU2LO)

## 60.函数指针？
函数指针**指向的是函数而非对象**。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。

要想声明一个可以指向该函数的指针，只需要**用指针替换函数名即可**。

**为什么有函数指针**：函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。

**一个函数名就是一个指针，它指向函数的代码**。  
一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；

两种赋值方法：`指针名 =函数名`；`指针名=&函数名`

> `decltype` 与 `auto` 关键字一样，用于**进行编译时类型推导**，不过它与 auto 还是有一些区别的。decltype 的类型推导并不是像 auto 一样是从变量声明的初始化表达式获得变量的类型，而是总是**以一个普通表达式作为参数**，返回该表达式的类型，而且 **decltype 并不会对表达式进行求值**。  
> [https://www.cnblogs.com/QG-whz/p/4952980.html](https://www.cnblogs.com/QG-whz/p/4952980.html)


## 61.说一说你理解的内存对齐以及原因？
内存对齐是指在结构体中，**成员变量按照特定规则排列**以满足硬件平台要求和提高性能的过程。

1.平台原因：  
不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2.性能原因 ：  
数据结构( 尤其是栈 ) 应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。这里归根结底的来说就**是以空间换时间** 。


[https://blog.csdn.net/weixin_45897952/article/details/123727425](https://blog.csdn.net/weixin_45897952/article/details/123727425)


**对齐规则**  
1.每个特定平台上的编译器都有自己的默认“对齐系数”#pragma pack(show)可以查看；  
2.有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。  
3.结构体第一个成员变量的偏移量(offset)为0，以后每个数据成员的起始位置要从自身大小的整数倍开始存储；  
4.结构体的总大小为：若没有设定对齐字节数，则最大成员为对齐字节数。若有设定对齐字节数，则对齐字节数为：min(最大成员，设定的对齐字节数)的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

<font color=blue>对齐规则是按照成员的声明顺序，依次安排内存，其偏移量为成员大小的整数倍，0看做任何成员的整数倍，最后结构体的大小为最大成员的整数倍</font>

## 62.函数调用过程栈的变化，返回值和参数变量哪个先入栈？
1. 将函数的参数压入栈中。参数的压入顺序与调用约定有关，在大多数C/C++编译器中，在函数调用的过程中，函数的参数是 ***由右向左*** 入栈的；
2. 将**当前函数的返回地址**压入栈中。返回地址是指函数调用结束后回到调用点的地址。
3. 将当**前函数的栈帧**（Stack Frame）压入栈中。栈帧包括本地变量、临时变量、函数的返回值等信息。栈帧的大小取决于函数中定义的变量和数据类型。
4. 跳转到**函数的入口点**开始执行函数代码。
5. 函数执行完毕后，将**返回值存放在寄存器中**（或者放在栈内存中），然后将栈帧弹出，恢复返回地址，跳转回调用点。

在返回之前，可以进行一些清理工作，例如释放内存、关闭文件等。函数调用过程中，栈的变化是动态的，每次函数调用都会增加栈的深度，而函数返回时栈的深度又会减少。如果递归调用函数，栈的深度会不断增加，直到达到一定限制，例如栈溢出。

## 63.你知道 printf 函数的实现原理是什么吗？
printf 是格式化输出可以自己定义输出的格式；`printf(“%d\n”,a),`其中" "之间的是格式说明串。% 后的一个或两个字符是格式说明符，用它来控制输出变量值的形式,
printf可以输入以上两种格式:

- 字符说明符 `%c` 同于 `putchar`；
- 字符串说明符 `%s` 同于 `puts`；


压栈时从右往左压栈，因此，printf  的第一个被找到的参数就是那个**字符指针**，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了。

## 64.为什么模板类一般都是放在一个 h 文件中？
1. 模板定义很特殊。由`template<…>`处理的任何东西都意味着编译器**在当时不为它分配存储空间**，它一直处于**等待状态直到被一个模板实例告知**。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。
2. 在分离式编译的环境下，编译器编译某一个`.cpp`文件时并不知道另一个`.cpp`文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为**模板仅在需要的时候才会实例化出来**。    
所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。  
然而**当实现该模板的`.cpp`文件中没有用到模板的实例**时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。

## 65.cout 和 printf 有什么区别？
C中的printf是一个标准的**输出函数**。  
C++中的cout是在iostrem文件中定义的**全局对象**。


**1.原理不同**  
    std::cout<<“输出内容"std::endl;  
其中`<<`操作符提取"输出内容”，然后进行重载，同时重载函数，根据"输出内容"的类型来重载不同类型的函数。

同时在定义每一个流对象时，系统会在内存中**开辟一段缓冲区（全缓冲）**，用来暂存数据（系统内有多个缓冲区）。此时当收到endl时，cout行会进行换行，同时刷新缓冲区。  
当缓冲区满或者收到结束符时，会将缓冲区数据一并清空并在显示设备输出。  
**flush 立即强迫缓冲输出**。

printf 是**行缓冲输出**，不是无缓冲输出。

> **全缓冲**： 全缓冲就是等待标准IO缓冲区填满或者flush操作，才进行IO操作输入输出  ；  
**行缓冲**：当遇到 \n 回车换行符时，进行IO操作输入输出；  
**无缓冲**：没有缓冲，直接进行IO操作；

**2.cout与printf格式不同**：  
**cout**：` std::cout<<"任意类型函数"std::endl;`  
**printf**：` printf(“其他+%转换+其他”，参数)`；


**3.输出效率不同(C++中 cin,cout 是不是效率不如scanf,printf)**：    
因为 printf 是在编译期确定操作数类型和调用的输出函数，**不用在运行期解析格式**控制字符串带来额外开销。不过标准流对象 cin/cout 为了普适性，继承体系很复杂，所以在对象的构造等方面会影响效率，因此总体效率比较低。。

## 66.你知道重载运算符吗？
重载的运算符是带有特殊名称的函数，函数名是由**关键字 operator** 和其后**要重载的运算符符号**构成的。

1. **只能重载已有的运算符**，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；
2. 两种重载方式：**成员运算符和非成员运算符**，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；
3. 引入运算符重载，是为了实现类的**多态性**；
4. 当重载的运算符是成员函数时，**this 绑定到左侧运算符对象**。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；
5. 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（`+，-，*，&`）；
6. **下标运算符必须是成员函数**，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；
7. **箭头运算符必须是类的成员**，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；


当程序中有函数重载时，函数的匹配原则和顺序：
1.名字查找（选定候选函数）；
2.确定候选函数（选定可行函数）；
3.寻找最佳匹配；

<font color=blue>**重载可以根据静态子类型分派不同表现，所以它是一种静态多态。**</font>


## 67.动态多态和静态多态的比较
**静态多态**  

优点：

- 由于**静多态是在编译期完成的**，因此效率较高，编译器也可以进行优化；
- 有很强的适配性和松耦合性，比如可以通过偏特化、全特化来处理特殊类型；
- 最重要一点是静态多态通过模板编程为C++带来了泛型设计的概念，比如强大的STL库。

缺点：

- 由于是模板来实现静态多态，因此模板的不足也就是静多态的劣势，比如调试困难、编译耗时、代码膨胀、编译器支持的兼容性
- 不能够处理异质对象集合；


**动态多态**

优点：

- OO设计，对是客观世界的直觉认识；
- 实现与接口分离，可复用；
- 处理同一继承体系下异质对象集合的强大威力；


缺点：

- 运行期绑定，导致一定程度的运行时开销；
- 编译器无法对虚函数进行优化
- 笨重的类继承体系，对接口的修改影响整个类层次；


**不同点：**

- 本质不同，静态多态在编译期决定，由模板具现完成，而动态多态在运行期决定，由继承、虚函数实现；
- 动态多态中接口是显式的，以函数签名为中心，多态**通过虚函数在运行期实现**；静态多台中接口是隐式的，以有效表达式为中心，多态通过模板具现在编译期完成


**相同点：**

- 都能够实现多态性，静态多态/编译期多态、动态多态/运行期多态；
- 都能够使接口和实现相分离，一个是模板定义接口，类型参数定义实现，一个是基类虚函数定义接口，继承类负责实现；



[https://www.cnblogs.com/lizhenghn/p/3667681.html](https://www.cnblogs.com/lizhenghn/p/3667681.html)

## 68.定义和声明的区别
**如果是指变量的声明和定义**：  
从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。

**如果是指函数的声明和定义**：  
**声明**：一般在头文件里，对编译器说{这里我有一个函数叫function()}，让编译器知道这个函数的存在；  
**定义**：一般在源文件里，具体就是函数的实现过程写明函数体。


[https://linhongbo.com/posts/difference-between-definition-and-declaration/](https://linhongbo.com/posts/difference-between-definition-and-declaration/)

## 69.说一下你理解的 ifdef endif 代表着什么？
1.  一般情况下，源程序中所有的行都参加编译。但是有时希**望对其中一部分内容只在满足一定条件才进行编译**，也就是对一部分内容指定编译的条件，这就是“**条件编译**”。有时，希望当满足某条件时对一 组语句进行编译，而当条件不满足时则编译另一组语句。

2) 条件编译命令最常见的形式为：

	\#ifdef 标识符
		程序段1
	\#else
		程序段2
	\#endif

它的作用是：**当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程 序段2**。

3) 在一个大的软件工程里面，**可能会有多个文件同时包含一个头文件**，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。

在头文件中使用#define、#ifndef、#ifdef、#endif** 能避免头文件重定义**。

## 70.C++如何处理多个异常的？
- **C++ 中的异常情况**：   
**语法错误**（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正；  
**运行时错误**：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。
- **C++异常处理机制**：    
**异常处理基本思想**：执行一个函数的过程中发现异常，**可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题**。    
C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果 try 块中程序段发现了异常则抛出异常。

## 71.如何在不使用额外空间的情况下交换两个数？你有几种方法？
1)  算术

	x = x + y;
	y = x - y;
	
	x = x - y; 

2)  异或

	x = x^y;// 只能对int,char..
	y = x^y;
	x = x^y;
	x ^= y ^= x;

## 72.你知道 strcpy 和 memcpy 的区别是什么吗？
1. **复制的内容不同**。strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。
2. **复制的方法不同**。strcpy 不需要指定长度，它遇到被复制字符的串结束符"`\0`"才结束，所以容易溢出。memcpy 则是根据其第3个参数决定复制的长度。
3. **用途不同**。通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy。

[https://www.cnblogs.com/codemagiciant/p/17544881.html](https://www.cnblogs.com/codemagiciant/p/17544881.html)

> strlen函数返回的是在字符串中’\0’前面出现的字符的个数；  
> strcat追加拷贝，追加到目标空间后面，目标空间必须足够大，能容纳下源字符串的内容；  
> strcmp比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较；

## 73.程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？
参数的含义是程序在命令行下运行的时候，需要输入 argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，**所有的参数在指针`char *` 指向的内存中，数组的中元素的个数为 argc个，第一个参数为程序的名称**。

## 74.如果有一个空类，它会默认添加哪些函数？
	1)  Empty(); // 缺省构造函数//
	2)  Empty( const Empty& ); // 拷贝构造函数//
	3)  ~Empty(); // 析构函数//
	4)  Empty& operator=( const Empty& ); // 赋值运算符//

## 75.C++中标准库是什么？
1.C++ 标准库可以分为两部分： 
 
- **标准函数库**：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自C语言；  

- **面向对象类库**：这个库是类及其相关函数的集合；

	- 输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数;  
	- 标准的 C++  I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库


## 76.你知道 const char* 与 string 之间的关系是什么吗？
- string 是 C++ 标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用`const char*`给string类初始化；
- `c_str()` 函数可以将 `const string*` 类型 转化为 `const char*` 类型；

> c_str() 这个函数转换后返回的是一个临时指针，不能对其进行操作；
> 
所以因为这个数据是临时的，所以当有一个改变这些数据的成员函数被调用后，该数据就会改变失效；


## 77.如何设计一个计算仅单个子类的对象个数？
1. 为类设计一个 static 静态变量 count 作为计数器；
2. 类定义结束后初始化 count;
3. 在构造函数中对 count 进行+1;
4. 设计拷贝构造函数，在进行拷贝构造函数中进行 count +1，操作；
5. 设计赋值构造函数，在进行赋值函数中对 count+1 操作；
6. 在析构函数中对 count 进行-1；


## 78.成员初始化列表会在什么时候用到？它的调用过程是什么？
1.当初始化一个引用成员变量时；  
2.当初始化一个非静态的常量成员时；  
3.当调用一个基类的构造函数，而构造函数拥有一组参数时；  
4.当调用一个成员类的构造函数，而他拥有一组参数；  
5.成员类型是没有默认构造函数的类。

编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。<font color = blue>初始化列表中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</font>

## 79.在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？
对比值传递，引用传参的好处：

1. 在函数内部可以对此参数进行修改；
2. 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）

**用引用作为返回值最大的好处就是在内存中不产生被返回值的副本**。

但是有以下的限制：

1. 不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁；
2. 不能返回函数内部 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄露；
3. 可以返回类成员的引用，但是最好是 const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。

## 80.说一说 strcpy、sprintf 与 memcpy 这三个函数的不同之处？
1.操作对象不同

① strcpy 的两个操作对象均为字符串；  
② sprintf 的操作源对象可以是多种数据类型，目的操作对象是字符串；  
③ memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。

2.复制的方法不同

①strcpy 不需要指定长度，它遇到被复制字符的串结束符"`\0`"才结束，所以容易溢出。  
②sprintf 如果失败，则返回一个负数。对于写入buffer（它可以指代缓存、缓冲区等）的字符数是没有限制的，这就存在了 buffer 溢出的可能性。  
③ memcpy 则是根据其第3个参数决定复制的长度。

3.执行效率不同  

memcpy最高，strcpy次之，sprintf的效率最低； 

4.实现功能不同

① strcpy 主要实现字符串变量间的拷贝；  
② sprintf 主要实现其他数据类型格式到字符串的转化；  
③ memcpy主要是内存块间的拷贝。

## 81.你知道数组和指针的区别吗？
1.数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；**数组大小：sizeof(数组名)/sizeof(数组元素数据类型)**；

2.用运算符 sizeof 可以计算出数组的容量（字节数）。**sizeof(p), p 为指针得到的是一个指针变量的字节数，而不是 p 所指的内存容量**。

3.编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将**表达式中的数组元素引用转换为指针加偏移量的引用**。

4.在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是**传递过去是数组的首地址而不是整个数组**，能够提高效率；

5.在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过**数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的**。

## 82.如何禁止程序自动生成拷贝构造函数？
1. 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成 `private`，防止被调用。
2. 类的成员函数和 `friend` 函数还是可以调用 private 函数，如果这个 private 函数只声明不定义，则会产生一个连接错误；
3. 针对上述两种情况，我们可以定一个 base 类，**在 base 类中将拷贝构造函数和拷贝赋值函数设置成 private**，那么派生类中编译器将不会自动生成这两个函数，且由于 base 类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。【muduo 就是这样实现的】

## 83.你知道 Debug 和 Release 的区别是什么吗？
**Debug**：调试版本，包含调试信息，所以容量比 Release 大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug 模式下生成两个文件，除了`.exe`或`.dll`文件外，还有一个`.pdb`文件，该文件记录了代码中断点等调试信息 

**Release**：发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release 模式下生成一个文件`.exe`或`.dll`文件

实际上，Debug 和 Release 并**没有本质的界限**，**他们只是一组编译选项的集合，编译器只是按照预定的选项行动**。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。

[https://www.cnblogs.com/taiyonghai/p/6126074.html](https://www.cnblogs.com/taiyonghai/p/6126074.html)

## 84. main 函数的返回值有什么值得考究之处吗? 
**main 函数的返回值用于说明程序的退出状态**。如果返回 0，则代表程序正常退出。返回其它数字的含义则由系统决定。通常，返回非零代表程序异常退出。

既然 main 函数只有一种返回值类型，那么是不是可以不写？规定：不明确标明返回值的，默认返回值为 int，也就是说 main()等同于int main()，而不是等同于void main()。

main 也是个函数，它运行了自然也是有结果的，这个结果通常是告诉操作系统，自身是正常运行结束了（值为0），还是发生了异常（这个值就有很多了）。告诉操作系统值是多少，目的是后台或者SHELL可以从操作系统中取得这个程序的运行结果，从而可以进行进一步操作。

其实 **main 函数本身是可以调用这个返回值**的，这个的作用就在于多线程的编程中，另外一个线程等待这个程序执行完毕，等待的就是这个MAIN函数的执行结果。


[http://t.csdnimg.cn/pwJvm](http://t.csdnimg.cn/pwJvm)

## 85.成员函数里 memset(this,0,sizeof(*this)) 会发生什么？
- 类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。

以下场景不可以使用：

- 类含有虚函数表：这么做**会破坏虚函数表**，后续对虚函数的调用都将出现异常【this指向的是一个对象，该对象中有一个指向虚表的指针，那么此操作会将虚表指针的值置为0，则无法索引到虚函数表】；
- 如果成员的类对象变量中如果有用到new的方法，例如 std::string内部 指针全部置空 ，这时确实会导致找不到开辟的内存的位置，会导致内存泄露，访问异常。因为**指针清零，但是指针指向的内存空间还没有释放**。

## 86.你知道回调函数吗？它的作用？
函数指针的调用，即是一个通过函数指针调用的函数；  
如果**把函数的指针（地址）作为参数传递给另一个函数**，当这个指针被用来调用其所指向的函数时，就说这是回调函数。

<font color=red>回到函数作用：“解耦”【因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件(如返回值为int)的被调用函数】，普通函数代替不了回调函数的这个特点。</font>

**使用回调函数，和普通函数调用区别：**  
1）在主入口程序中，把回调函数像参数一样传入库函数。这样一来，只要**改变传进库函数的参数，就可以实现不同的功能**，且不需要修改库函数的实现，变的很灵活，这就是解耦。  
2）主函数和回调函数是在同一层的，而库函数在另外一层。如果库函数对我们不可见，我们修改不了库函数的实现，也就是说不能通过修改库函数让库函数调用普通函数那样实现，那我们就只能通过传入不同的回调函数了。

**回调函数其实就是函数指针的一种用法**【使用回调函数会有间接调用，因此，会有一些额外的传参与访存开销，对于MCU代码中对时间要求较高的代码要慎用】

**回调函数的缺点：**    
1）回调函数固然能解决一部分系统架构问题但是绝不能再系统内到处都是，如果你发现你的系统内到处都是回调函数，那么你一定要重构你的系统。  
2）回调函数本身是**一种破坏系统结构的设计思路**，回调函数会绝对的变化系统的运行轨迹，执行顺序，调用顺序。回调函数的出现会让读到你的代码的人非常的懵头转向。



[https://blog.csdn.net/llzhang_fly/article/details/104933969](https://blog.csdn.net/llzhang_fly/article/details/104933969)


## 87.什么是一致性哈希？
分布式存储（每个节点数据不同）使用哈希算法有一个很致命的问题，如果节点数量发生了变化了映射关系的数据，否则会出现查询不到数据的问题。也就是在对系统做扩容或者缩容时，必须迁移改变。

一致性哈希是一种哈希算法，就是在**移除或者增加一个结点时，能够尽可能小的改变**已存在 key 的映射关系。  
一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。（也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值）     
映射的结果值往顺时针的方向的找到第一个节点，就是存储该数据的节点。

<img src="https://cdn.xiaolincoding.com//mysql/other/83d7f363643353c92d252e34f1d4f687.png" alt="哈希环" width="300" height="300">

但是一致性哈希算法并不保证节点能够在哈希环上分布均匀，会有大量的请求集中在一个节点上。

<img src ="https://cdn.xiaolincoding.com//mysql/other/d528bae6fcec2357ba2eb8f324ad9fd5.png"  width="300" height="300">

一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题。

[https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93](https://www.xiaolincoding.com/os/8_network_system/hash.html#%E6%80%BB%E7%BB%93)

不再将真实节点映射到哈希环上，而是**将虚拟节点映射到哈希环上**，并**将虚拟节点映射到实际节点**，所以这里有「两层」映射关系。

## 88.C++从代码到可执行程序经历了什么?
<img src = "http://oss.interviewguide.cn/img/202205212343505.png" >

1、**预编译**  
主要处理源代码文件中的以“#”开头的预编译指令；  
2、**编译**  
把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。  
3、**汇编**  
将汇编代码转变成机器可以执行的指令(机器码文件)。  经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows 下)、xxx.obj(Linux下)。  
4、**链接**  
将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

链接分为静态链接和动态链接：

- 静态链接：
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，**链接器从库中复制**这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件；【在内存存在多个副本；需要重新进行编译链接；执行的时候运行速度快】
	- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
	- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

- 动态链接：
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，**在程序运行时才将它们链接在一起**形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件，在 Linux 系统中通常用 .so 后缀来表示，windows 为 DLL。【共享库；更新时只需要替换原来的目标文件；链接推迟到了程序运行】

[http://t.csdnimg.cn/ZouMD](http://t.csdnimg.cn/ZouMD)

## 89.友元函数在类内部声明还是内外？
友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。  
只有友元工厂才必须用到类内声明友元函数。

**如果友元函数是在类的内部声明的**，那么它可以直接访问类的私有成员和保护成员，即使这些成员在类的外部是不可见的。然而，如果友元函数在类的内部声明，它的**可见性只限于该类及其派生类，无法在其他地方直接使用**。

**如果友元函数是在类的外部声明的**，那么它仍然可以访问类的私有成员和保护成员，但是**需要使用类名来限定友元函数的可见性**。因为友元函数的声明和定义可以单独放在一个头文件中，而不需要与类的定义混合在一起。


[https://www.cnblogs.com/codemagiciant/p/17601831.html](https://www.cnblogs.com/codemagiciant/p/17601831.html)

## 90.友元函数和友元类的基本情况
友元是一种定义在类外部的普通函数，但它需要在类体内进行声明，为了与该类的成员函数加以区别，在声明时前面加以关键字friend。

友元不是成员函数，但是它**可以访问类中的私有成员**。  
友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。


- 友元函数可访问类的私有成员，但不是类的成员函数
- 友元函数不能用const修饰
- 友元函数可以在类定义的任何地方声明，不受类访问限定符限制
- 一个函数可以是多个类的友元函数
- 友元函数的调用与普通函数的调用和原理相同


友元除了友元函数以外，友元还可以是类——**友元类**，即一个类可以作另一个类的友元。当一个类作为另一个类的友元时，这就意味着这个类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的非公有成员。

- **友元关系是单向的，不具有交换性。**  
- **友元关系不能被继承，但对已有的方法来说访问权限不改变**。


## 91.介绍一下几种典型的锁
**读写锁**

- 多个读者可以同时进行读；
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）；
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）；

**互斥锁**：一次只能一个线程拥有互斥锁，其他线程只有等待

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以**互斥锁在加锁操作时涉及上下文的切换**。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁；

**条件变量**

互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而**条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件**。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。

**自旋锁**

**如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止**。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

## 92.为什么C++没有垃圾回收机制?
- 首先，实现一个**垃圾回收器会带来额外的空间和时间开销**。你需要开辟一定的空间保存指针的引用计数和对他们进行标记 `mark`。然后需要单独开辟一个线程在空闲的时候进行 free 操作。

- 垃圾回收会使得C++不适合进行很多底层的操作。


## 93.类的对象存储空间?
类所占内存的大小主要是由**成员变量（静态变量除外）决定的**，成员函数（虚函数除外）是不计算在内的。

类内部的成员变量：

- 普通的变量：是要占用内存的，但是要注意<font color = red>**对齐原则**</font>（这点和struct类型很相似）。
- static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。

类内部的成员函数：

- 普通函数：不占用内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。
- 虚函数：要占用4个以上字节(在32位系统分配指针大小为4字节)，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。类继承自多个基类的时候可能有多个虚函数表指针，可能会占据多个内存空间。

<font color = red>空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。</font>空类也会被实例化，所以编译器会给空类隐含的添加一个字节。

> 带有虚函数的 C++ 类大小不为1，因为**每一个对象会有一个 vptr 指向虚函数表，具体大小根据指针大小确定**。

`可见子类的大小 = 本身成员变量的大小 + （父类成员变量的的大小 + 虚函数表指针）* n` , n 表示继承的类的个数。



[https://blog.csdn.net/leigelaile1/article/details/81982103](https://blog.csdn.net/leigelaile1/article/details/81982103)


## 94.简要说明C++的内存分区

- **栈**： 存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
- **堆**： 动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
- **全局区/静态存储区**（.bss 段和 .data 段）： 存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
- **常量存储区**（.data 段）： 存放的是常量，不允许修改，程序运行结束自动释放。
- **代码区**（.text 段）： 存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

## 95.什么是内存池，如何实现？
内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用 new、malloc 等申请内存，这样做的缺点在于：**由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能**。

内存池则是**在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用**。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。

**内存池的工作原理**

1. 在初始化时，从操作系统申请一块连续的物理内存，称为内存池。
1. 将内存池按照固定大小分成多个内存块。
1. 将这些内存块用链表、栈或其他数据结构连接起来，形成一个内存块池。
1. 当需要分配内存时，从内存块池中获取一个内存块，并将其标记为已分配。
1. 当不需要使用内存块时，将其标记为未分配，放回到内存块池中。
1. 当内存块池中无可用内存块时，可以选择动态扩展内存池。

## 96.关于this指针你知道什么？全说出来？
1. 每个对象都有一个隐藏的 this 指针，但**不属于对象，是编译器添加的**；
2. `this` 只能在成员函数中使用【实际上，成员函数默认第一个参数为T *const this】。全局函数、静态函数都不能使用 `this`；
3. 由此可见，**this 在成员函数的开始前构造，在成员函数的结束后清除**。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的 `this` 参数传递进去。

## 97.this指针存放在何处？堆、栈、全局变量，还是其他？
this 指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。

## 98.this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？
大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。

在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。

## 99.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？
**this 指针只有在成员函数中才有定义**。因此，你获得一个对象后，也不能通过对象使用 this 指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。


[http://blog.chinaunix.net/uid-21411227-id-1826942.html](http://blog.chinaunix.net/uid-21411227-id-1826942.html)

## 100.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，**如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数**。

## 101.在成员函数中调用delete this会出现什么问题？对象还可以使用吗？
在类对象的内存空间中，**只有数据成员和虚函数表指针**，并不包含代码内容，类的成员函数单独放在代码段中。  
在调用成员函数时，隐含传递一个 this 指针，让成员函数知道当前是哪个对象在调用它。    
**当调用 delete this 时，类对象的内存空间被释放**。在 delete this 之后进行的其他任何函数调用，只要不涉及到 this 指针的内容，都能够正常运行。一旦涉及到this 指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。


## 102. C++11 有哪些新特性

[https://cloud.tencent.com/developer/article/1745592](https://cloud.tencent.com/developer/article/1745592)


## 103.auto、decltype和decltype(auto)的用法
编程时常常需要把表达式的值赋给变量，这就要求声明变量时清楚的知道表达式的类型。然而有些情况是**声明的变量的类型我们并不知道**，比如在模板编程时。  
为了解决这个问题，C++11引入了**auto类型说明符，用它来让编译器替我们去分析表达式所属的类型**。

decltype是C++11新增的关键字，主要用于提取变量和表达式的类型。  
decltype的语法形式为：`decltype(e)`，这里e是一个表达式，而`decltype(e)`是一个类型指示符。decltype的结果不是值，而是一个类型。**编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。  
**

`decltype(auto)`是C++14新增的类型指示符，可以**用来声明变量以及指示函数返回类型**。  
使用时，会将”=”号右边的表达式替换掉auto，再根据decltype的语法规则来确定类型

	int e = 4;
	const int* f = &e; // f是底层const
	decltype(auto) j = f;//j的类型是const int* 并且指向的是e

## 104. C++中NULL和nullptr区别
- NULL是一个宏定义，C++中通常将其定义为0，编译器一般优先把它当作一个整型常量(C标准下定义为(void*）0)；
- nullptr是一个编译期常量，其类型为nullptr_t。它**既不是整型类型，也不是指针类型**；
- 在模板推导中，nullptr被推导为nullptr_t类型，仍可隐式转为指针。但0或NULL则会被推导为整型类型；
- 要避免在整型和指针间进行函数重载。因为NULL会被匹配到整型形参版本的函数，而不是预期的指针版本。

[https://blog.csdn.net/qq_38410730/article/details/105183769](https://blog.csdn.net/qq_38410730/article/details/105183769)

## 105. 智能指针理解
[http://t.csdnimg.cn/et0ON](http://t.csdnimg.cn/et0ON)

动态内存管理经常会出现两种问题：
（1）一种是忘记释放内存，会造成内存泄漏；
（2）一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。

为了更加容易（更加安全）的使用动态内存，**引入了智能指针**的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。

`auto_ptr` 是c++11以前的最原始的智能指针，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用 delete 来释放内存。但是在c++11中已经被弃用（使用的话会被警告）了。

原因：

1. 复制或者赋值都会改变资源的所有权；
2. 在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值；
3. 不支持对象数组的内存管理；

`unique_ptr`：`unique_ptr` 和 `auto_ptr` 用法几乎一样，除了一些特殊

特性：

1. 基于排他所有权模式：**两个指针不能指向同一个资源**
1. 无法进行左值 `unique_ptr` 复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值；
1. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象；
1. 在容器中保存指针是安全的；


`shared_ptr`：:它所指向的资源具有共享性，即多个shared_ptr可以指向同一份资源，并在内部使用引用计数机制来实现这一点。可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，引用计数加 1，当智能指针析构时，引用计数减 1，如果计数为零，代表已经没有指针指向这块内存，那么就释放它。

<font color = "#FA1000">`shared_ptr` 的构造函数和拷贝构造函数做的事情，导致虽然都是指向同一个资源，但是**对于引用计数对象的管理方式**，这两个函数是不一样的，构造函数是**新分配引用计数对象**，拷贝构造函数只做引用**计数增减**。</font>

> 当新的 `shared_ptr` 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。

> 当任何 `shared_ptr` 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表示没有其他 `shared_ptr` 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。


最安全的分配和使用动态内存的方法就是调用一个名为 `make_shared` 的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`。


<font color = "#F100">可以说，当生命控制权没有彼此互相掌握时，才能正确解决循环引用问题，而弱引用的使用可以使生命控制权互相掌握的情况消失。</font>

我们在 `enable_shared_from_this<A>` 基类中继承一个成员变量 `_Wptr`，当定义第一个智能指针对象的时候： `shared_ptr< A > ptr1(new A())`，调用 `shared_ptr` 的普通构造函数，就会初始化 `A` 对象的成员变量 `_Wptr`，作为观察 `A` 对象资源的一个弱智能指针观察者。

`weak_ptr` :设计的目的是为配合 `shared_ptr` 而引入的一种智能指针来协助 `shared_ptr` 工作, 它只提供了对管理对象的一个访问手段，同时也可以实时动态地知道指向的对象是否存活。它只可以从一个 `shared_ptr` 或另一个 `weak_ptr` 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。 同时 `weak_ptr` 没有重载`*`和`->`，，所以并不能直接使用资源，但可以使用 lock 获得一个可用的 `shared_ptr` 对象。

`shared_from_this()` 函数，是直接返回了一个 `shared_ptr<_Ty>(_Wptr)`，该语法在 shared_ptr 中也有相应的构造函数，其主要作用就是**把一个弱智能指针提升为一个强智能指针**，可以在多线程环境中判断对象是否存活或者已经析构释放.

[C/C++｜智能指针的 shared\_ from \_ this 和enable\_ shared\_ from\_ this](http://t.csdnimg.cn/sNhIH)

## 106.智能指针出现循环引用怎么解决?
一般来讲，解除这种循环引用有下面有三种可行的方法(参考)：

1. 当只剩下最后一个引用的时候需要手动打破循环引用释放对象。
2. 当A的生存期超过B的生存期的时候，B改为使用一个普通指针指向A。
3. 使用弱引用的智能指针打破这种循环引用。
虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。我们一般使用第三种方法：弱引用的智能指针weak_ptr。

weak_ptr除了对所管理对象的基本访问功能（通过get()函数）外，还有两个常用的功能函数：   
`expired()` 用于检测所管理的对象是否已经释放；  
`lock()` 用于获取所管理的对象的强引用指针。不能直接通过 weak_ptr 来访问资源。那么**如何通过weak_ptr来间接访问资源呢？答案是：在需要访问资源的时候weak_ptr为你生成一个shared_ptr，shared_ptr能够保证在shared_ptr没有被释放之前，其所管理的资源是不会被释放的**。`创建shared_ptr的方法就是lock()方法。`

                        
[https://blog.csdn.net/daniel_ustc/article/details/23096229](https://blog.csdn.net/daniel_ustc/article/details/23096229)  
[http://t.csdnimg.cn/G5HAZ](http://t.csdnimg.cn/G5HAZ)

## 107.Lambda 表达式
类似匿名函数（需要函数体，不需要函数名），可以理解为简易版函数。  
**基本格式**： `[捕获方式] (参数) -> 返回值类型 {函数体}`（可以忽略返回类型，lambda自动推断出返回类型）。

`[ ]`：闭包形式(closure type)，即定义一个lambda表达式后，编译器会自动生成一个重载()运算符的匿名类。优势在于可以通过传值或引用的方式捕获其封装作用域内的变量（即捕获方式中存在的变量）

lambda 的性能优势：

1. 内联函数：
编译器自动将 lambda 表达式内联，这意味着代码直接插入到调用函数中。
可以减少函数调用的开销，并提高性能。

2. 避免命名函数的开销：
lambda 表达式没有名称，因此不必被声明和存储在符号表中，
可以减少开销，并提高性能。

3. 改善高速缓存局部性：
lambda 表达式可以在同一个函数中定义和使用，这意味着 lambda 使用的代码和数据
存储在与调用代码相同的高速缓存行中。
可以改善高速缓存局部性并降低高速缓存失效的成本。

4. 减小代码大小：
lambda 表达式通常比命名函数小，并不需要外部函数调用，
这可以减小编译代码的大小并提高性能。

5. 增加灵活性：
lambda 表达式可以用来将函数作为参数传递给其他函数，


## 108.什么是STL?
C++ STL从广义来讲包括了三类：算法，容器和迭代器。

- 算法包括排序，复制等常用算法，以及不同容器特定的算法。
- 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是 list，vector 等，关联式容器就是set，map等
- 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。

## 109.解释一下什么是trivial destructor
在C++中，当一个类的析构函数**不需要做任何额外的工作**时，我们称这个类的析构函数为 trivial destructor。也就是说，如果这个类不持有任何资源，比如堆内存、文件句柄等等，那么它的析构函数就是 trivial destructor。

当一个类的析构函数是 trivial destructor 时，**编译器会对其进行优化**，使得在该类对象被销毁时，不会调用析构函数。这种优化被称为trivial destructor优化，它可以提高程序的性能和效率。

需要注意的是，如果一个类的析构函数不是trivial destructor，那么在该类对象被销毁时，析构函数必须被调用。这是因为该类对象可能持有一些资源，需要在销毁时释放。如果析构函数没有被调用，这些资源可能会泄漏，导致程序出现严重的错误。


[https://www.nowcoder.com/discuss/541403936406691840](https://www.nowcoder.com/discuss/541403936406691840)

## 110.使用智能指针管理内存资源，RAII是怎么回事？
1)RAII全称是“Resource Acquisition is Initialization”，直译过来是“**资源获取即初始化**”，也就是说**在构造函数中申请分配资源，在析构函数中释放资源**。

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

2)**智能指针（std::shared_ptr和std::unique_ptr）**即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。

## 111.说一下C++左值引用和右值引用
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

所以当一个左值被当成右值使用时，实际使用的是它的内容（值）。**在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用**。比如取地址符` &`，就是对一个左值取地址，取出来的地址是个右值，因为右值只有内容，在内存中没有位置。而对一个地址解引用 `*p`，或者对一个数组取下标` arr[0]`，就获得了左值。


C++11 引入了 **右值引用 &&** 的概念，允许将右值绑定到一个引用上，并且可以修改其内容，这提供了更多的灵活性和效率。

	int i = 10;
	int& j = i;           // 正确：左值引用
	int& k = i * 1;       // 错误：左值引用不能绑定右值
	int&& m = i * 1;      // 正确：右值引用
	int&& n = i;          // 错误：右值引用不能绑定左值
	const int& p = i * 1; // 正确：const左值引用可以绑定右值

如果说变量是左值，那么问题来了，右值引用的变量也是变量，这个变量是左值么，比如这里的 m。

答案为左值，所以下面这个表达式是错误的：

	int&& q = m;          // 错误：右值引用不能绑定左值，即使这个左值是右值引用类型的变量
虽然直接把右值引用类型的变量绑定到变量上，但可以使用 move 来获取绑定到左值上的右值引用。

	int&& q = std::move(m);    // 正确：std::move可以将左值转换为右值


[https://segmentfault.com/a/1190000044307595](https://segmentfault.com/a/1190000044307595)


**左值引用**：传统的 C++ 中引用被称为左值引用；  
**右值引用**：C++11 中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，**右值虽然无法获取地址，但是右值引用是可以获取地址的**，该地址表示临时对象的存储位置；


### 112.STL中 hashtable 的实现？
STL中的 hashtable 使用的是**开链法**解决hash冲突问题；

hashtable中 的 bucket 所维护的 list 既不是 list 也不是 slist，而是其自己定义的由hashtable_node 数据结构组成的 linked-list，而 bucket 聚合体本身使用 vector 进行存储。**hashtable 的迭代器只提供前进操作，不提供后退操作**。

在hashtable设计bucket的数量上，其**内置了28个质数**[53, 97, 193,...,429496729]，在创建hashtable时，会**根据存入的元素个数选择大于等于元素个数的质数作为 hashtable 的容量**（vector的长度），其中**每个 bucket 所维护的 linked-list 长度也等于hashtable的容量**。如果插入 hashtable 的元素个数超过了 bucket 的容量，就要进行重建 table 操作，即找出下一个质数，创建新的 buckets vector，重新计算元素在新 hashtable 的位置。

<img src = "http://oss.interviewguide.cn/img/202205220035271.png"  weight="300" height = "200">

[https://github.com/Light-City/CPlusPlusThings/blob/master/src_analysis/stl/hashtable.md](https://github.com/Light-City/CPlusPlusThings/blob/master/src_analysis/stl/hashtable.md)

## 113.c++  traits 技法理解
**traits，又被叫做特性萃取技术**，说得简单点就是**提取“被传进的对象”对应的返回类型，让同一个接口实现对应的功能**。因为STL的算法和容器是分离的，两者通过迭代器链接。算法的实现并不知道自己被传进来什么。萃取器相当于在接口和实现之间加一层封装，来隐藏一些细节并协助调用合适的方法，这需要一些技巧（例如，偏特化）。

traits 技法利用“内嵌型别”的编程技巧与编译器的 template 参数推导功能，增强C++ 未能提供的关于型别认证方面的能力。常用的有 `iterator_traits` 和 `type_traits` 。

C++ 中的模板特性（Traits）是一种常见的技术，用于**在编译时提取或操作类型信息**。Traits类提供了一种灵活且可扩展的方法，用于实现类型特定的行为和元编程。Traits的主要作用包括：

- **类型信息提取**：提取类型的某些属性或信息，例如类型的基本类型、是否为指针、是否为某种类型的实例等。
- **类型操作**：定义某些类型转换或操作，例如从一种类型转换为另一种类型。
- **条件编译**：根据类型信息进行条件编译，以实现不同类型的特定行为。

[https://www.cnblogs.com/codemagiciant/p/17601959.html](https://www.cnblogs.com/codemagiciant/p/17601959.html)


## 114.STL的两级空间配置器

**为什么有适配器？**  
（1）小块内存带来的内存碎片问题；  
（2）小块内存频繁申请释放带来的性能问题；   
（3）小块空间太多会造成空间的浪费；

**STL里面的空间配置主要分为两级**：一级空间配置器(`__malloc_alloc_template`)和二级空间配置器(`__default_alloc_template`)。  
（1）在STL中默认**如果要分配的内存大于128个字节的话就是大块内存，调用一级空间配置器直接向系统申请**；  
直接采用malloc和free进行内存的申请和释放


（2）**如果小于等于128个字节的话则认为是小内存，则就去内存池中申请**。  
> `default_alloc_template` 维护着一个内存池，内存池每次分配内存都会分配一大块内存，并维护 free_list，free_list 是一个指针数组，free_list有16项，每一项都维护一个对应大小的内存块链表，大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128；
> 
> 从 `free_list` 找到管理指定内存块大小的链表，如果该链表上没有内存块，那么就重新填充（从缓存块中获取内存，填充free_list对应的链表），之后将分配得到的内存块从链表中删除，再返回此内存块。

## 115.STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

 C++ vector 容器利用类似于数组的连续内存空间来存储其元素，当利用其 `erase` 函数删除相应的元素之后，该容器会重新分配所有剩下的元素，同时 **erase 函数会返回指向已经删除的那些元素的下一个元素的迭代器**，**以前所有指向被删除元素以后的元素的迭代器会失效**。

size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。

可以使用`reserve(n)`预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。

整体的一个**扩容流程**为：  
申请新的内存空间（空间大小为原空间的两倍或一点五倍）—> 把原空间的元素拷贝到新的空间里 —> 释放原空间 —> 数组指针指向新空间。

使用k=2增长因子的问题在于，**每次扩展的新尺寸必然刚好大于之前分配的总和**，也就是说，之前分配的内存空间不可能被使用。

## 116.Vector如何释放空间?
1. **清空vector** ：用vector的clear()方法可以清空vector中的元素，但是并不会释放vector所占用的内存空间。这意味着，如果之后还需要往vector中添加元素，vector会尝试使用之前已经分配的内存空间，而不是重新分配内存空间。【如果需要释放vector占用的内存空间，<font color=blue>可以**在调用clear()方法之后再调用vector的shrink_to_fit()方法，该方法会将vector的容量减小到与其大小相等，从而释放多余的内存空间**。</font>】
2. **重新分配vector大小**：
可以使用resize()方法重新分配vector的大小，从而释放多余的内存空间。
3. **使用swap()方法**：
可以使用swap()方法交换两个vector的内容，从而释放一个vector占用的内存空间。
4. **使用移动语义**：
C++11引入了移动语义，可以通过将一个 vector **移动** 到另一个 vector 来释放内存空间。具体方法是，使用`std::move()`函数将一个vector移动到另一个vector中，然后将原vector置为空。


[https://www.cnblogs.com/ybqjymy/p/18054639](https://www.cnblogs.com/ybqjymy/p/18054639)

## 117.容器内部删除一个元素？
- **关联容器的删除**  
对于关联容器(如map, set,multimap,multiset)，**删除当前的iterator，仅仅会使当前的iterator失效**，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
- **顺序容器的删除**  
顺序容器就是数组式容器，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。所以不能使用erase(iter++)的方式，还好erase方法可以返回下一个有效的iterator。
- **链表式容器的删除**  
对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++)。

## 118.STL迭代器如何实现？
1. 迭代器是一种抽象的设计理念，**通过迭代器可以在不了解容器内部原理的情况下遍历容器**，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。
2.  迭代器的作用就是**提供一个遍历容器内部所有元素的接口**，**因此迭代器内部必须保存一个与容器相关联的指针**，然后**重载各种运算操作来遍历**，其中最重要的是*运算符与->运算符，以及++、--等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。
3. 最常用的迭代器的相应型别有五种:value type、difference type、pointer、reference、iterator catagoly;

## 119.map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器?为什么使用红黑树？
- 他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除；
- 在这里定义了一个模版参数，如果它是 key 那么它就是 set，如果它是map，那么它就是 map；底层是红黑树，实现 map 的红黑树的节点数据类型是key+value，而实现 set 的节点数据类型是value
- 因为 map 和 set 要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。


> 红黑树和AVL树都是高效的平衡二叉树，复杂度都一样。**红黑树不追求绝对平衡，其只需保证最长路径不超过最短路径的2倍**，相对而言，**降低了插入和旋转的次数**，所以在经常进行增删的结构中性能比AVL树（当需要大量增删的时候，AVL树旋转次数太多，效率并不高）更优，而且红黑树实现比较简单，所以实际运用中红黑树更多。

## 120.如何在共享内存上使用STL标准库？
1. 一个最笨拙的办法是**在堆上构造STL容器，然后把容器复制到共享内存**，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。
2. 进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。
3. 进程A先在共享内存**某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里**。进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。

## 121.map插入方式有哪几种？
1. 用insert函数插入pair数据

    	mapStudent.insert(pair<int, string>(1, "student_one")); 

2. 用insert函数插入value_type数据

    	mapStudent.insert(map<int, string>::value_type (1, "student_one"));

3. 在insert函数中使用make_pair()函数

    	mapStudent.insert(make_pair(1, "student_one")); 

4. 用数组方式插入数据

    	mapStudent[1] = "student_one"; 

## 122.STL 中 unordered_map(hash_map) 和 map 的区别，hash_map 如何解决冲突以及扩容？
1、**需要引入的头文件不同**  
map: #include < map >  
unordered_map: #include < unordered_map >  

2、内部实现机理不同   
 map内部实现了一个红黑树，具有 **自动排序** 的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树存储的，使用 **中序遍历** 可将键值按照从小到大遍历出来。  
unordered_map内部实现了一个 **哈希表**（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。  

3、使用时 map 的 key 需要定义`operator<`。而unordered_map需要定义`hash_value`函数并且重载`operator=`=    
std::map 是一个 **排序的关联容器**，需要对键值进行比较，以确定元素的存储位置。默认情况下，std::map使用`operator<`来比较键；  
std::unordered_map是一个基于哈希的关联容器，它使用哈希函数来确定元素的存储位置，同时也需要一个比较函数来处理哈希冲突。默认情况下，std::unordered_map使用`std::hash`作为哈希函数，`operator==`作为比较函数。


**hash_map如何解决冲突？**

- 开放地址法：线性探测再散列、平方探测再散列；
- 拉链法：如果发生冲突，就继续往前一个元素上链接；
- 再哈希：如果发生冲突，就用另一个方法计算hashcode，两次结果值不一样就不会发生hash冲突；
- 建立公共溢出区：将哈希表分为基本表和溢出表两部分，与基本表发生冲突的元素，一律填入溢出表。


[https://blog.csdn.net/qq_43434328/article/details/115876864](https://blog.csdn.net/qq_43434328/article/details/115876864)



**hash_map如何扩容？**

哈希表（如std::unordered_map）的扩容是一个重要的过程，在 **装载因子（即哈希表中当前元素数量与哈希表大小的比值）** 达到或超过某个阈值（例如0.75）时发生。装载因子过高会增加哈希冲突的可能性，从而降低哈希表的性能。

1、**分配新内存**：首先，哈希表会分配一个新的、更大的内存块。新哈希表的大小通常是原来的两倍，但具体的扩展策略可能因具体的哈希表实现和特定的应用需求而不同。

2、**元素重新哈希**：然后，哈希表会遍历原来的所有元素，并使用哈希函数重新计算每个元素的哈希值。由于哈希表的大小已经改变，这通常会导致元素的哈希值也随之改变。

3、**元素迁移**：接着，哈希表会根据每个元素新的哈希值，将元素移动到新哈希表的相应位置。

4、**释放旧内存**：最后，一旦所有的元素都被成功地迁移到新的哈希表，就可以释放旧的哈希表占用的内存。

哈希表的扩容操作需要对所有元素进行重新哈希和迁移，因此时间复杂度为`O(n)`，其中`n`是哈希表中的元素数量。


## 123.vector越界访问下标，map越界访问下标？
- 在C++中，如果你 **使用operator[]来访问std::vector的元素，当下标越界时，编译器不会抛出任何错误或异常** ，而且它通常会**返回一个未定义的值**，这可能导致程序行为异常或崩溃。这种情况下，错误可能很难被检测到，因为程序可能会在某些情况下正常运行，但在其他情况下出现错误。  
【为了避免这种情况，C++提供了`std::vector::at()`成员函数，这个函数在访问超出std::vector范围的索引时 **会抛出std::out_of_range异常**。】


- 在C++的std::map中，使用operator[]**访问一个不存在的键会创建一个具有该键和默认值（通常为0或等效初始化值）的新元素**。  
【如果不希望在键不存在时创建新元素，你应该使用`std::map::find()`。（用 key 执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器）】

## 124.STL中list与queue之间的区别？
1. **容器类型**：std::list 是一个**双向链表**，而 std::queue 是一个队列，可以使用多种实现方式（如顺序容器、优先队列等）。
1. **插入和删除元素**：在 std::list 中，可以在任何位置插入和删除元素，而在 std::queue 中，只能在队尾插入元素，从队头删除元素。
1. **访问元素**：在 std::list 中，可以随机访问元素，而在 std::queue 中，只能顺序访问元素。
1. **存储方式**：std::list 采用链表存储元素，而 std::queue 采用顺序容器或优先队列等实现方式存储元素。
1. **适用场景**：std::list 适用于需要在任意位置进行插入和删除操作的场景，而 std::queue 适用于进行先进先出操作的场景。


## 125.常见容器性质总结？
C++ STL（Standard Template Library）提供了多种容器，用于存储和操作各种类型的数据。以下是一些常见容器的特性总结：

1.std::vector：动态数组，能高效地在末尾进行插入和删除操作，能直接访问任何元素。但在中间位置进行插入或删除操作则需要移动元素，效率较低。此外，当插入的元素超过当前分配的空间时，会重新分配内存，可能导致大规模元素移动。底层数据结构为数组

2.std::deque：双端队列，支持高效的头部和尾部插入和删除操作，并能直接访问任何元素。与std::vector相比，std::deque不保证元素在内存中的连续存储，因此当插入的元素超过当前分配的空间时，不需要移动其他元素。

3.std::queue：基于其它容器（如std::deque）实现的队列，支持两端的插入和删除操作。

4.std::priority_queue：基于其它容器（如std::vector）实现的优先队列，堆（heap）为处理规则来管理底层容器实现，元素按优先级排序。

5.std::list：底层数据结构为双向链表，能在任何位置高效地进行插入和删除操作。但不支持直接访问元素，只能通过迭代器进行访问。

6.std::forward_list：单向链表，只能从头部开始遍历，并只支持头部和后面的高效插入和删除操作。

7.std::array：固定大小的数组，提供与std::vector类似的接口，但其大小在编译时确定，无法动态改变。

8.std::set：底层数据结构为红黑树实现的有序集合，元素按排序顺序存储，每个元素只能出现一次。插入和查找操作的复杂度为对数级别。

9.std::multiset：与std::set类似，底层数据结构为红黑树，有序，允许元素重复。

10.std::map：底层数据结构为红黑树实现的有序映射表，存储键值对，键是唯一的，插入和查找操作的复杂度为对数级别。

11.std::unordered_map：基于哈希表实现的无序映射表，存储键值对，键是唯一的。在理想情况下，插入和查找操作的复杂度为常数级别。

12.std::multimap：与std::map类似，但允许键重复。

13.std::unordered_multimap：与std::unordered_map类似，但允许键重复。

14.std::unordered_set：基于哈希表实现的无序集合，每个元素只能出现一次。在理想情况下，插入和查找操作的复杂度为常数级别。

15.std::unordered_multiset：与std::unordered_set类似，但允许元素重复。

16.std::stack：基于其它容器（如std::deque）实现的栈，只支持顶部的插入和删除操作。


## 126.