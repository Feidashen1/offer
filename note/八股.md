# C++

----------

## 1.C++ 在 main() 函数执行前，后执行了哪些操作?
main 函数执行之前，主要就是初始化系统相关资源：

1. 设置栈指针：栈分配相关的位置，用来放一些局部变量和其他数据；
2. 初始化 static 静态和 global 全局变量，即 data 段的内容：**把全局和静态变量初始化**；
3. 将未初始化部分的全局变量赋初值：数值型 short，int，long 等为0，bool 为FALSE，指针为NULL，等等，即 .bss 段的内容：**将未设置初值的全局变量赋初值**；
4. 全局对象初始化，在main之前调用构造函数；
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。

在执行完 main 函数后：执行全局的析构函数，要销毁堆内存，关闭标准输入，输出，错误流。

## 2. 结构体内存对齐问题
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐(若有double成员，按8字节对齐)

**内存对齐：** 一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。

**内存对齐的原则：**

- 对于结构体的各个成员，<font color="#F100">除了第一个成员的偏移量为 0 外，其余成员的偏移量是 **其实际长度** 的整数倍，如果不是，则在前一个成员后面补充字节。</font>
- 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，<font color="#F100">**保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍**。</font>
- 如程序中有  `#pragma pack(n)` 预编译指令，则所有成员对齐以 n 字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。

[https://www.cnblogs.com/hyacinthLJP/p/16041690.html](https://www.cnblogs.com/hyacinthLJP/p/16041690.html)

- C++ `alignas` 用来**指定**对象的对齐字节数。效果和__attribute__((aligned(n)))一样，对齐值必须是 2 的幂，`alignas` 指定的对齐要求不能低于类型的自然对齐要求。；
- C++ `alignof` 用来**查看**对象的对齐字节数。用法类似于sizeof。

[http://t.csdnimg.cn/P5cZl](http://t.csdnimg.cn/P5cZl)

## 3. 指针和引用的区别
C++ 指针和引用的区别在于：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

- 指针是存储变量地址的变量；引用是变量的别名；
- 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错；
- 指针变量定义时可以初始化为 NULL；引用不能初始化为 NULL，不然报错；
- const 修饰指针变量，const 放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const 放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const 修饰引用，const 放在&之前，不能修改引用所表示的变量的值；const 放在 & 之后，const 的作用被忽略，可以修改引用所表示的变量的值。
- 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名。
- sizeof 运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 指针可以有多级，引用只有一级。
- 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。


> 指针的大小并不是固定的，它取决于运行程序的计算机架构。 在 32 位系统中，一个指针通常占用 4 个字节（32 bits / 8 bits per byte = 4 bytes）。 而在 64 位系统中，一个指针则占用 8 个字节（64 bits / 8 bits per byte = 8 bytes）。

## 4.在传递函数参数时，什么时候使用引用，什么时候使用指针，什么时候按值传递呢？
对于使用传递的值而不做修改的函数：

- 如果数据量很小，如内置数据类型或小型结构，则按值传递；
- 如果数据对象是数组，则使用指针，并将指针申明为指向 `const` 的指针(如`void fun(const int * arr, int length)`)；
- 如果数据对象是较大的结构，则使用 `const` 指针或 `const` 引用；
- 如果数据对象是类对象，则使用 `const` 引用。传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用引用，如`int* randomArr(int& length)`，别人看到这个声明就知道此函数内部会修改 `length` 的值；
- 如果数据对象是数组，则只能使用指针；
- 如果数据对象是结构体，则使用引用或指针；
- 如果数据对象是类对象，则使用引用；

总结：

- <font color="#A100">需要**返回函数内局部变量的内存的时候用指针**。使用指针传递参数需要先开辟内存，用完要释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
- 对栈空间大小比较敏感的场景（比如使用递归）要使用引用。**使用引用传递的时候不需要创建临时变量**，开销会更小。
- 类对象作为参数传递的时候使用引用，这是cpp类对象传递的标准方式。</font>


## 5. 堆和栈的区别
1. **申请方式不同**：
栈由系统自动分配；
堆是自己申请和释放的。
2. **申请大小限制不同**：
栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定（可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改）；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。【栈空间默认是4M，堆区一般是 1G - 4G】
3. **申请效率不同**：
栈由系统分配，速度快，不会有碎片；
堆由程序员分配，速度慢，且会有碎片。
4. **使用方法不同**：堆一般是底层用` malloc `通过` brk() `系统调用从堆分配内存；栈一般就是直接定义，就是分配，简单的 `esp, ebp` 指针的移动。
5. **存放内容不同**：堆一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排；栈在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的 C 编译器中，**参数是由右往左入栈（占位符确定参数个数）**，然后是函数中的局部变量。
【[http://t.csdnimg.cn/b0Tcu](http://t.csdnimg.cn/b0Tcu)】
6. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了**栈的效率比较高**。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
7. 堆地址向上生长（低到高），栈地址向下生长（高到低），因为计算机总是先从低地址开始读，所以，栈先进后出，堆先进先出。


[http://t.csdnimg.cn/sV3N5](http://t.csdnimg.cn/sV3N5)

## 6.区别指针类型
	int *p[10]
	int (*p)[10]
	int *p(int)
	int (*p)(int)

1. `int *p[10]`表示指针数组，强调数组概念，是一数组变量，数组大小为 10，数组内每个元素都是指向 `int` 类型的指针变量（一个有十个指针的数组）。
1. `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 `int` 类型的数组，这个数组大小是10（一个指向有十个整型数据数组的指针）。
1. `int *p(int)`是函数声明，函数名是 `p`，参数是 `int` 类型的，返回值是`int *`类型的。
1. `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有 `int` 类型参数，并且返回值是 `int` 类型的。

**指针函数与函数指针：**

- **指针函数**：本质是一个函数，不过它的返回值是一个指针。【`ret *func(args, ...);`--`func` 是一个函数，`args` 是形参列表，`ret *` 作为一个整体，是 `func` 函数的返回值，是一个指针的形式。】
- **函数指针**：本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。【`ret (*p)(args, ...);` —`ret` 为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args` 为形参列表。其中`p`被称为函数指针变量 】


[http://t.csdnimg.cn/ItQSC](http://t.csdnimg.cn/ItQSC)


## 7.new/delete 与 malloc/free 的异同
- 相同点：都可用于内存的动态申请和释放；
- 不同点：
	- 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数；
	- new 自动计算要分配的空间大小，malloc 需要手动计算；
	- new 是类型安全的，malloc不是。
	- new 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为`operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用；
	- 后者需要库文件支持，前者不用；
	- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象。
	- malloc 和 free 返回的是 void 类型指针(必须进行类型转换)，new 和 delete 返回的是具体类型指针。

**new 的实现过程**：首先调用名为 `operator new` 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。

**delete 的实现过程**：对指针指向的对象运行适当的析构函数，然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。

## 8.malloc/free和new/delete释放后的内存系统会马上回收吗？
用户 `free` 掉的内存并不是都会马上归还给系统，`ptmalloc` 会统一管理 `heap` 和 `mmap` 映射区域中的空闲的 `chunk`，当用户进行下一次分配请求时，`ptmalloc` 会首先试图在空闲的 `chunk` 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。

`ptmalloc` 将相似大小的 `chunk` 用双向链表链接起来，这样的一个链表被称为一个 bin。`ptmalloc` 一共维护了 128 个 bin，并使用一个数组来存储这些 bin。

内存管理一般会有一个`free block list`，`free` 掉的东西就放在这里来，这里会尝试合并这些散乱的 `block`，而 `malloc` 首先找的也是` free block list`，而非从OS申请新的内存。【碎片问题：页大小固定，避免小内存一直分配，占据不同的页】

[http://t.csdnimg.cn/tjySr](http://t.csdnimg.cn/tjySr)


## 9.宏定义和函数有何区别？
- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于**直接插入**了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；
- 宏定义属于在结构中插入代码，**没有返回值**；函数调用具有返回值；
- 宏定义**参数没有类型**，不进行类型检查；函数参数具有类型，需要检查类型；
- 宏定义不要在最后加分号。

## 10.宏定义 和 typedef 区别?
- 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名；
- 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分；
- 宏不检查类型；typedef会检查数据类型；
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束；

注意对指针的操作，`typedef char*p_char`和`#define p_char char *`区别巨大：

	typedef (int*)  pINT;
	#define pINT2 int*

效果相同？实则不同！实践中见差别：`pINT a,b;`的效果同`int *a; int *b;`表示定义了两个整型指针变量；而`pINT2 a,b;`的效果同`int *a, b;`表示定义了一个整型指针变量 a 和整型变量 b。


## 11.变量声明和定义区别?
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其**分配存储空间**。
- 相同变量可以在**多处声明**(外部变量 `extern`)，但只能在**一处定义**。


## 12.strlen 和 sizeof 区别?
- `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数；
- `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是`\0'`的字符串；
- 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。

## 13.常量指针和指针常量区别?
- **指针常量**：是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的`int const `和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`；【**不能够通过指针修改内存数据**。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象】
- **常量指针**：是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值(也就是存放在指针中的地址)就不能在改变了，即不能中途改变指向，如`int *const p`。【**指针所指向的位置不能改变**，即指针本身是一个常量，但是指针所指向的内容可以改变。】

<font color="#F100">【以*为中间划一条线，看const修饰谁就谁就是常量。】</font>

[http://t.csdnimg.cn/q3F0U](http://t.csdnimg.cn/q3F0U)


## 14.C 语言和 C++ 的区别

1. **过程**：*C 编程语言不支持面向对象编程。因此，它不允许多态性、继承等。作为一种面向对象的语言，C++ 支持多态性和继承。*
2. **安全性**：*由于 C 语言不允许封装，数据变得可访问，其他实体可以破坏它。然而，C++ 支持封装，可以保护数据结构并根据需要使用它。*
3. **方法**：*C 编程语言鼓励自顶向下的方法，首先定义一个通用问题，然后将其分解为较小的任务。另一方面，C++ 鼓励自底向上的方法。这涉及首先识别和定义类，然后使用它们执行最初的任务。*
4. **输入/输出函数**：在 C 中，I/O 操作主要通过 C 标准库的标准 I/O 函数进行处理，如 printf() 和 scanf()。这些函数提供基本的格式化和读取功能，但缺少 C++ 中的一些高级功能；另一方面，C++ 通过使用 iostream 库中的对象扩展了 I/O 功能，这些对象称为**标准 I/O 流**。cout 流允许进行简单而灵活的输出操作，而 cin 流提供了增强的输入功能。C++ 流支持运算符重载，可方便地输出复杂数据类型并启用自定义格式选项。
5. **重载和覆盖**：方法覆盖允许子类重新定义从其祖先继承的函数。重载允许同一个函数有多个版本，每个版本具有唯一的参数。C 不支持这两者，但 C++ 支持。
6. **内存分配**：*C 编程依赖于两个关键函数——`calloc()`和`malloc()`——用于内存分配。相应的 free() 函数用于内存释放。C++使用new运算符进行动态内存分配，使用delete运算符进行释放。*
7. **编译**：C 和 C++ 的软件开发始于编写源代码。C文件的源代码具有`.c`扩展名，而 C++ 使用扩展名如`.cpp`或`.cxx`。这些源代码文件包含程序的指令和逻辑。


8. **变量**：通常，C编程语言使用两种类型的值：字面值和变量。C使用四种基本的变量类型：int、float、char和double。C++的主要变量类型包括bool、void和wchar_t。

9. **特点**：C编程语言是一种过程式、快速和高效的语言，具有模块化和丰富的内置运算符。与C不同，C++是一种过程式语言，具有OOP。此外，它是机器无关的、简单的和区分大小写的。
10. 在C++中，除了值和指针之外，**新增了引用**。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。

11. C++中的`try/catch/throw`异常处理机制取代了标准C中的`setjmp()`和`longjmp()`函数。

C编程语言是一种中级语言，而C++是一种高级语言。



[http://t.csdnimg.cn/X7tM2](http://t.csdnimg.cn/X7tM2)


## 15.C++中 struct 和 class 的区别？

