# C++

----------

## 1.C++ 在 main() 函数执行前，后执行了哪些操作?
main 函数执行之前，主要就是初始化系统相关资源：

1. 设置栈指针：栈分配相关的位置，用来放一些局部变量和其他数据；
2. 
3. 
4. 
5.  static 静态和 global 全局变量，即 data 段的内容：**把全局和静态变量初始化**；
3. 将未初始化部分的全局变量赋初值：数值型 short，int，long 等为0，bool 为FALSE，指针为NULL，等等，即 .bss 段的内容：**将未设置初值的全局变量赋初值**；
4. 全局对象初始化，在main之前调用构造函数；
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。

在执行完 main 函数后：执行全局的析构函数，要销毁堆内存，关闭标准输入，输出，错误流。

## 2. 结构体内存对齐问题
- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐(若有double成员，按8字节对齐)

**内存对齐：** 一种提高内存访问速度的策略，CPU 在访问未对齐的内存可能需要经过两次的内存访问，而经过内存对齐一次就可以了。

**内存对齐的原则：**

- 对于结构体的各个成员，<font color="#F100">除了第一个成员的偏移量为 0 外，其余成员的偏移量是 **其实际长度** 的整数倍，如果不是，则在前一个成员后面补充字节。</font>
- 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，<font color="#F100">**保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍**。</font>
- 如程序中有  `#pragma pack(n)` 预编译指令，则所有成员对齐以 n 字节 为准（即偏移量是n的整数倍），不再考虑当前类型以及最大结构体内类型。

[https://www.cnblogs.com/hyacinthLJP/p/16041690.html](https://www.cnblogs.com/hyacinthLJP/p/16041690.html)

- C++ `alignas` 用来**指定**对象的对齐字节数。效果和__attribute__((aligned(n)))一样，对齐值必须是 2 的幂，`alignas` 指定的对齐要求不能低于类型的自然对齐要求。；
- C++ `alignof` 用来**查看**对象的对齐字节数。用法类似于sizeof。

[http://t.csdnimg.cn/P5cZl](http://t.csdnimg.cn/P5cZl)

## 3. 指针和引用的区别
C++ 指针和引用的区别在于：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元； 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

- 指针是存储变量地址的变量；引用是变量的别名；
- 指针变量定义时不必初始化；引用定义时必须初始化，不然会报错；
- 指针变量定义时可以初始化为 NULL；引用不能初始化为 NULL，不然报错；
- const 修饰指针变量，const 放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const 放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const 修饰引用，const 放在&之前，不能修改引用所表示的变量的值；const 放在 & 之后，const 的作用被忽略，可以修改引用所表示的变量的值。
- 非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名。
- sizeof 运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 指针可以有多级，引用只有一级。
- 指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。


> 指针的大小并不是固定的，它取决于运行程序的计算机架构。 在 32 位系统中，一个指针通常占用 4 个字节（32 bits / 8 bits per byte = 4 bytes）。 而在 64 位系统中，一个指针则占用 8 个字节（64 bits / 8 bits per byte = 8 bytes）。

## 4.在传递函数参数时，什么时候使用引用，什么时候使用指针，什么时候按值传递呢？
对于使用传递的值而不做修改的函数：

- 如果数据量很小，如内置数据类型或小型结构，则按值传递；
- 如果数据对象是数组，则使用指针，并将指针申明为指向 `const` 的指针(如`void fun(const int * arr, int length)`)；
- 如果数据对象是较大的结构，则使用 `const` 指针或 `const` 引用；
- 如果数据对象是类对象，则使用 `const` 引用。传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用引用，如`int* randomArr(int& length)`，别人看到这个声明就知道此函数内部会修改 `length` 的值；
- 如果数据对象是数组，则只能使用指针；
- 如果数据对象是结构体，则使用引用或指针；
- 如果数据对象是类对象，则使用引用；

总结：

- <font color="#A100">需要**返回函数内局部变量的内存的时候用指针**。使用指针传递参数需要先开辟内存，用完要释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。
- 对栈空间大小比较敏感的场景（比如使用递归）要使用引用。**使用引用传递的时候不需要创建临时变量**，开销会更小。
- 类对象作为参数传递的时候使用引用，这是cpp类对象传递的标准方式。</font>


## 5. 堆和栈的区别
1. **申请方式不同**：
栈由系统自动分配；
堆是自己申请和释放的。
2. **申请大小限制不同**：
栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定（可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改）；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。【栈空间默认是4M，堆区一般是 1G - 4G】
3. **申请效率不同**：
栈由系统分配，速度快，不会有碎片；
堆由程序员分配，速度慢，且会有碎片。
4. **使用方法不同**：堆一般是底层用` malloc `通过` brk() `系统调用从堆分配内存；栈一般就是直接定义，就是分配，简单的 `esp, ebp` 指针的移动。
5. **存放内容不同**：堆一般是在堆的头部用一个字节存放堆的大小，具体内容由程序员安排；栈在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的 C 编译器中，**参数是由右往左入栈（占位符确定参数个数）**，然后是函数中的局部变量。
【[http://t.csdnimg.cn/b0Tcu](http://t.csdnimg.cn/b0Tcu)】
6. 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了**栈的效率比较高**。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
7. 堆地址向上生长（低到高），栈地址向下生长（高到低），因为计算机总是先从低地址开始读，所以，栈先进后出，堆先进先出。


[http://t.csdnimg.cn/sV3N5](http://t.csdnimg.cn/sV3N5)

## 6.区别指针类型
	int *p[10]
	int (*p)[10]
	int *p(int)
	int (*p)(int)

1. `int *p[10]`表示指针数组，强调数组概念，是一数组变量，数组大小为 10，数组内每个元素都是指向 `int` 类型的指针变量（一个有十个指针的数组）。
1. `int (*p)[10]`表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个 `int` 类型的数组，这个数组大小是10（一个指向有十个整型数据数组的指针）。
1. `int *p(int)`是函数声明，函数名是 `p`，参数是 `int` 类型的，返回值是`int *`类型的。
1. `int (*p)(int)`是函数指针，强调是指针，该指针指向的函数具有 `int` 类型参数，并且返回值是 `int` 类型的。

**指针函数与函数指针：**

- **指针函数**：本质是一个函数，不过它的返回值是一个指针。【`ret *func(args, ...);`--`func` 是一个函数，`args` 是形参列表，`ret *` 作为一个整体，是 `func` 函数的返回值，是一个指针的形式。】
- **函数指针**：本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。【`ret (*p)(args, ...);` —`ret` 为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args` 为形参列表。其中`p`被称为函数指针变量 】


[http://t.csdnimg.cn/ItQSC](http://t.csdnimg.cn/ItQSC)


## 7.new/delete 与 malloc/free 的异同
- 相同点：都可用于内存的动态申请和释放；
- 不同点：
	- 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数；
	- new 自动计算要分配的空间大小，malloc 需要手动计算；
	- new 是类型安全的，malloc不是。
	- new 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，delete 对指针所指对象运行适当的析构函数；然后通过调用名为`operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用；
	- 后者需要库文件支持，前者不用；
	- new 是封装了 malloc，直接 free 不会报错，但是这只是释放内存，而不会析构对象。
	- malloc 和 free 返回的是 void 类型指针(必须进行类型转换)，new 和 delete 返回的是具体类型指针。

**new 的实现过程**：首先调用名为 `operator new` 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针。

**delete 的实现过程**：对指针指向的对象运行适当的析构函数，然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。

## 8.malloc/free和new/delete释放后的内存系统会马上回收吗？
用户 `free` 掉的内存并不是都会马上归还给系统，`ptmalloc` 会统一管理 `heap` 和 `mmap` 映射区域中的空闲的 `chunk`，当用户进行下一次分配请求时，`ptmalloc` 会首先试图在空闲的 `chunk` 中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。

`ptmalloc` 将相似大小的 `chunk` 用双向链表链接起来，这样的一个链表被称为一个 bin。`ptmalloc` 一共维护了 128 个 bin，并使用一个数组来存储这些 bin。

内存管理一般会有一个`free block list`，`free` 掉的东西就放在这里来，这里会尝试合并这些散乱的 `block`，而 `malloc` 首先找的也是` free block list`，而非从OS申请新的内存。【碎片问题：页大小固定，避免小内存一直分配，占据不同的页】

[http://t.csdnimg.cn/tjySr](http://t.csdnimg.cn/tjySr)


## 9.宏定义和函数有何区别？
- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于**直接插入**了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数；
- 宏定义属于在结构中插入代码，**没有返回值**；函数调用具有返回值；
- 宏定义**参数没有类型**，不进行类型检查；函数参数具有类型，需要检查类型；
- 宏定义不要在最后加分号。

## 10.宏定义 和 typedef 区别?
- 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名；
- 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分；
- 宏不检查类型；typedef会检查数据类型；
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束；

注意对指针的操作，`typedef char*p_char`和`#define p_char char *`区别巨大：

	typedef (int*)  pINT;
	#define pINT2 int*

效果相同？实则不同！实践中见差别：`pINT a,b;`的效果同`int *a; int *b;`表示定义了两个整型指针变量；而`pINT2 a,b;`的效果同`int *a, b;`表示定义了一个整型指针变量 a 和整型变量 b。


## 11.变量声明和定义区别?
- 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其**分配存储空间**。
- 相同变量可以在**多处声明**(外部变量 `extern`)，但只能在**一处定义**。


## 12.strlen 和 sizeof 区别?
- `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数；
- `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是`\0'`的字符串；
- 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小。

## 13.常量指针和指针常量区别?
- **指针常量**：是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的`int const `和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`；【**不能够通过指针修改内存数据**。只能防止通过指针引用修改内存中的数据，并不保护指针所指向的对象】
- **常量指针**：是一个不能改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值(也就是存放在指针中的地址)就不能在改变了，即不能中途改变指向，如`int *const p`。【**指针所指向的位置不能改变**，即指针本身是一个常量，但是指针所指向的内容可以改变。】

<font color="#F100">【以*为中间划一条线，看const修饰谁就谁就是常量。】</font>

[http://t.csdnimg.cn/q3F0U](http://t.csdnimg.cn/q3F0U)


## 14.C 语言和 C++ 的区别

1. **过程**：*C 编程语言不支持面向对象编程。因此，它不允许多态性、继承等。作为一种面向对象的语言，C++ 支持多态性和继承。*
2. **安全性**：*由于 C 语言不允许封装，数据变得可访问，其他实体可以破坏它。然而，C++ 支持封装，可以保护数据结构并根据需要使用它。*
3. **方法**：*C 编程语言鼓励自顶向下的方法，首先定义一个通用问题，然后将其分解为较小的任务。另一方面，C++ 鼓励自底向上的方法。这涉及首先识别和定义类，然后使用它们执行最初的任务。*
4. **输入/输出函数**：在 C 中，I/O 操作主要通过 C 标准库的标准 I/O 函数进行处理，如 printf() 和 scanf()。这些函数提供基本的格式化和读取功能，但缺少 C++ 中的一些高级功能；另一方面，C++ 通过使用 iostream 库中的对象扩展了 I/O 功能，这些对象称为**标准 I/O 流**。cout 流允许进行简单而灵活的输出操作，而 cin 流提供了增强的输入功能。C++ 流支持运算符重载，可方便地输出复杂数据类型并启用自定义格式选项。
5. **重载和覆盖**：方法覆盖允许子类重新定义从其祖先继承的函数。重载允许同一个函数有多个版本，每个版本具有唯一的参数。C 不支持这两者，但 C++ 支持。
6. **内存分配**：*C 编程依赖于两个关键函数——`calloc()`和`malloc()`——用于内存分配。相应的 free() 函数用于内存释放。C++使用new运算符进行动态内存分配，使用delete运算符进行释放。*
7. **编译**：C 和 C++ 的软件开发始于编写源代码。C文件的源代码具有`.c`扩展名，而 C++ 使用扩展名如`.cpp`或`.cxx`。这些源代码文件包含程序的指令和逻辑。


8. **变量**：通常，C编程语言使用两种类型的值：字面值和变量。C使用四种基本的变量类型：int、float、char和double。C++的主要变量类型包括bool、void和wchar_t。

9. **特点**：C编程语言是一种过程式、快速和高效的语言，具有模块化和丰富的内置运算符。与C不同，C++是一种过程式语言，具有OOP。此外，它是机器无关的、简单的和区分大小写的。
10. 在C++中，除了值和指针之外，**新增了引用**。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。

11. C++中的`try/catch/throw`异常处理机制取代了标准C中的`setjmp()`和`longjmp()`函数。

C编程语言是一种中级语言，而C++是一种高级语言。



[http://t.csdnimg.cn/X7tM2](http://t.csdnimg.cn/X7tM2)


## 15.C++中 struct 和 class 的区别？
相同点：

1. 两者都拥有成员函数、公有和私有部分；
1. 任何可以使用class完成的工作，同样可以使用struct完成。

不同点：

1. 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的；
2. class默认是private继承，而struct默认是public继承；
3. class 可以使用模板，而 struct 不能；


**引申：C++和C的struct区别**

- C 语言中：struct 是用户自定义数据类型(UDT)；C++中 struct 是抽象数据类型(ADT)，支持成员函数的定义，(**C++中的 struct 能继承，能实现多态**)
- C 中 struct 是没有权限的设置的，且 struct 中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且**成员不可以是函数**；C++中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public(为了与C兼容)；
- struct 作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中**必须在结构标记前加上struct**，才能做结构类型名(除:typedef struct class0;)；C++中结构体标记(结构体名)可以**直接作为结构体类型名使用**，此外结构体 struct 在C++ 中被当作类的一种特例；


[https://www.cnblogs.com/banluxinshou/p/11823158.html](https://www.cnblogs.com/banluxinshou/p/11823158.html)


## 16.define宏定义和const的区别？
角度1： 就定义常量说的话， const 定义的常数是**变量 也带类型**， #define 定义的只是个**常数 不带类型**。

角度2： 就起作用的阶段而言，#define 是在编译的**预处理阶段**起作用，而 const 是在 **编译、运行**的时候起作用。

角度3： 就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：

	#define N 2+3     // 我们预想的 N 值是 5，我们这样使用 
	Ndouble a = N/2;  // 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5
角度4： 就空间占用而言， 例如：

	#define PI 3.14     //预处理后 占用代码段空间
	const float PI=3.14;    // 本质上还是一个 float，占用数据段空间

角度5： 从代码**调试**的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了

角度6： 从是否可以再定义的角度而言，const 不足的地方，是与生俱来的，**const 不能重定义**，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义；【[const定义的对象属性可以改变](https://blog.csdn.net/Ain_z/article/details/109634087)】

[https://www.runoob.com/note/12963](https://www.runoob.com/note/12963)


## 17.C++ 中 const 和 static 的作用？
static

不考虑类的情况：

- 隐藏。所有不加 static 的全局变量和函数具有全局可见性，可以在其他文件中使用，**加了之后只能在该文件所在的编译模块中使用**；
- 默认**初始化为0**，包括未初始化的全局静态变量与局部静态变量，都存在**全局未初始化区**；
- 静态变量在函数内定义，**始终存在，且只进行一次初始化**，具有记忆性，其作用范围0与局部变量相同，函数退出后仍然存在，但不能使用

考虑类的情况：

- static 成员变量：**只与类关联**，不与类的对象关联。**定义时要分配空间，不能在类声明中初始化**，必须在类定义体外部初始化，**初始化时不需要标示为static**；可以被非static成员函数任意访问。
- static 成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问；


const

不考虑类的情况：

- const 常量在定义时必须初始化，之后无法更改；
- const 形参可以接收 const 和非 const 类型的实参，例如//i可以是int 型或者 const int型void fun(const int& i){ //...}

考虑类的情况：

- const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化；
- const成员函数：const 对象不可以调用非 const 成员函数；非const对象都可以调用；不可以改变非 `mutable`(用该关键字声明的变量**可以在const成员函数中被修改)数据的值**）。


<font color="#A100">

const 定义的常量在超出其作用域之后其空间会被释放，而static 定义的静态常量在函数执行后不会释放其存储空间。</font>


类里的static cosnt 和 const static成员初始化：它们的初始化没有区别，虽然一个是静态常量一个是常量静态。静态都将存储在全局变量区域，其实最后结果都一样。可能在不同编译器内，不同处理，但最后结果都一样。  

[https://www.cnblogs.com/phpzhou/p/6390869.html](https://www.cnblogs.com/phpzhou/p/6390869.html)


## 18.C++的顶层 const 和底层 const?
**顶层const**：指的是 `const` 修饰的变量本身是一个常量，无法修改，指的是指针，就是`*`号的右边；

**底层const**：指的是 `const` 修饰的变量所指向的对象是一个常量，指的是所指变量，就是号的左边；

	int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量
	const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量
	const int b3 = 20; 		   //顶层const，b3是常量不可变
	const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
	const int& b5 = a;		   //用于声明引用变量，都是底层const

- 如果 const 右结合修饰的为 `类型` 或者 `*`，那这个 const 就是一个底层 const；
- 如果 const 右结合修饰的为 `标识符`，那这个 const 就是一个顶层 const。

主要区别：

- 被修饰的变量本身无法改变的 const 是顶层 const；
- 通过指针或引用等间接途径来限制目标内容不可变的 const 是底层 const。

顶层 const 表示指针本身（对象值）是个常量；
底层 const 表示指针所指的对象（地址）是一个常量。

## 19.数组名和指针(这里为指向数组首元素的指针)区别?
- 二者均可通过**增减偏移量来访问**数组中的元素；
- 数组名不是真正意义上的指针，可以理解为常量指针，所以数组名没有自增、自减等操作；指针是变量指针；
- **当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但 sizeof 运算符不能再得到原数组的大小了**。

## 20.final 和 override 关键字
`final` 和 `override` 是C++11标准引入的两个关键字，它们为类的继承和多态机制提供了更多的控制权和明确性。

- `final` 关键字用于指示一个类或成员函数是最终的，**不能被继承或覆盖**，可以保护基类不被修改，防止滥用继承；
- `override` 关键字用于**明确指出**派生类中的成员函数旨在覆盖基类中的同名虚拟函数，并进行编译时类型检查。


## 21.拷贝初始化和直接初始化
- 如果**使用等号（=）**初始化一个变量，实际上执行的是“**拷贝初始化**”，编译器把等号右侧的初始值拷贝到新创建的对象中去。
- 与之相反，如果**不使用等号**，则执行的是“**直接初始化**”；

直接初始化实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；

拷贝初始化实际上是要求编译器将右侧运算对象拷贝到正在创建的对象中，通常用拷贝构造函数来完成；

**拷贝构造函数的形参必须是引用类型**的原因：如果不是引用类型，为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环，造成错误。

使用 `explicit` 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

[https://blog.csdn.net/capecape/article/details/78276677](https://blog.csdn.net/capecape/article/details/78276677)


## 22.C++初始化与赋值的区别
初始化不是赋值，初始化的含义是在创建对象时赋予一个初值，而赋值是将对象的当前值擦除掉，以一个新值代替。

[http://t.csdnimg.cn/sBvrQ](http://t.csdnimg.cn/sBvrQ)

## 23.extern"C" 的用法
`extern "c" ` 的主要作用就是为了**能够正确实现 C++ 代码调用其他 C 语言代码**。加上 `extern “c”` 后，会指示**编译器这部分的代码按C语言，而不是C++的方式进行编译**。


由于C++支持函数重载，因**此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名**；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。


**extern "C"使用要点**：

- 可以是单一语句：`extern “C” double sqrt(double);`
- 可以是复合语句，相当于复合语句中的声明都加了 `extern “C”`：`extern “C”{ double sqrt(double); int min(int, int);}`
- 可以包含头文件，相当于头文件中的声明都加了extern “C” ：`extern “C”{＃include <cmath> }`
- 不可以将 extern “C” 添加在函数内部;
- 如果函数有多个声明，可以都加 extern “C”, 也可以只出现在第一次声明中，后面的声明会接受第一个链接指示符的规则。


## 24.野指针和悬空指针
- **野指针**：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空；
- **悬空指针**：指针 free 或 delete 之后没有及时置空  => 释放操作后立即置空；

C++智能指针的本质就是避免悬空指针的产生。

## 25.C 和 C++ 的类型安全？
类型安全很大程度上可以等价于内存安全，**类型安全的代码不会试图访问自己没被授权的内存区域**。

<font color="#F100">**类型安全**是指同一段内存在不同的地方，会被强制要求使用相同的办法来解释(内存中的数据是用类型来解释的)。</font>

C 只在局部上下文中表现出类型安全；因为同一段内存可以用不同的数据类型来解释，比如1用int来解释就是1，用boolean来解释就是true。

如果C++使用得当，它将远比C更有类型安全性。相比于C，C++提供了一些新的机制保障类型安全：

- 操作符new返回的指针类型严格与对象匹配，而不是void*；
- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换；
- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
- C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。


Java语言是类型安全的，除非强制类型转换。

[http://t.csdnimg.cn/AlWSs](http://t.csdnimg.cn/AlWSs)


## 26.C++中的重载、重写(覆盖)和隐藏的区别？
**重载**：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，**重载不关心函数返回类型**。

**隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，注意**只要同名函数，不管参数列表是否相同，基类函数都会被隐藏**。

**重写(覆盖)**：是指派生类中存在重新定义的函数。其**函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。**只有函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 `virtual` 修饰，派生类可以没有。


## 27.C++有哪几种的构造函数
通常 C++中的构造函数可以分为5类：默认构造函数、普通构造函数、拷贝构造函数、转换构造函数、移动构造函数。

- **默认构造函数**：未提供显式初始值时，用来创建对象的构造函数`Student();//没有参数`；
- **普通构造函数**：C++用于构建类的新对象时需要调用的函数`Student(int num，int age）;//有参数`；
- **拷贝构造函数**：何时生成默认的拷贝构造函数；
- **转换构造函数**：一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象【string 类中可以找到使用转换构造函数的实用示例】；
- **移动构造函数**：以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。


委托构造函数是C++11引入的一个特性，它**允许一个构造函数调用同一类的另一个构造函数**，从而避免在类内部出现相似的初始化代码，提高代码的可维护性。在构造函数的初始化列表中使用` : `符号，可以调用同一类中的其他构造函数。

委托构造函数的调用必须出现在构造函数的初始化列表中。在构造函数主体中调用其他构造函数是不允许的。

## 28.浅拷贝和深拷贝的区别
**浅拷贝**：浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，**如果原来的指针所指向的资源释放了，我那么再释放浅拷贝的指针的资源就会出现错误**。

**深拷贝**：**深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值**，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。

深拷贝和浅拷贝是指在赋值一个对象时，拷贝的深度不同。 在进行深拷贝时，会拷贝所有的属性，并且如果这些属性是对象，也会对这些对象进行深拷贝，直到最底层的基本数据类型为止。

## 29.内联函数和宏定义的区别
**宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的**。

而且**内联函数是真正的函数**，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

**内联函数有类型检测、语法判断等功能，而宏没有。**


## 30.public, protected 和 private 访问和继承权限 /public/protected/private 的区别?
**访问权限：**

- public:可以被任意实体访问；
- protected:只允许子类及本类的成员函数访问；
- private:只允许本类的成员函数访问；

**继承：**

1. public 继承不改变基类成员的访问权限；
2. private 继承使得基类所有成员在子类中的访问权限变为 private；
3. protected 继承将基类中public成员变为子类的protected成员，其它成员的访问 权限不变；
4. 基类中的 private 成员不受继承方式的影响，子类永远无权访问。


友元是一种**定义在类外部的普通函数，但它需要在类体内进行声明**，为了与该类的成员函数加以区别，在声明时前面加以关键字 `friend`。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

[【C++】友元函数和友元类（作用及优缺点）](http://t.csdnimg.cn/ThyG8)

## 31.如何用代码判断大小端存储？
- **大端存储**：是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中；
- **小端存储**：是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

<font color="#F100">想办法取出一个字节的内容，就可以知道是哪种存储方式。</font>

初始化一个 `16 进制` 的int型的数据，然后把它放在一个 `char` 类型的数组中，由于**十六进制的数据一位代表四个bit位**；`char` 型是8个bit位，那么十六进制的两位占一个 `char` 位，那么就可以把数据位分离。

**方法一：直接法**

	int main()
	{
		int a = 0x12345678;
		char i = a;
		printf("%x", i);
	}
定义一个十六进制的数据，数据类型为int型，之后定义一个char类型的数据，**int数据类型的大小为四个字节，而char类型的数据为一个字节，所以将int类型的数据赋值给char时会丢失三个字节的数据，char类型中存储的是int类型中低地址的数据**，这时候char类型获取的数据输出之后，如果输出的是12那就说明你低地址位置的数据是12，那就说明你的数据是大端存储，如果输出的结果是78那当前条件下就是小端存储。

**方法二：指针法**

	int main()
	{
	    int i = 0x1122;
		char* p = (char*)& i;
		if (p[0] == 0x22 && p[1] == 0x11) {
			cout << "little endian" << endl;
		}
		else if (p[0] == 0x11 && p[1] == 0x22) {
			cout << "big endian" << endl;
		}
	}

`*p`就是`p[0]`，把变量的地址强制类型转换为`char*`，这样就可以每次取出一个字节的内容，因为 `char` 的大小就是1个字节，`p[0]`和`p[1]`都表示一个 `char` 类型。

将`int*`类型的` &i`强制转换为了`char*`类型，但值没有改变（地址）；地址存储的值也未改变，`p` 就是表示的这个地址，但 `p` 是 `char*` 类型的变量，因此可以用`p[0]p[1]`去取，每一个`p[]`就是两个十六进制的数（也就是一个字节）。`p[0]`就是`0x22`, `p[1]`就是`0x11`。

**方法三：联合体法**

	int main(){
		union
		{
			int value;
			char union_bytes[ sizeof(int) ];
		} test;
		test.value = 0x0102;
		if (  ( test.union_bytes[ 0 ] == 1 ) && ( test.union_bytes[ 1 ] == 2 ) )
		{
			printf( "big endian\n" );
		}
		else if ( ( test.union_bytes[ 0 ] == 2 ) && ( test.union_bytes[ 1 ] == 1 ) )
		{
			printf( "little endian\n" );
		}
		else
		{
			printf( "unknown...\n" );
		}
	}
在联合体中定义一个 char 类型的变量和 int 类型的变量，利用二者所占同一段存储空间，可以通过引用联合体变量中的成员访问 `char`  类型的数据，取出一个字节的内容。

**在 `union` 中所有的数据成员共用一个空间**，而且是**从低位开始占用**，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，**共用体变量的内存空间大小是该变量中某个占用空间最大的那个成员所占的空间**。。

即上述的union虽然定义了两个成员，但其实这个union只占用了4个字节(32位机器中 int 所占的空间大小)，往 value 成员赋值（value完整是0x00000102），然后读取 union_bytes ，union_bytes[0]就是value的第一个字节，union_bytes[1]就是value的第二个字节。

[http://t.csdnimg.cn/lm2iI](http://t.csdnimg.cn/lm2iI)


## 32.volatile、mutable 和 explicit 关键字的用法？
volatile 关键字是一种类型修饰符，用它声明的类型变量**表示可以被某些编译器未知的因素更改**。

<font color="#F100">当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。</font>


volatile 定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。

多线程中被几个任务共享的变量需要定义为 volatile 类型。


volatile 限定符的用法和 const 很相似，它起到对类型额外修饰的作用；const 和volatile 限定符互相没什么影响，**某种类型可能既是 const 的也是 volatile 的**，此时它同时具有二者的属性。

只有 `volatile` 的成员函数才能被 `volatile` 的对象调用。

可以把一个非 volatile in t赋给 volatile int，但是不能把非 volatile 对象赋给一个volatile对象。

**mutable**

- 用 const 修饰的成员函数时，**const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量**，当成员变量类型符前用 `mutable` 修饰时例外。

-  常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰；


> 常函数不能对普通成员变量（除mutable修饰外）进行写操作 ；
> 常函数可以被普通对象或者常对象调用；
> 
> 常对象不能调用所有普通函数，只能调用常函数；
> 常对象可以读成员变量；
> 
> [http://t.csdnimg.cn/pOfDm](http://t.csdnimg.cn/pOfDm)


**explicit**

c++ 提供了关键字 `explicit`，禁止通过构造函数进行的隐式转换。声明为 `explicit` 的构造函数不能在隐式转换中使用。

- 是针对**单参数**的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。
-  explicit用于修饰构造函数，防止隐式转化。




[https://www.cnblogs.com/codemagiciant/p/17524184.html](https://www.cnblogs.com/codemagiciant/p/17524184.html)


## 33.什么情况下会调用拷贝构造函数？
拷贝构造函数是一种特殊的构造函数，它在创建对象时，是**使用同一类中之前创建的对象来初始化新创建的对象**。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象；
- 复制对象把它作为参数传递给函数；
- 复制对象，并从函数返回这个对象；

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

## 34.C++中有几种类型的new（plain new\nothrow new\placement new)

**1. plain new**

言下之意就是普通的 `new`，就是我们常用的 `new`；

在C++中定义如下：

	void* operator new(std::size_t) throw(std::bad_alloc);
	void operator delete(void *) throw();
	Copy to clipboardErrorCopied
因此 plain new 在空间分配失败的情况下，抛出异常`std::bad_alloc`而不是返回 `NULL`，因此通过判断返回值是否为 `NULL` 是徒劳的。

**2.nothrow new**

	char *p = new(nothrow) char[10e11];
`nothrow new `在空间分配失败的情况下是不抛出异常，而是返回 `NULL`；


**3.placement new**

    ADT *q = new(p) ADT;
这种 new **允许在一块已经分配成功的内存上重新构造对象或对象数组。** `placement new`不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。

	void* operator new(size_t,void*);
	void operator delete(void*,void*);
	Copy to clipboardErrorCopied

`palcement new` 的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组；

`placement new`构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为`placement new`构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。


## 35.C++的异常处理的方法
- try、throw 和 catch 关键字`try...(throw)...catch...`；
- 函数的异常声明列表：在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表`int fun() throw(int,double,A,B,C) {...};`
这种写法表名函数可能会抛出 `int,double` 型或者A、B、C三种类型的异常，如果 `throw` 中为空表明不会抛出任何异常，如果没有 `throw` 则可能抛出任何异常【在C++11这种做法已经被摒弃，而后者则被C++11的 noexcept （noexcept 的一个作用是**阻止异常的传播，提高安全性**）异常声明所代替：`void func() noexcept {...}//等价于void func() throw(){...}`】；
- C++标准异常类 `exception`：C++标准提供了一组标准异常类，这些类以基类 Exception 开始，标准程序库抛出的所有异常，都派生于该基类，该基类提供一个成员函数 what()，用于返回错误信息（返回类型为 const char*）。

【析构函数默认也是noexcept的】

[https://www.cnblogs.com/QG-whz/p/5136883.html](https://www.cnblogs.com/QG-whz/p/5136883.html)
[https://www.cnblogs.com/suozhiyuan/p/12528891.html#_label0](https://www.cnblogs.com/suozhiyuan/p/12528891.html#_label0)

## 36.值传递、指针传递、引用传递的区别和效率

**传值**： 函数参数压栈的是参数的副本。  
任何的修改是在副本上作用，没有作用在原来的变量上。  

**传指针**：压栈的是指针变量的副本。    
当你对指针解指针操作时，其值是指向原来的那个变量，所以**对原来变量操作**。  

**传引用**：压栈的是引用的副本。由于引用是指向某个变量的，对引用的操作其实就是**对他指向的变量的操作**。

**传递效率上**： 调用被调函数的代码将实参传递到被调函数体内的过程。 
指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。 

**执行效率上**：在被调用的函数体内执行时的效率。    
因为传值调用时，当值被传到函数体内，临时对象生成以后，所有的执行任务都是通过**直接寻址**的方式执行的，而指针和大多数情况下的引用则是以**间接寻址**的方式执行的，所以实际的执行效率会比传值调用要低；如果函数体内对参数传过来的变量进行操作比较频繁，执行总次数又多的情况下，传址调用和大多数情况下的引用参数传递会造成比较明显的执行效率损失。

[https://www.cnblogs.com/ywliao/articles/8127531.html](https://www.cnblogs.com/ywliao/articles/8127531.html)

## 37.C++ 全局变量和 static 变量初始化问题
- 全局变量、文件域中的静态变量、类中的成员静态变量在 main 函数执行前初始化；局部变量中的静态变量在第一次调用时初始化。


**在 C 语言中是编译期初始化并分配内存**，故不能用变量给静态局部变量赋值，只能用常量。

**在C++中是第一次执行时初始化**，因为 C++ 引入了对象的概念，对象一般需要构造函数，无法简单的分配内存，故可以用变量赋值，并且在**第一次使用时初始化**。


- 初始化顺序：对于编译单元（同一个文件）的全局变量来讲，初始化顺序跟声明的顺序一致。销毁顺序则相反。
对于不同编译单元的全局变量，初始化顺序不确定。对于不同编译单元的全局变量互相引用的情况应避免。

解决不同文件相互引用全局变量初始化顺序不确定问题：可以通过函数调用，引用的时候不直接引用全局变量，而是放在一个函数中。**函数中的全局变量在调用时初始化**。


**类的静态成员变量声明和定义**   
静态成员变量不属于任何一个对象，对象的数据中不应该包含静态成员的数据。所以在**定义类的时候不会给静态变量分配内存只是声明**，因此就要在其他地方分配即定义。

> 定义与声明的区别  
**声明**：只是向程序表面变明的类型和名字。    
**定义**：为变量分配内存，也可以顺便初始化。程序中变量有且只有一个定义（更能说明为什么要在类外再定义下类的静态成员变量了）





## 38.new 和 malloc 的区别
1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；
2、使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算；而malloc则需要显式地指出所需内存的尺寸。  
3、 new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 new 是符合类型安全性的操作符。而malloc内存分配成功则是返回`void*`需要**通过强制类型转换将`void*`指针转换成我们需要的类型**。  
4、new 内存分配失败时，会抛出 `bac_alloc` 异常。malloc分配内存失败时返回NULL。  
5、 new 会先调用`operator new`函数，申请足够的内存(通常底层使用malloc实现)。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete 先调用析构函数，然后调用operator delete函数释放内存(通常底层使用free实现)。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做**自定义类型对象构造和析构工作**。


## 39.delete p、delete [] p、allocator都有什么作用?
- delete p是用于释放由 new 运算符分配的单个对象的内存。
- 如果使用 new[] 运算符创建了一个对象数组，那么应该使用delete [] p 来释放内存，而不是 delete p。【delete[] p是用于释放由`new[]`运算符分配的对象数组的内存。在释放内存时，delete[] p会**调用每个对象的析构函数**，然后释放整个数组的内存（delete[时，数组中的元素按**逆序**的顺序进行销毁）】。

- new在内存分配上面有一些局限性，new 的机制是将内存分配和对象构造组合在一起同样的，delete 也是将对象析构和内存释放组合在一起的。allocator 将这两部分分开进行， **allocator 申请一部分内存，不进行初始化对象**，只有当需要的时候才进行初始化操作。

[https://www.cnblogs.com/codemagiciant/p/17524217.html](https://www.cnblogs.com/codemagiciant/p/17524217.html)


allocator的主要作用如下：

1.**内存分配**：allocator负责为容器中的元素分配内存。它使用动态内存分配机制（如new和malloc）从堆上分配内存，并返回指向分配内存的指针。

2.**内存释放**：当元素被从容器中移除或容器被销毁时，allocator负责释放先前分配的内存。它使用delete和free等函数释放先前分配的内存。

3.**对象构造和析构**：allocator还负责在分配的内存空间中构造和析构对象。当新元素被添加到容器中时，allocator使用元素的构造函数来创建对象，并在元素被移除时调用析构函数来销毁对象。

4.**内存对齐**：allocator还负责按照特定的内存对齐方式来分配内存，以确保对象的起始地址满足对齐要求。这对于某些类型的对象（如带有对齐要求的结构体）非常重要。


## 40.new和delete的实现原理，delete是如何知道释放内存的大小的？
new 和 delete是用户进行动态内存申请和释放的操作符，operator new 和operator delete是系统提供的全局函数，new在底层调用operator new全局函数来申请空间，delete在底层通过operator delete全局函数来释放空间。

C++ 的做法是在分配数组空间时多分**配了4个字节的大小，专门保存数组的大小**，在 delete 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。



[http://t.csdnimg.cn/NX0dG](http://t.csdnimg.cn/NX0dG)


## 41.malloc、realloc、calloc的区别
malloc 申请的空间的值是随机初始化的；  
calloc 申请的空间的值是初始值为0；  
realloc 给动态分配的空间分配额外的空间，用于扩充容量。


## 42.malloc与free的实现原理?
`malloc` 小于`128k`的内存，使用 `brk` 分配内存，将「堆顶」指针往高地址推；`malloc` 大于 `128k` 的内存，使用 `mmap` 分配内存，在堆和之间找一块空闲内存分配；

**brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。** 

**malloc分配内存之后，只是分配了虚拟内存，还没有映射到物理内存，只有当访问申请的内存的时候，才会发生缺页中断，分配对应的物理内存**

当最高地址空间的空闲内存超过128K(可由M TRIM THRESHOLD选项调节)时，执行内存紧缩操作(trim)。【调用`sbrk(-size)`将内存归还操作系统】


[https://jacktang816.github.io/post/mallocandfree/](https://jacktang816.github.io/post/mallocandfree/)


## 43.类成员初始化方式？构造函数的执行顺序？为什么用成员初始化列表会快一些？
**赋值初始化**，通过在函数体内进行赋值初始化；  
**列表初始化**，在冒号后使用初始化列表进行初始化。

主要区别在于：  
<font color = blue>对于在函数体中初始化，是在所有的数据成员被分配内存空间后才进行的；  </font>
列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)，那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说**初始化这个数据成员此时函数体还未执行**。


一个派生类构造函数的执行顺序如下：  
① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）；  
② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）；  
③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）；  
④ 派生类自己的构造函数。


方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，**C++的赋值操作是会产生临时对象的**。临时对象的出现会降低程序的效率。


## 44.有哪些情况必须用到成员列表初始化？作用是什么？
1.**必须使用成员初始化**的四种情况：  
① 当初始化一个引用成员时；  
② 当初始化一个常量成员时；  
③ 当调用一个基类的构造函数，而它拥有一组参数时；  
④ 当调用一个成员类的构造函数，而它拥有一组参数时；  

**成员初始化列表做了什么**：  
① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；  
② list 中的项目顺序是**由类中的成员声明顺序决定**的，不是由初始化列表的顺序决定的。

## 45.C++中新增了string，它与C语言中的 char * 有什么区别吗？它是如何实现的？
string 继承自 `basic_string`，其实是对 `char* `进行了封装，封装的 string 包含了 `char*` 数组，容量长度等等属性。

`string` 可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间 (`2*n`) 然后将原字符串拷贝过去，并加上新增的内容。


## 46.什么是内存泄露，如何检测与避免？
**内存泄露**  
一般我们常说的内存泄漏是指**堆内存的泄漏**。  
堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定）内存块，使用完后必须显式释放的内存。应用程序般使用 malloc、realloc、new 等函数从堆中分配到块内存，
**使用完后，程序必须负责相应的调用 free 或 delete 释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏**。

避免内存泄露的几种方式  
计数法：使用 new 或者 malloc 时，让该数+1，delete 或 free 时，该数 -1，程序执行完打印这个计数，如果不为 0 则表示存在内存泄露；  
一定要将基类的析构函数声明为虚函数【否则不会调用派生类的析构函数，要能够保证继承关系中最高的基类的析构函数是虚的（具有传递性）】；  
对象数组的释放一定要用delete []；  
有 new 就有delete，有 malloc 就有 free，保证它们一定成对出现；

检测工具  
Linux下可以使用Valgrind工具；  
Windows下可以使用CRT库。

## 47.对象复用的了解，零拷贝的了解
**对象复用是指将已经创建的对象进行重复使用，而不是创建新的对象。**  

在面向对象编程中，对象复用可以通过以下几种方式实现：  
1.**对象池** ：对象池是一种常见的对象复用方式，它可以将已经创建的对象保存起来，并在需要时将其重新使用。  
2.**模板类和模板对象** ：模板类和模板对象可以将一些公共的行为封装在类和对象中，从而实现对象的复用。  
3.**类的成员变量** ：类的成员变量可以是类的实例对象，这样可以将对象的状态和行为保存在类的成员变量中，从而实现对象的复用。  
4.**对象的静态变量** ：对象的静态变量可以是类的实例对象，这样可以将对象的状态和行为保存在类的静态变量中，从而实现对象的复用。

**零拷贝是指在程序运行过程中，对对象的复制和初始化过程中，只复制对象的引用而不复制对象本身**。  
这样可以避免对象的内存分配和释放过程，从而提高程序的性能。零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。  
实现零拷贝的方法有多种，其中最常见的是使用**C++中的智能指针和垃圾回收器**。


## 48.介绍面向对象的三大特性，并且举例说明
**1.封装**  
C++中的封装是指将属性和方法包装在一个类中，并通过访问控制符来限制外部对类的访问。封装可以提高代码的可维护性和安全性，同时也可以实现多态性。


**2.继承**  
C++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。


**3.多态**
同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）【允许将子类类型的指针赋值给父类类型的指针（向上转换）】。

实现多态有二种方式：覆盖（override），重载（overload）。

## 48.C++的四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast

**为什么C++需要四种类型转换？**  
**1.隐式转换缺点**：  

- 可能会导致数据精度丢失：当将一个数据类型转换为另一个数据类型时，可能会发生精度丢失，例如将一个浮点数转换为整数时，小数部分会被截断。
- 可能导致未定义行为：隐式转换可能会导致未定义行为，例如将一个指针类型转换为整数类型可能会导致未定义行为。
- 代码不够清晰：隐式转换可能会使代码不够清晰，因为它不需要在代码中明确地指定转换的类型。

【C++中提供了 `explicit` 关键字，在构造函数声明的时候加上 `explicit` 关键字，能够**禁止隐式转换**】


**2.显式转换缺点：**

- 可能会导致数据失真：当使用显式转换将一个数据类型转换为另一个数据类型时，可能会导致数据失真，例如将一个整数转换为浮点数时，小数部分可能会出现不准确的情况。
- 可能会导致代码不够清晰：显式转换需要程序员在代码中明确地指定转换的类型，这可能会使代码不够清晰，同时也增加了代码的复杂性。


C++中的类型转换包括**自动类型转换**、**强制类型转换**、**类型解析转换**和**类型推断转换**。

- **static_cast**（编译时类型检查）：`static_cast < type-id > ( expression )`，将 `expression` 转换为 `type-id` 类型。  
<font color = red>static_cast 是静态类型转换，发生在编译期。这种转换不会进行运行时的动态检查（RTTI），因而这种转换可能是不安全的。 </font>
- **const_cast**：`const_cast` 只能改变运算对象的**底层 const**，用来移除变量的 `const` 或 `volatile` 限定符。  
注意：`const_cast` 是不能用来执行任何类型的转换的，比如只能将 `const char* p` 转换成` char* p`，而不能转成 `int* p`。
- **reinterpret_cast**：`reinterpret_cast` 可以将指针类型任意转换，甚至是不相关的类之间（既不检查指针所指向的内容，也不检查指针类型本身）【旧式强制类型转换执行与reinterpret_cast类似的功能】；
- **dynamic_cast**：`dynamic_cast` 只能用于指向类的指针和引用(或void*)。它的目的是确保类型转换的结果指向目标指针类型的有效完整对象。  
`dynamic_cast` 主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性（）

> 何为安全性？  
> 即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL，之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。


C++中层次类型转换中无非两种：上行转换和下行转换

- 对于上行转换，`static_cast` 和 `dynamic_cast` 效果一样，都安全；
- 对于下行转换：你必须确定要转换的数据确实是目标类型的数据，即需要注意要转换的父类类型指针是否真的指向子类对象，如果是，`static_cast` 和 `dynamic_cast` 都能成功；如果不是 `static_cast` 能返回，但是不安全，可能会出现访问越界错误，而 `dynamic_cast` 在运行时类型检查过程中，判定该过程不能转换，返回NULL。



[https://www.cnblogs.com/codemagiciant/p/17544722.html](https://www.cnblogs.com/codemagiciant/p/17544722.html)

## 49.C++函数调用的压栈过程
