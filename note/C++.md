## 1.C和C++的区别
**设计思想上：** C++是面向对象的语言，而C是面向过程的结构化编程语言。

**语法上：**

C++具有封装、继承和多态三大特性。

C++相比较C，增加了许多类型安全的功能，比如强制类型转换、智能指针。

C++支持泛型编程，比如模板类，函数模板等。


## 2.构造函数后面的冒号有什么用？
在构造函数后面加冒号，表示冒号后面接构造函数初始化列表（constructor initialize list），主要有三种应用场景：

1. 对基类进行初始化;
2. 对类成员进行初始化;
3. 对类的const成员变量进行初始化;

由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或者使用初始化列表赋值。


## 3. 函数后面 = default 和 = delete 有什么用？
[http://t.csdnimg.cn/hUk79](http://t.csdnimg.cn/hUk79 "http://t.csdnimg.cn/hUk79")

`=defalut`使得被修饰的函数为编译器默认的形式。只能用于（类的）特殊的成员函数（默认构造函数，复制构造函数，析构函数等）。

`=delete`使得编译器禁止该类型的成员函数生成。例如：1.禁用拷贝构造函数；2.禁用不需要用的参数转换。

对特殊成员函数使用以上修饰符使得代码更容易阅读。


## 4.类的大小和什么有关系？

平时所声明的类只是一种类型定义，它本身是没有大小可言的。

这里所说的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。

类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员均对类的大小无影响。


<font color="#F100">静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类的所有对象共享，并不属于哪个对象。</font>

虚函数对类的大小有影响，是因为虚函数表指针带来的影响；
虚继承对类的大小有影响，是因为虚基表指针带来的影响。

[http://t.csdnimg.cn/FR01C](http://t.csdnimg.cn/FR01C "http://t.csdnimg.cn/FR01C")
**c++空类（这个类不带任何数据）的大小不为0，为1。**


因为：new需要分配不同的内存地址，不能分配内存大小为0的空间，避免除以 sizeof(T)时得到除以0错误，故使用一个字节来区分空类。

## 5.struct 和 typedef struct 什么区别？
C ：

	typedef struct student {
		int a;
	}Stu;

这时声明变量就可以：`Stu stu1;`
如果上面没有加 `typedef` 就必须用 `struct student stu1` 来声明。这里的 `Stu` 实际上就是 `struct Student` 的别名。
另外这里也可以不写 `Student typedef struct {}Stu`; 那声明变量的时候就不能`struct Student stu1;`了只能`Stu stu1;`）


C++:

1. `struct name {int a;}stu;` 这里 `stu` 是一个变量。
2. `typedef struct name{int a;}stu;`这里的 `stu` 是一个结构体类型。


## 6.函数后面加const
`const` 只能加在类的成员函数后面（普通函数不可以），也就是说这些成员函数是只读函数。

1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）

2、加了cosnt的成员函数，表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）
非静态成员函数后面加 `const` 和 `mutable` 是反义词


加了 `const` 的成员函数可以被 非const对象 和 const对象调用。**注意是对象**。

但不加 `const` 的成员函数只能被 非const对象 调用。

<font color="#A100">函数前面加 cosnt 表示返回值是 const，函数后面加 const 表示不可以修改 class 的成员。</font>



## 7.共享数据的保护
1.常引用：所引用的形参不能被更新

	void display(const double& a);

2.常对象：在生存期内不能被更新，但必须被初始化

	A const a(3, 4);

3.常成员函数：不能修改对象中数据成员，也不能调用类中没有被const修饰的成员函数（常对象唯一的对外接口）。如果声明了一个常对象，则该对象只能调用它的常函数！另外，可以用于对重载函数的区分。

	void print();
	void print() const;

4.extern int a;使得其他文件也能访问该变量

声明一个函数或定义函数时，冠以 `static` 的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数（每一个cpp文件就是一个编译单元）


## 8.运算符重载注意
单目运算符最好重载为成员函数，双目最好为友元函数。

`=、[]`只能重载为成员函数，`<<`和`>>`只能重载为友元函数。


## 9.程序内存分配方式以及它们的区别
内存分配大致上可以分成5块：

1. **栈区（stack）**：栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）
1. **堆区（heap）**：一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆时两回事，分配方式类似于链表。
1. **全局区（静态区）（static）**：全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
1. **常量存储区**：常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
1. **程序代码区**：存放函数体的二进制代码。


## 10.全局变量、全局静态变量、静态变量、静态函数

### 全局静态变量和全局变量的区别
1.若程序由一个源文件构成时，全局变量与全局静态变量没有区别；

2.若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即全局静态变量对组成该程序的其他源文件时无效的；

3.具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。

静态变量只被所属源文件使用。


### static的作用
**1、全局静态变量**

在全局变量前加上关键字 `static`，全局变量就被定义成一个全局静态变量。

**存放区**：存放在静态存储区，在整个程序运行期间一直存在。

**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

**作用域**：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

**2、局部静态变量**

在局部变量前加上关键字 `static`，局部变量就被定义成一个局部静态变量。

**存放区**：静态存储区。

**初始化**：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

**作用域**：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

**3、静态函数**

在函数返回类型前加 `static`，函数就被定义为静态函数。函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。
这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**warning**：（没懂）不要在头文件中声明 `static` 的全局函数，不要在cpp内声明 非static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中去，否则cpp内部声明需加上static修饰。

**4、类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**5、类的静态函数**
静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用 `class_name::static_func()` 就可以访问。

### 静态成员函数与普通成员函数的区别
静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）

普通成员函数有this指针，可以访问类中的任意成员（普通成员变量和静态成员变量，好像静态成员函数没有this指针不能通过this访问，但是可以通过类名::访问）；而静态成员函数没有this指针。


## 11.new delete 与 malloc free的联系与区别
`new delete `和 `malloc free`都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄漏或者二次释放。

不同的是，`new delete`是C++`中定义的操作符`，`new` 除了分配空间外，还会调用类的构造函数来完成初始化工作，delete 除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。


## 12.explicit
`explicit` 关键字只能用于类的构造函数的声明上。它的作用是防止构造函数进行的隐式转换。

在C++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担了两个角色：

第一是构造；

第二是默认且隐含的类型转换操作符。即如果构造函数接收到的参数会默认进行隐式转换。

隐式转换看起来很方便，但是某些情况下违背了程序员的本意。这个时候就要加上explicit修饰，指定这个构造器只能被明确的调用/使用，不能进行隐式转换。

	class A
	{
	public:
	    explicit A(int a, int b) : m_a(a), m_b(b) {};
	private:
	    int m_a;
	    int m_b;
	}
	
	int main()
	{
	    A test(1, 2); //正确
	    A test1(2.2, 2); // 错误，存在double->int的隐式转换。
	}


## 13.c++的四种 cast 转换
cast转换是C++的强制转换：`cast-name<target_type>(expression);`

1、`const_cast`
唯一一个可以改变const性质的转换

2、`static_cast`
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

3、`dynamic_cast`
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果时非法的对于指针返回 `null`，对于引用抛出异常。要深入理解内部转换的原理。

向上转换：指的是子类向基类的转换。
向下转换：指的是基类向子类的转换。

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、`reinterpret_cast`
几乎什么都可以转，可能会出问题，尽量少用。

## 14.为什么不用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

C的强制转换 `(type_name)expression`



## 15.mutable关键字
`mutable` 的中文意思时可变的、易变的，跟 constant（即C++里的const）是反义词。在C++中，mutable 也是为了突破 const 的限制而设置的。被 mutable 修饰的变量（**`mutable`只能用于修饰类的非静态数据成员**），将永远处于可变的状态（可以修改成员数据之类的），即使在一个const函数中。

## 16.用const修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 `const` 修饰，那么函数返回值（即指针）的内容不能修改，且该返回值只能被赋给加 `const` 的同类型指针。一般只在返回值为引用或指针时使用，返回其他值时没有必要。

	const char* get_string(void);
	char *str = get_string();//编译报错
	const char *str = get_string();//正确

## 17.宏、const、enum
`#define`不被视为语言的一部分（#define属于预处理器）。

对于单纯常量，最好用 `const` 对象或者 `enum` 替换`#define`。

对于类似函数的宏，尽量使用内联函数替换掉 `#define`


**编译器处理方式不同**: `define` 宏是在预处理阶段展开; `const` 常量是在编译运行阶段使用。

**类型**：
`define` 宏没有类型，不做任何类型检查，仅仅是展开；
`const` 常量没有具体的类型，在编译阶段会执行类型检查。

**起作用的方式**：`#define` 只是简单的字符串替换，没有类型检查。而 `const` 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。正因为 `define` 只是简单的字符串替换，会导致边界效应，很容易犯错。

	#define N 2+3
	const double a = N/2; //结果是2+3/2 = 2+1 = 3
	const double b = (double)N / (double)2;
	//我们预想的答案是2.5，可实际输出的值是2 + 3 / 2 = 3.5


**占用空间**：
`define` 宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，占用代码段空间；
`const` 常量会在内存中分配（可以是在堆中也可以是在栈中） 占用数据段空间

**调试角度**：
`const` 常量是可以进行调试的，`#define` 不能进行调试，因为在预编译阶段就已经替换掉了。

**作用域**：`const` 变量是由作用域的，`#define` 在没有遇到 `#undefine` 之前是没有作用域限制的。

## 18.程序编译
程序编译是指将源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。便已产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。

## 19.class 和 struct 的区别
c++中，class 和 struct 都可以定义一个类。
它们有以下两点区别：

1、默认继承权限，如果不指定，来自 class 的继承按照 private 继承处理，来自struct 的继承按照 public 继承处理。

2、成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是public权限。

<<<<<<< HEAD
## 20.C++ 默认编写并调用了哪些函数
编译器会主动为用户编写的任何类声明一个拷贝构造函数、拷贝复制操作符和一个析构函数，同时如果声明生命任何构造函数，编译器也会为你声明一个 `default` 版本的拷贝构造函数，这些函数都是 `public` 且 `inline` 的。

注意，上边说的是声明，只有当这些函数有调用需求的时候，编译器才会帮你去实现它们。但是编译器替你实现的函数可能在类内引用、类内指针、有const成员以及类型有虚属性的情形下会出问题：

1. 对于拷贝构造函数，要考虑到类内成员有没有深拷贝的需求，如果有的话就需要自己编写拷贝构造函数/操作符，而不是把这件事情交给编译器来做。
1. 对于拷贝构造函数，如果类内有引用成员或 `const` 成员，需要自己定义拷贝行为，因为编译器替你实现的拷贝行为在上述两个场景很有可能是有问题的。
1. 对于析构函数，如果该类有多态需求，请主动将析构函数声明为 `virtual`

## 21.为多态基类声明 virtual
带有多态性质的基类必须将析构函数声明为虚函数，防止指向子类的基类指针在被释放时只局部销毁了该对象。

如果一个类有多态的内涵，那么几乎不可避免的会有基类的指针（或引用）指向子类对象，因为非虚函数没有动态类型，所以如果基类的析构函数不是虚函数，那么在基类指针析构时会直接调用基类的析构函数，造成子类对象仅仅析构了基类的那一部分，有内存泄漏的风险。

除此之外，还需注意：

1. 需要注意的是，普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价。
1. 如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为 `final` （C++ 11），这样禁止派生可以防止误继承造成上述问题。
1. 编译器自动生成的析构函数时非虚的，所以多态基类必须将析构函数显示声明为virtual。


## 22.禁止使用编译器自动生成的函数
如果类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么就应该禁止编译器去自动生成它：

1. 将被禁止生成的函数声明为 `private` 并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。
1. 将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。
2. C++11可以直接使用 `= delete` 来声明拷贝构造函数，显示禁止编译器生成该函数。


## 23.别让异常逃离析构函数
析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。

析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明抛出异常后的代码无法再继续执行，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃。

在析构函数中只负责记录，需要时刻保证析构函数能够执行到底


## 24.不要在构造和析构过程中调用 virtual 函数
在多态环境中，需要重新理解构造函数和析构函数的意义，这两个函数在执行过程中，涉及到了对象类型从基类到子类，再从子类到基类的转变。

一个子类对象开始创建时，首先调用的是基类的构造函数，在调用子类构造函数之前，**该对象将一直保持着“基类对象”的身份而存在**，自然在基类的构造函数中调用的虚函数——将会是基类的虚函数版本，在子类的构造函数中，**原先的基类对象变成了子类对象**，这时子类构造函数里调用的是子类的虚函数版本。

这是一件有意思的事情，这说明**在构造函数中虚函数并不是虚函数**，在不同的构造函数中，调用的虚函数版本并不同，因为随着不同层级的构造函数调用时，对象的类型在实时变化。那么相似的，析构函数在调用的过程中，子类对象的类型从子类退化到基类。


因此，如果无法在基类的构造函数中调用子类的虚函数。


## 25.在 operator= 中处理“自我赋值”
自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要假借指针来实现：

	*pa = *pb;		 			//pa和pb指向同一对象，便是自我赋值。
	arr[i] = arr[j];		//i和j相等，便是自我赋值


那么对于管理一定资源的对象重载的 `operator =`  中，一定要对是不是自我赋值格外小心并且增加预判，因为无论是深拷贝还是资源所有权的转移，原先的内存或所有权一定会被清空才能被赋值，如果不加处理，这套逻辑被用在自我赋值上会发生——先把自己的资源给释放掉了，然后又把以释放掉的资源赋给了自己——出错了

第一种做法是在赋值前增加预判，但是这种做法没有异常安全性，试想如果在删除掉原指针指向的内存后，在赋值之前任何一处抛出了异常，那么原指针就指向了一块已经被删除的内存。
    
    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      if (this == &rhs) return *this;
      
      delete ptr;	
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr将指向一块已经被删除的内存。
      return *this;
    }


如果我们把异常安全性也考虑在内，那么我们就会得到如下方法，令人欣慰的是这个方法也解决了自我赋值的问题。

    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      DataBlock* pOrg = ptr;
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr仍然指向之前的内存。
      delete pOrg;
      return *this;
    }



另一个使用copy and swap技术的替代方案。


## 26.复制对象时勿忘其每一个成分

当你给类多加了成员变量时，不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果忘记处理，编译器也不会报错。

如果类有继承，那么在为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是 `private` 的，所以无法访问它们，应该让子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数：

    //在成员初始化列表显示调用基类的拷贝构造函数
    ChildClass::ChildClass(const ChildClass& rhs) : BaseClass(rhs) {		
      	// ...
    }


除此之外，拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个。

其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此**前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。**


## 27.设计 class 犹如设计 type
每次设计class时最好在脑中过一遍以下问题：

1. 对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。
1. 对象的构造函数与赋值行为应有何区别：构造函数和赋值操作符的区别，重点在资源管理上。
1. 对象被拷贝时应考虑的行为：拷贝构造函数。
1. 对象的合法值是什么？最好在语法层面、至少在编译前应对用户做出监督。
1. 新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。
1. 新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非explicit函数之间的取舍。
1. 新类型是否需要重载操作符。
1. 什么样的接口应当暴露在外，而什么样的技术应当封装在内（public和private）
1. 新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。
1. 这个类是否具备template的潜质，如果有的话，就应改为模板类。


## 28.函数接口应该以const引用的形式传参，而不应该是按值传参

1. 按值传参涉及大量参数的复制，这些副本大多是没有必要的。
1. 如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。
1. 对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。
1. 小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。


## 29.对class内所有成员变量声明为private，private意味着对变量的封装

简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是private了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是语法一致性；其次，对变量的封装意味着，**可以尽量减小因类型内部改变造成的类外外代码的必要改动**。

**public 和 protected属性在一定程度上是等价的**。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种——用这个类创建对象或者继承这个类以设计新的类——以下简称为第一类客户和第二类客户。

从封装的角度来说，一个 public 的成员说明了类的作者决定对类的第一种客户不封装此成员，而一个 protected 的成员说明了类的作者对类的第二种客户不封装此成员。


## 30.若所有参数皆需类型转换，请为此采用non-member函数

如果我们在使用操作符时希望操作符的任意操作数都可能发生隐式类型转换，那么应该把该操作符重载成非成员函数。

首先说明：**如果一个操作符是成员函数，那么它的第一个操作数（即调用对象）不会发生隐式类型转换。**

操作符一旦被设计为成员函数，它在被使用时的特殊性就显现出来了——单从表达式无法直接看出是类的哪个对象在调用这个操作符函数

做为成员函数的操作符默认操作符的第一个操作数应当是正确的类对象——**编译器根据第一个操作数的类型来确定被调用的操作符到底属于哪一个类的**。

举例说明：当 `Ratinoal` 类的构造函数允许 `int` 类型隐式转换为 `Rational` 类型时，`Rational z = x + 2;`是可以通过编译的，因为操作符是被 `Rational` 类型的 `x` 调用，同时将 `2` 隐式转换为 `Ratinoal` 类型，完成加法。但是 `Rational z = 2 + x;`却会引发编译器报错，因为由于操作符的第一个操作数不会发生隐式类型转换，所以加号“+”实际上调用的是`2`——一个 `int` 类型的操作符，因此编译器会试图将 `Rational` 类型的 `x` 转为 `int`，这样是行不通的。


## 31.子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口
在确定是否需要public继承的时候，我们首先要搞清楚子类是否必须拥有父类每一个特性，如果不是，则无论生活经验是什么，都不能视作”is-a”的关系。**public 继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。**


## 32.避免遮掩继承而来的名称
在父类中，虚函数`foo()`被重载了两次，可能是由于参数类型重载（`foo(int)`），也可能是由于`const`属性重载(`foo() const`)。如果子类仅对父类中的`foo()`进行了覆写，那么在子类中父类的另外两个实现(`foo(int) ,foo() const`)也无法被调用，这就是名称遮盖问题——名**称在作用域级别的遮盖是和参数类型以及是否虚函数无关的**，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖。

如果想要重启父类中的函数名称，需要在子类有此需求的作用域中（可能是某成员函数中，可能是 `public` 或 `private` 内）加上 `using Base::foo;`，即可把父类作用域汇总的同名函数拉到目标作用域中，需要注意的是，此时父类中的`foo(int)`和`foo() const`都会被置为可用。

如果只想把父类某个在子类中某一个已经不可见的同名函数复用，可使用`inline forwarding function`。


## 33.区分接口继承和实现继承
成员函数的接口总是会被继承，而public继承保证了，如果某个函数可施加在父类上，那么他一定能够被施加在子类上。不同类型的函数代表了父类对子类实现过程中不同的期望。

- 在父类中声明纯虚函数，是为了**强制子类拥有一个接口，并强制子类提供一份实现。**
- 在父类中声明虚函数，是为了**强制子类拥有一个接口，并为其提供一份缺省实现。**
- 在父类中声明非虚函数，是为了**强制子类拥有一个接口以及规定好的实现，并不允许子类对其做任何更改**。

在这其中，有可能出现问题的是普通虚函数，这是因为*父类的缺省实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应从代码层面提醒子类的设计者做相应的检查_，很可惜，普通虚函数无法实现这个功能*。***一种解决方案是，在父类中为纯虚函数提供一份实现，作为需要主动获取的缺省实现***，当子类在实现纯虚函数时，检查后明确缺省实现可以复用，则只需调用该缺省实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查缺省实现的适用性。

将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者**在于从编译层面提醒子类主动实现接口**，后者则侧重于**给予子类自由度对接口做个性化适配**。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，
**保证所有继承体系内能有其一份实现**。


## 34.不重新定义继承而来的non-virtual函数

如果函数有多态调用的需求，一定记得把它设为虚函数，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。

反之同理，如果一个函数父类没有设置为虚函数，你千万千万不要在子类重载它，也会犯上边类似的错误。

理由就是，多态的动态调用中，只有虚函数是动态绑定，非虚函数是静态绑定的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。

话说回来，**虚函数的意思是“接口一定被继承，但实现可以在子类更改”，而非虚函数的意思是“接口和实现都必须被继承”。**


## 35.绝不重新定义继承而来的缺省参数值
在继承中：

1. 不要更改父类非虚函数的缺省参数值，其实不要重载父类非虚函数的任何东西，不要做任何改变！
1. 虚函数不要写缺省参数值，子类自然也不要改，虚函数要从始至终保持没有缺省参数值。
> 
> 缺省参数是 声明或定义函数 时为函数的 形参指定一个缺省值（默认参数）。

虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的缺省参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。

缺省参数值属于静态绑定的原因是为了提高运行时效率。


## 36.类的复合：一个类的对象可以作为另一个类的成员

什么情况下我们应该用类的复合:

第一种情况，非常简单，说明某一个类“拥有”另一个类对象作为一个属性，比如学生拥有铅笔、市民拥有身份证等，不会出错。

第二种情况被讨论的更多，即“一个类根据另一个类实现”。比如“用stack实现一个queue”，更复杂一点的情况可能是“用一个老版本的Google Chrome内核去实现一个红芯浏览器”。



## 37.审慎地使用private继承
private继承正是表达“通过某工具类实现另一个类”。那么相似的，工具类在目标类中自然应该被隐藏——所有接口和变量都不应对外暴露出来。这也解释了private继承的内涵，它本质是一种__技术封装__，和public继承不同的是，private继承表达的是“**只有实现部分被继承，而接口部分应略去”的思想。**

与private继承的内涵相对应，**在private继承下，父类的所有成员都转为子类私有变量——不提供对外访问的权限**，外界也无需关心子类内有关父类的任何细节。


当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与private继承中做选择呢？


尽可能用复合，除非必要，不要采用private继承。
当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择private继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。


## 38.少使用多继承

原则上不提倡使用多继承，因为多继承可能会引起多父类共用父类，导致在底层子类中出现多余一份的共同祖先类的拷贝。为了避免这个问题C++引入了虚继承，但是虚继承会使子类对象变大，同时使成员数据访问速度变慢，这些都是虚继承应该付出的代价。

## 39.讲一讲封装、继承、多态是什么？
**封装**：将具体实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性，使类成为一个具有内部数据的自我隐藏能力、功能独立的软件模块。

**意义**：保护或防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。


----------


**继承**：子类继承父类的特征和行为，复用了基类的全体数据和成员函数，具有从基类复制而来的数据成员和成员函数（基类私有成员可被继承，但是无法被访问），其中构造函数、析构函数、友元函数、静态数据成员、静态成员函数都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。

> 如果对一个类或者虚函数使用 final 关键字，则代表不允许再对其内容进行修改:
>  对类使用final关键字，代表它不可以作为基类被继承；
>  对虚函数使用final关键字，代表它不可以在子类中被重写。

**意义**：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期

----------

**多态**：不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。

**意义**：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。


## 40.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？
**实现方式**：多态分为**动态多态**（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和**静态多态**（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）。

其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做**虚函数表**，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。

> 虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。 
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说**在代码的编译阶段，虚表就可以构造出来了。**

>**虚表是属于类的，而不是属于某个具体的对象**，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。
><font color="#A100">对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。</font>


>[虚函数表详解](http://t.csdnimg.cn/sJZb5 "虚函数表详解")

而静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。**隐藏只与函数名有关，与参数没有关系**）来实现的。

**优点**：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。


## 41.什么时候会执行函数的动态绑定？
符合以下三个条件：

1. 通过指针来调用函数
1. 指针upcast向上转型（继承类向基类的转换称为upcast）
1. 调用的是虚函数

如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的通过虚表的机制。

> "Upcasting"是面向对象编程中的一个概念，它指的是将一个子类对象的引用或指针转换为基类（也就是父类）类型的引用或指针。这种转换是安全的，因为子类对象是其基类对象的一个超集，这意味着子类对象包含其基类的所有成员。


## 42.动态绑定的流程

1. 取出类的虚函数表的地址
1. 根据虚函数表的地址找到虚函数表
1. 根据找到的虚函数的地址调用虚函数。

[C++虚函数表：让多态成为可能的关键](https://blog.csdn.net/qq_21438461/article/details/126362661https://blog.csdn.net/qq_21438461/article/details/126362661)

## 43.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的？
在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针

**虚函数表**：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。

**虚函数指针**：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。

当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。

## 44.智能指针的本质是什么，它们的实现原理是什么？
智能指针就是帮C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而避免内存泄漏。

智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。

实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。

[C++ 智能指针 - 全部用法详解](https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171379580616800197099831%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171379580616800197099831&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142^v100^pc_search_result_base3&utm_term=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)

`auto_ptr`：c++ 98定义的智能指针模板，定义了管理指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存。

头文件: `#include <memory>`；用法：`auto_ptr<类型> 变量名(new 类型)`

C++11 后auto_ptr 已经被“抛弃”，已使用 `unique_ptr` 替代！C++11后不建议使用auto_ptr(原因)：
1). 复制或者赋值都会改变资源的所有权；
2). 在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值；
3). 不支持对象数组的内存管理


----------

智能指针的三个常用函数：

1. get() 获取智能指针托管的指针地址
1. release() 取消智能指针对动态内存的托管
2. reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉

----------


`unique_ptr`：unique_ptr 和 auto_ptr 用法几乎一样，除了一些特殊

特性：

1. 基于排他所有权模式：两个指针不能指向同一个资源
1. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
1. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
1. 在容器中保存指针是安全的

----------

`shared_ptr`：可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，引用计数加1，当智能指针析构时，引用计数减1，如果计数为零，代表已经没有指针指向这块内存，那么就释放它。

1.引用计数的使用：

调用 `use_count` 函数可以获得当前托管指针的引用计数。

2.构造

1). `shared_ptr<T> sp1;` 空的shared_ptr，可以指向类型为T的对象

2). `shared_ptr< T > sp2(new T());` 定义shared_ptr,同时指向类型为T的对象

3). `shared_ptr<T[]> sp4;` 空的shared_ptr，可以指向类型为T[]的数组对象 C++17后支持

4). `shared_ptr<T[]> sp5(new T[] { … });` 指向类型为T的数组对象 C++17后支持

5). `shared_ptr< T > sp6(NULL, D());` 空的shared_ptr，接受一个D类型的删除器，使用D释放内存

6).`shared_ptr< T > sp7(new T(), D());`定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存

3.初始化

1). 方式一：构造函数
	
	shared_ptr<int> up1(new int(10));  // int(10) 的引用计数为1
	shared_ptr<int> up2(up1);  // 使用智能指针up1构造up2, 此时int(10) 引用计数为2

2). 方式二：使用make_shared 初始化对象，分配内存效率更高(推荐使用)
make_shared函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr; 用法：

    make_shared<类型>(构造类型对象需要的参数列表);
	shared_ptr<int> up3 = make_shared<int>(2); // 多个参数以逗号','隔开，最多接受十个


4.赋值

	shared_ptrr<int> up1(new int(10));  // int(10) 的引用计数为1
	shared_ptr<int> up2(new int(11));   // int(11) 的引用计数为1
	up1 = up2;	// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2

5.主动释放对象
	
	shared_ptrr<int> up1(new int(10));
	up1 = nullptr ;	// int(10) 的引用计数减1,计数归零内存释放 
	// 或
	up1 = NULL; // 作用同上 

6.重置

`p.reset();` 将p重置为空指针，所管理对象引用计数减1

`p.reset(p1);` 将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控

`p.reset(p1,d); `将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器;p1是一个指针！

7.交换

p1 和 p2 是智能指针

	std::swap(p1,p2); // 交换p1 和p2 管理的对象，原对象的引用计数不变
	p1.swap(p2);    // 交换p1 和p2 管理的对象，原对象的引用计数不变

在使用shared_ptr智能指针时，要注意避免对象交叉使用智能指针的情况！ 否则会导致内存泄露！

----------

`weak_ptr` :设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。 同时 weak_ptr 没有重载`*`和`->`但可以使用 lock 获得一个可用的 shared_ptr 对象。

    shared_ptr<Girl> sp_girl;
	sp_girl = wpGirl_1.lock();

	// 使用完之后，再将共享指针置NULL即可
	sp_girl = NULL;

**expired**：判断当前weak_ptr智能指针是否还有托管的对象，有则返回false，无则返回true

<font color="A100">禁止delete 智能指针get 函数返回的指针：
如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放</font>


## 45.匿名函数的本质是什么？他的优点是什么？
匿名函数了，也叫做lambda表达式。

	[capture](parameters) specifiers exception attr -> return type { /*code; */ }
	[capture]代表捕获列表，括号内为外部变量的传递方式，包括值传递、引用传递等
	(parameters)代表参数列表，其中括号内为形参，和普通函数的形参一样
	specifiers exception attr代表附加说明符，一般为mutable、noexcept等
	->return type代表lambda函数的返回类型如 -> int、-> string等。在大多数情况下不需要，因为编译器可以推导类型
	{}内为函数主体，和普通函数一样




匿名函数本质上是一个**对象**，在其定义的过程中会创建出一个**栈对象**，内部通过重载()符号实现函数调用的外表。

**优点**：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。


## 46.右值引用是什么，为什么要引入右值引用？
右值引用是为一个临时变量取别名，它只能绑定到一个临时变量或表达式（将亡值）上。实际开发中我们可能需要对右值进行修改（实现移动语义时就需要）而右值引用可以对右值进行修改。


为什么：

1.为了支持移动语义，右值引用可以绑定到临时对象、表达式等右值上，这些右值在生命周期结束后就会被销毁，因此可以在右值引用中窃取其资源，从而避免昂贵的复制操作，实现高效的移动语义。

2.完美转发：右值引用可以绑定到任何类型的右值上，可以将其作为参数传递给函数，并在函数内部将其“转发”到其他函数中，从而实现完美转发。

3.拓展可变参数模板，实现更加灵活的模板编程。


> 左值准确来说是：一个表示数据的表达式(如变量名或解引用的指针），且可以获取他的地址（取地址），可以对它进行赋值；它可以在赋值符号的左边或者右边。

>右值准确来说是：一个表示数据的表达式（如字面常量、函数的返回值、表达式的返回值），且不可以获取他的地址（取地址）；它只能在赋值符号的右边。

>>>左值引用：给左值取别名；右值引用：给右值取别名

>左值引用只能引用左值；const左值引用可以左值，也可以引用右值（因为右值通常是不可以改变的值，所以用const左值引用是可以的）；右值只能引用右值；左值可以通过
>
>（左值）来转化为右值，继而使用右值引用。

	int main()
	{
		// 左值引用只能引用左值，不能引用右值。
		int a = 10;
		int& ra1 = a;   // ra1为a的别名
		//int& ra2 = 10;   // 编译失败，因为10是右值
	 
		// const左值引用既可引用左值，也可引用右值。
		const int& ra3 = 10;
		const int& ra4 = a;
	 
		 //右值引用只能右值，不能引用左值。
		int&& r1 = 10;
	 
	 
		int a = 10;
	    //message : 无法将左值绑定到右值引用
		int&& r2 = a;
	 
	 
		 //右值引用可以引用move以后的左值
		int&& r3 = std::move(a);
	 
		return 0;
	}


左值引用的意义在于:

1.函数传参：实参传给形参时，可以减少拷贝。

2.函数传返回值时，只要是出了作用域还存在的对象，那么就可以减少拷贝。

<font color="#A100">右值引用和左值引用减少拷贝的原理不一样：
左值引用是取别名，直接起作用；
右值引用是间接起作用，实现移动构造和移动赋值,在拷贝的场景中，如果是右值(将亡值)，转移资源

</font>


**右值是不能取地址的，但是给右值取别名后，会导致右值被存储到特定位置，且可以取到该位置的地址。（右值被右值引用以后就成为了左值）**

[【C++】右值引用（极详细版）](https://blog.csdn.net/ChaoFreeandeasy_/article/details/130229252?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171386931016800185849419%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171386931016800185849419&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-130229252-null-null.142^v100^pc_search_result_base9&utm_term=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&spm=1018.2226.3001.4187)


## 47.左值引用和指针的区别？

**是否初始化**：指针可以不用初始化，引用必须初始化

**性质不同**：指针是一个变量，引用是对被引用的对象取一个别名

**占用内存单元不同**：指针有自己的空间地址，引用和被引用对象占同一个空间。

## 48.指针是什么？
指针全名为指针变量，计算机在存储数据是有序存放的，为了能够使用存放的地址，就需要一个地址来区别每个数据的位置，指针变量就是用来存放这些地址的变量。

## 49.weak_ptr真的不计数？是否有计数方式，在哪分配的空间？
计数，控制块中有强弱引用计数

如果是使用 `make_shared` 初始化的函数则它所在的控制块空间是在所引用的 `shared_ptr` 中同一块的空间；

若是 `new` 则控制器所分配的内存与 `shared_ptr` 本身所在的空间不在同一块内存。


## 50.malloc 的内存分配的方式，有什么缺点？
malloc 并不是系统调用，而是C库中的函数，用于动态内存分配，在使用 malloc 分配内存的时候会有两种方式向操作系统申请堆内存:

**方式1**：当用户分配的内存小于128KB时通过 `brk()` 系统调用从堆分配内存；

**实现方式**：将堆顶指针向高地址移动，获取内存空间，如果使用 `free` 释放空间，并不会将内存归还给操作系统，而是会缓存在 `malloc` 的内存池中，待下次使用。

**方式2**：当用户分配的内存大于128KB时通过 `mmap()` 系统调用在文件映射区域分配内存；

**实现方式**为：使用私有匿名映射的方式，在文件映射区分配一块内存，也就是从文件映射区拿了一块内存，`free` 释放内存的时候，会把内存归还给操作系统，内存得到真正释放。

----------

**缺点**：容易造成内存泄漏和过多的内存碎片，影响系统正常运行，还得注意判断内存是否分配成功，而且内存释放后（使用free函数之后指针变量p本身保存的地址并没有改变），需要将 p 的赋值为 `NULL` 拴住野指针。


## 51.为什么不全部使用mmap来分配内存？
因为向操作系统申请内存的时候，是要通过系统调用的，执行系统调用要进入内核态，然后再回到用户态，状态的切换会耗费不少时间，所以申请内存的操作应该避免频繁的系统调用，如果都使用mmap来分配内存，等于每次都要执行系统调用。另外，因为mmap分配的内存每次释放的时候都会归还给操作系统，于是每次mmap分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候就会触发缺页中断。


> **缺页中断**：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。


>**缺页异常被触发通常有两种情况**：
>1.程序设计的不当导致访问了非法的地址；
2.访问的地址是合法的，但是该地址还未分配物理页框（malloc()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存）。


>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
>1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行


>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
>1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

[简述缺页中断](https://blog.csdn.net/weixin_52669146/article/details/130589203)

## 52.为什么不全部都用brk？
如果全部使用brk申请内存那么随着程序频繁的调用malloc和free，尤其是小块内存，堆内将产生越来越多的不可用的内存碎片。

>通过调用brk系统调用，程序可以请求操作系统增加或减少它的堆空间，以动态地管理内存。

> brk() 函数是用来修改分配给调用者进程的内存量的。这种修改是通过改变进程的中断值到addr并提供必要的空间数量来实现的。
> 
> brk()函数用于修改分配给调用方进程的内存量。随着中断值的上升，分配的空间数量也在上升。新分配的空间有一个0的值分配给它。如果程序先减去然后再增加断点值，重新分配的空间的值就不会被清空。


## 53.传入一个指针，它如何确定具体要清理多少空间呢？
在申请内存的时候，会多分配**16字节**的内存，里面保存了内存块的详细信息，`free` 会对传入的内存地址向**左偏移16字节**，然后分析出当前内存块的大小，就知道要释放多大的内存空间了。

## 54.define和const的区别是什么？
**编译阶段**：define是在编译预处理阶段进行简单的文本替换，const是在编译阶段确定其值。

**安全性**：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查；const定义的常量是有类型的，是要进行类型判断的。

**内存占用**：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的内存；const定义常量占用静态存储区域的空间，程序运行过程中只有一份。

**调试**：define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量是可以进行调试的。


## 55.程序运行的步骤是什么
**预编译**：将头文件编译，进行宏替换，输出.i文件

**编译**：将其转化为汇编语言文件，主要做词法分析，语义分析以及检查错误，检查无误后将代码翻译成汇编语言，生成.s文件

**汇编**：汇编器将汇编语言文件翻译成机器语言，生成.o文件

**链接**：将目标文件和库链接到一起，生成可执行文件.exe


## 56.（☆）锁的底层原理是什么？
锁的底层是通过CAS，atomic 机制实现。

**CAS机制**：全称为Compare And Swap（比较相同再交换）可以将比较和交换操作转换为原子操作，CAS操作依赖于三个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存在内存之中。（就是每一个线程从主内存复制一个变量副本后，进行操作，然后对其进行修改，修改完后，再刷新回主内存前。再取一次主内存的值，看拿到的主内存的新值与当初保存的快照值，是否一样，如果不一样，说明有其他线程修改，本次修改放弃，重试。）

**atomic机制**：原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何切换到另一个线程。


## 57.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？
内存对齐是处理器为了提高处理性能而对存取数据的起始地址所提出的一种要求。

有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定的地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时将进行对齐，这就具有平台的移植性。

CPU每次寻址有时需要消耗时间的，并且CPU访问内存的时候并不是逐个字节访问，而是以字长为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐内存，处理器需要做多次内存访问，而对齐的内存访问可以减少访问次数，提升性能。

优：提高程序的运行效率，增强程序的可移植性。

## 58.（☆）进程之间的通信方式有哪些？
**管道**：管道分为匿名管道和命名管道，管道本质上是一个内核中的一个缓存，当进程创建管道后会返回两个文件描述符，一个写入端一个输出端。缺点：半双工通信，一个管道只能一个进程写，一个进程读。不适合进程间频繁的交换数据

**消息队列**：可以边发边收，但是每个消息体都有最大长度限制，队列所包含的消息体的总数量也有上限并且在通信过程中存在用户态和内核态之间的数据拷贝问题

**共享内存**：解决了消息队列存在的内核态和用户态之间的数据拷贝问题。

**信号量**：本质上是一个计数器，当使用共享内存的通信方式时，如果有多个进程同时往共享内存中写入数据，有可能先写的进程的内容被其他进程覆盖了，信号量就用于实现进程间的互斥和同步PV操作不限于信号量+-1，而且可以任意加减正整数

信号

套接字

## 59.（☆）线程之间的通信方式有哪些？


## 60.（☆）介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式



select、poll、epoll都是IO多路复用的一种机制，可以监视多个文件描述符，一旦某个文件描述符进入读或写就绪状态，就能够通知系统进行相应的读写操作。

----------

**Select优点**：可移植性好，因为在某些Unix系统中并不支持poll和epoll

对于超时时间提供了更好的精度：微妙，而poll和epoll都是毫秒级

**Select缺点**：支持监听的文件描述符 fd 的数量有限制，最大数量默认是1024个

Select 需要维护一个用来存放文件描述符的数据结构，每次调用 select 都需要把 fd 集合从用户区拷贝到内核区，而 select 系统调用后有需要把 fd 集合从内核区拷贝到用户区，这个系统开销在 fd 数量很多的时候会很大。



----------

**Poll优点（相对于select而言）**：没有最大文件描述符数量的限制，poll 基于链表存储主要解决了这个最大文件描述符数量的限制（当然，他还是有限制的，上限为操作系统能支持的能开启的最大文件描述符数量），优化了编程接口，减少了函数调用参数，并且，每次调用 select 函数时，都必须重置该函数的三个 fd_set 类型的参数值，而 poll 不需要重置。

**Poll缺点**：poll 和 select 一样同样都需要维护一个用来存放文件描述符的数据结构，当注册的文件描述符无限多时，会使得用户态和内核区之间传递该数据结构的复制开销很大。每次 poll 系统调用时，需要把文件描述符 fd 从用户态拷贝到内核区，然后 poll 系统调用返回前，又需要把文件描述符 fd 集合从内核区拷贝到用户区，这个内存拷贝的系统开销在fd数量很多的时候会很大。

----------

**Epoll优点**：和poll一样没有最大文件描述符数量的限制，epoll 虽然也需要维护用来存放文件描述符的数据结构（epoll_event），但是它只需要将该数据结构拷贝一次，不需要重复拷贝，并且它只在调用 epoll_ctl 系统调用时拷贝一次要监听的文件描述符数据结构到内核区，在调用 epoll_wait 的时候不需要再把所有的要监听的文件描述符重复拷贝进内核区，这就解决了 select 和 poll 种内存复制开销的问题。

**Epoll缺点**：目前只有Linux操作系统支持epoll，不支持跨平台使用，而Unix操作系统上是使用kqueue。

**Epoll水平触发（LT）**：对于读操作，只要缓冲区内容不为空，LT模式返回读就绪；

对于写操作，只要缓冲区还不满，LT模式会返回写就绪。

**Epoll边缘触发（ET）**：对于读操作，当缓冲区由不可读变为可读的时候，有新数据到达时，进程修改了 EPOLL_CTL_MOD 修改 EPOLLIN 事件时

在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。

当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait() 时，它不会通知你，也就是它**只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你**。通常配合将文件描述符设置为非阻塞状态一起使用，这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。


# 61.类的生命周期
类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载七个阶段**。其中验证，准备，解析三个部分统称为**连接**

- 全局对象在main开始前被创建，main退出后被销毁。
- 静态对象在第一次进行作用域时被创建，在main退出后被销毁。
- 局部对象在进入作用域时被创建，在退出作用域时被销毁。
- New 创建的对象直到内存被释放的时候都存在。


## 62.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？
构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。

析构函数可以是虚函数：vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。

要注意，使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。

## 63.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？
因为在多进程中易发生多进程对资源进行竞争，如果一个进程集合里面的每一个进程都在等待这个集合中的其他一个进程才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁。产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件。解决死锁的方法就是破坏上述任意一种条件。

## 64.描述一下面向过程和面向对象
**面向对象**：就是将问题分解为各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为，相比面向过程，代码更易维护和复用。但是代码效率相对较低。

**面向过程**：就是将问题分析出解决问题的步骤，然后将这些步骤一步一步的实现，使用的时候一个一个调用就好。代码效率更高但是代码复用率低，不易维护。


## 65.++i是左值还是右值，++i和i++哪个效率更高？
++i是左值，因为++i返回的是一个左值没有发生拷贝，所以效率更高。

## 66.介绍一下vector、list的底层实现原理和优缺点
**Vector优点**：可使用下标随机访问，尾插尾删效率高

**缺点**：前面部分的插入删除效率低，扩容有消耗，可能存在一定的空间浪费。

**原理**：底层是由一块连续的内存空间组成，由三个指针实现的分别是**头指针（**表示目前使用空间的头），**尾指针**（表示目前使用空间的尾）和**可用空间尾指针**实现

----------

**List优点**：按需申请内存，不需要扩容，不会造成内存空间浪费。在任意位置的插入删除下效率高。

**缺点**：不支持下标随机访问

**原理**：底层是由双向链表实现的

## 67.静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）
静态变量，全局变量，常量都在编译阶段完成初始化和内存分配。其他变量都是在编译阶段进行初始化，运行阶段内存分配.。

## 68.如何实现多进程？
在Linux中C++使用fork函数来创建进程

而windows中C++使用createprocess来创建进程


## 69.空对象指针为什么能调用函数？
在类的初始化的时候，编译器会将它的函数分配到类的外部，这也包括静态成员函数，这样做主要是为了节省内存，如果我们在调用类中的的成员函数时没有使用类中的任何成员变量，它不会使用到this指针所以可以正常调用这个函数。

## 70.shared_ptr线程安全吗？
智能指针中的引用计数是线程安全的，但是智能指针所指向的对象的线程安全问题，智能指针没有做任何保障线程不安全。也就是说它所管理的资源可以线程安全的释放，**只保证线程安全的管理资源的生命期**，不保证其资源可以线程安全地被访问。

## 71.push_back()左值和右值的区别是什么？
如果 push_back（）的参数是左值，则使用它拷贝构造新对象，如果是右值，则使用它移动构造新对象。

## 72.move底层是怎么实现的？
move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。

优点：可以将左值变成右值而避免拷贝构造，将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝。

> std::move是C++11新增加的一个函数模板，其主要功能是将一个左值强制转换为一个右值引用。

>其原型定义如下：

>template<typename T>
>typename remove_reference<T>::type&& move(T&& arg) noexcept;

>其中remove_reference是一个类型转换模板，其主要功能是去除模板类型T的引用类型，返回一个非引用类型。

>函数move接收一个泛型参数，该参数被声明为一个右值引用，也就是T&&。当函数move接收到一个左值参数时，其会将该参数强制转换为一个右值引用，并返回一个右值引用类型的转换结果。

>在C++11中，移动语义的引入解决了传递复制构造函数和复制赋值运算符中的性能问题。当使用std::move函数将一个左值转换为右值引用时，可以避免不必要的对象复制和内存分配，从而提高程序的性能和效率。

## 73.完美转发的原理是什么？
完美转发是指函数模板可以将自己的参数完美的转发给内部调用的其他函数，完美是指不仅能够准确的转发参数的值，还能保证被转发参数的左、右值属性不变，使用引用折叠的规则，将传递进来的左值以左值传递出来，将传递进来的右值以右值的方式传出。

## 74.空类中有什么函数？
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符

取值运算符、const取值运算符

## 75.explicit用在哪里？有什么作用？
只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。


## 76.成员变量初始化的顺序是什么？
成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。**类中const成员常量必须在构造函数初始化列表中初始化。类中static成员变量，只能在类外初始化。**

顺序：基类的静态变量或全局变量，派生类的静态变量或者全局变量，基类的成员变量，派生类的成员变量。

## 77.指针占用的大小是多少？
64位电脑上占8字节，32位的占4字节，我们平时所说的计算机多少位是指计算机CPU中通用寄存器一次性处理、传输、暂时保存的信息的最大长度。即CPU在单位时间内能一次处理的二进制的位数，因此CPU所能访问的内存所有地址由多少位组成，而8比特位表示1字节，就可以得出在不同位数的机器中指针的大小。

## 78.野指针和内存泄漏是什么？如何避免？
内存泄漏：是指程序中以动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

避免：使用智能指针管理资源，在释放对象数组时使用delete[]，尽量避免在堆上分配内存

野指针：指向一个已删除的对象或未申请访问受限内存区域的指针。

避免：对指针进行初始化，用已合法的可访问内存地址对指针初始化，指针用完释放内存，将指针赋值nullptr。

## 79.malloc 和 new 的区别是什么？
malloc/free是标准库函数，new/delete是C++运算符

malloc分配内存失败返回空，new失败抛异常

new/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。

New返回有类型的指针，malloc返回无类型的指针

分配内存的位置：malloc从堆上动态分配内存，new是从自由存储区为对象动态分配内存（取决于operator new的实现，可以为堆还可以是静态存储区）

new申请内存的步骤：调用operator new函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。

delete：先调用对象的析构函数，再调用operator delete函数释放内存空间


## 80.(☆)多线程会发生什么问题？线程同步有哪些手段？
会引发资源竞争的问题，频繁上锁会导致程序运行效率低下，甚至会导致发生死锁。

**线程同步手段**：使用atomic原子变量，使用互斥量也就是上锁，使用条件变量或信号量制约对共享资源的并发访问。


## 81.什么是STL？
它是C++标准库的重要组成部分，不仅是一个可复用的组件库也是一个包含了数据结构与算法的软件架构。

STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。

> [STL基础知识 简介](https://blog.csdn.net/weixin_53332395/article/details/123948946)

## 82.对比迭代器和指针的区别
迭代器不是指针，是一个模板类，通过重载了指针的一些操作符模拟了指针的一些功能，迭代器返回的是对象引用而不是对象的值。

指针能够指向函数而迭代器不行,迭代器只能指向容器

## 83.空间配置器?

空间配置器是操作系统开辟的一大段内存空间。STL需要扩容申请内存时，就从空间配置器中申请，不需要再经过操作系统。并且，它还能回收释放的空间，供下一次使用。一个进程中有一个空间配置器，进程中所有容器需要的空间都到对应空间配置器申请。进程终止，对应空间配置器空间释放。

空间配置器有两级结构，一级空间配置器是用来处理大块内存，二级空间配置器处理小块内存。SGI-STL规定以**128字节作为小块内存和大块内存的分界线**。

**为什么这样区分成两级？**

因为STL容器，一般申请的都会是小块的内存，二级空间配置器，主要是管理容器申请空间和释放的空间。
如果用户申请的空间直接大于的128字节直接找的是一级空间配置器申请空间。

----------

**一级空间配置器**：
一级空间配置器原理很简单，直接是对malloc和free进行了封装，并且增加了C++中的申请空间失败抛异常机制。
主要的作用是：向操作系统申请内存，申请失败会抛异常。
为什么不直接用 C++ 的 new 和 delete，因为这里并不需要调用构造函数和析构函数。

----------

**二级空间配置器**：
二级空间配置器专门负责处理小于128字节的小块内存。

SGI-STL采用了内存池的技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式来提高用户获取空间的速度和高效管理。

[https://blog.csdn.net/weixin_51164515/article/details/125743478](https://blog.csdn.net/weixin_51164515/article/details/125743478)

## 84.NULL和nullptr的区别与联系？
`NULL` 是一个预处理器变量，在头文件 `cstdlib` 中定义为 0 值。预处理器是运行在编译过程之前的一段程序，预处理变量不属于命名空间 std，它是由预处理器负责管理。当用到一个预处理变量时，在编译时，预处理器会自动把它替换为实际值，因此使用 NULL 初始化指针和使用 0 初始化指针是一样的。

`nullptr` 是一个字面值常量，它可以被转化为任何其他类型的指针。

另外，把int 型变量直接赋值给指针是错误的操作，即使 int 型变量等于 0 也不行！

为了解决二义性，C++11标准引入了关键字nullptr，它作为一种空指针常量。


## 85.为什么C 中 (void*)0 是空指针常量，而C++中不是？

因为 C 语言中任何类型的指针都可以（隐式地）转换为 void* 型，反过来也行。
而 C++ 中void* 型不能隐式地转换为别的类型指针（例如：int  *p = (void *) 0;  使用C++编译器编译会报错）。


## 86.(☆)线程有哪些状态，线程锁有哪些？
五种状态：创建，就绪，运行，阻塞，死亡

线程锁的种类：互斥锁，条件锁，自旋锁，读写锁，递归锁


## 87.解释说明一下 map 和 unordered_map？
map 内部实现是一个红黑树，内部所有的元素都是有序的，而 hashmap 则是内部实现了一个哈希表，内部存储元素是无序的

**map优点**：有序性，其次是内部实现的是一个红黑树，使得很多操作都可以在logn的复杂度下可以实现效率较高。

**map缺点**：空间占用率高

**unorderedmap优点**：查找效率非常高；

**unorderedmap缺点**：哈希表的建立比较费时间。


## 88.vector中的push_back()和emplace_back()的区别、以及使用场景
当使用 `push_back` 时会先调用类的有参构造函数创建一个临时变量，再将这个元素拷贝或者移动到容器之中，而 `emplace_back` 则是直接在容器尾部进行构造比 push_back 少进行一次构造函数调用。在大部分场景中 `emplace_back` 可以替换 `push_back`，但是 `push_back` 会比 `emplace_back` 更加安全，`emplace_back` 只能用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中则需要使用 `push_back`。


## 89.(☆)如何实现线程安全，除了加锁还有没有其他的方式？
除了锁之外还可以使用互斥量（防止多个线程来同时访问共享资源，从而避免数据竞争的问题），原子操作（原子操作是不可分割的，使用原子操作可以确保在多线程环境中操作是安全的），条件变量（协调线程之间的协作，用来在线程之间传递信号，从而控制线程的执行流程）等方式。

## 90.vector扩容，resize和reserve的区别？
使用resize改变的是vector的大小（size），可能会添加或删除元素。

使用reserve改变的是vector的容量（capacity），不会改变当前元素的数量，仅仅是为了优化内存使用和性能。

## 91.vector 扩容为了避免重复扩容做了哪些机制？
当vector内存不够时本身内存会以1.5或者2倍的增长，以减少扩容次数

引入了reserve，自定义vector最大容量

## 92.C++中空类的大小是多少？
1字节

空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，因为实例化的过程就是在内存中分配一块地址。

注意：**当该空白类作为基类时，该类的大小就优化为0了，这就是所谓的空白基类最优化。**

注意：**空白基类最优化无法被施加于多重继承上只适合单一继承**。


## 93.weak_ptr 是怎么实现的？
实现依赖于计数器和寄存器实现的，计数器用来记录弱引用的数量，寄存器用来存储shared_ptr

shared_ptr：a 和 b的对象内部，具有各自指向对方的shared_ptr，并且 a 和 b 的引用计数都是2.当程序退出时，引用计数减为1，对象并不会被析构掉。


weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，即就是将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。不论是否有用weak_ptr指向一旦最后一个指向对象的shared_ptr被销毁，对象就会是释放。从这个角度看，weak_ptr更像是一个shared_ptr的助手，weak_ptr并不拥有对对象的管辖权，weak_ptr指向shared_ptr的目标也不会增加计数器值。

[weak_ptr](https://blog.csdn.net/m0_57719144/article/details/131153455)

## 94.虚函数的底层原理是什么？

C++中的虚函数是一种特殊类型的成员函数，用于实现运行时多态性。虚函数允许在基类中使用基类指针或引用来调用派生类的函数实现，从而根据对象的实际类型来执行相应的函数代码。

----------


虚函数的作用和优势包括：

1. **多态性**：通过虚函数，可以在运行时根据对象的实际类型来选择调用相应的函数实现。这样可以实现多态性，使得程序更加灵活和易于扩展。
1. **继承和接口**：虚函数为派生类提供了一种方式来继承基类的接口。基类中声明的虚函数在派生类中可以被覆盖（重写）以提供特定的实现。
1. **避免判断对象类型**：通过使用虚函数，不需要手动判断对象的实际类型，而是让编译器自动处理，使代码更加简洁和可读。
1. **动态绑定**：虚函数通过动态绑定（Dynamic Binding）实现多态性。在运行时，基类指针或引用会根据对象的实际类型调用相应的虚函数，而不是根据指针或引用的类型。

----------


**底层原理：**

在底层，虚函数的实现依赖于虚函数表（VTable）和虚指针（VPtr）。

**虚函数表（VTable）**：对于包含虚函数的类，编译器会为该类创建一个虚函数表。虚函数表是一个包含了虚函数指针的数组，每个虚函数对应一个表项。每个类只有一个虚函数表，不管有多少个对象实例。*虚函数表在编译阶段就确定，并在程序运行时使用*。

**虚指针（VPtr）**：对于包含虚函数的类，每个对象都会有一个虚指针，用于指向该对象所属类的虚函数表。这个虚指针通常是隐藏的，存储在对象的内存布局的开始位置。通过虚指针，程序可以在运行时找到正确的虚函数表，从而实现动态绑定。

当调用一个虚函数时，程序会根据对象的虚指针找到对应的虚函数表，然后根据函数在虚函数表中的索引找到正确的函数实现并调用。这就是C++中虚函数实现多态性的底层原理。

需要注意的是，虚函数的使用会引入虚函数表和虚指针，略微增加了对象的内存开销和函数调用的性能损耗，但对于大多数情况而言，这种开销是可以接受的，并且带来了更强大的代码组织和设计能力。


## 95.一个函数f(int a,int b)，其中a和b的地址关系是什么？
a和b的地址是相邻的。


## 96.移动构造和拷贝构造的区别是什么？
**移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交**，在一些特定场景下，可以减少不必要的拷贝。

比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。而**拷贝构造则是将传入的对象复制一份然后放进新的内存中**。

## 97.(☆)lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？
所谓捕获列表，其实可以理解为参数的一种类型，**lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用**。 根据传递的行为，捕获列表也分为以下几种：

1. **值捕获**：
与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝

2. **引用捕获：**
与引用传参类似，引用捕获保存的是引用，值会发生变化。

3. **隐式捕获**：
手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用 引用捕获或者值捕获。
总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：

	（1）[] 空捕获列表；
	（2）[name1, name2, …] 捕获一系列变量；
	（3）[&] 引用捕获, 让编译器自行推导捕获列表；
	（4）[=] 值捕获, 让编译器执行推导应用列表；



4. **容器for_each遍历中嵌入Lambda 表达式**：
利用stl中迭代写法for_each进行动态数组内元素奇偶数的判断。

[https://blog.csdn.net/Dasis/article/details/121372235](https://blog.csdn.net/Dasis/article/details/121372235)

----------


按值捕获和引用捕获，默认的引用捕获可能会导致悬挂引用，引用捕获会导致闭包包含一个局部变量的引用或者形参的引用，如果一个由lambda创建的闭包的生命周期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。解决方法是对个别参数使用值捕获。

[C++11：lambda表达式的陷阱](https://blog.csdn.net/zzhongcy/article/details/88019153?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-88019153-blog-121372235.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-88019153-blog-121372235.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6)

## 98.哈希碰撞的处理方法

**链地址法**：将所有的哈希地址相同的记录都链接在同一链表中

**开放定址法**：当遇到哈希冲突时，去寻找一个新的空闲的哈希地址（线性探测，平方探测）。

**多次哈希**：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数直到不发生冲突为止，虽然不易发生聚集，但是增加了计算时间。

**建立公共溢出区**：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。查找时，先从哈希表查，查不到再去公共溢出区查。


## 99.unordered_map 的扩容过程
当 `unordered_map` 中的元素数量 **达到桶的负载因子（0.75）时，会重新分配桶的数量** （通常会按照原有桶的数量 `*2` 的方式进行扩容，但是具体的增长策略也可以通过修改容器中的 `max_load_factor` 成员变量来进行调整），并 **将所有的元素重新哈希到新的桶中**。


> unordered_map是一个关联容器，存储key,value.其中元素并没有特别的次序关系.
> 
> 特点：
> 
> 1. 关联容器中的元素是通过主键（Key）而不是它们在容器中的绝对位置来引用的。
> 2. 无序（Unordered）无序容器通过 hash 表来组织它们的元素，允许通过主键快速地访问元素。
> 3. 映射（Map）每个元素为一个值（Mapped value）绑定一个键（Key）：以主键来标志主要内容等于被映射值的元素。
> 4. 键唯一（Unique keys）容器中不存在两个元素有相同的主键。
> 5. 能够感知内存分配器的（Allocator-aware）容器使用一个内存分配器对象来动态地处理它的存储需求。
> 
> 在 unordered_map 内部，元素不会按任何顺序排序，而是通过主键的 hash 值将元素分组放置到
> 各个槽（Bucket，也可译成“桶”）中，这样就能通过主键快速地访问各个对应的元素（平均耗时为一个常量，即时间复杂度为 O(1)）。


## 100.vector如何判断应该扩容？（size和capacity）
由当前容器内元素数量的大小和容器最大大小进行比较如果二者相等就会进行扩容，一般是1.5倍，部分的有两倍

## 101.构造函数是否能声明为虚函数？为什么？
构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的 `vptr` 指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找 `vptr` ，但此时 `vptr` 还没有完成初始化，导致无法构造对象。

## 102.类中static函数是否能声明为虚函数？
不能，因为类中的 `static` 函数是所有类实例化对象所共有的，没有 `this` 指针，而虚函数依靠 `vptr` 和 `vtable` 来处理，`vptr` 是一个指针，在类中的构造函数中生成，并且只能通过 `this` 指针访问，对于静态成员函数来说，他没有 `this` 指针，无法访问 `vptr`，因此 `static` 函数无法声明为虚函数.

## 103.(☆)哪些函数不能被声明为虚函数？
常见的不不能声明为虚函数的有：**普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。**

**普通函数(非成员函数)**:多态依托于类实现，因此普通函数不可被声明为虚函数

**构造函数**:虚表指针在构造函数中初始化，而虚函数保存在虚表中，调用虚函数时需要通过虚表指针找到虚函数;
若构造函数是虚函数，则调用构造函数需要先得到虚表指针，而虚表指针又需要在构造函数中初始化，矛盾

**内联成员函数**:内联函数在编译时被展开，而多态是运行时多态，也就是运行时才确定要调用哪个虚函数，矛盾

**静态成员函数**:虚函数保存在虚表中，调用虚函数时需要通过 this 指针得到虚表指针，再通过虚表指针找到虚函数,而静态函数不传入 this 函数，因此不可声明为虚函数

**友元函数**:对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。


## 104.(☆)如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）
将构造函数设置为私有，这样只能使用new运算符来建立对象，但是我们必须准备一个destory函数来进行内存的释放，然后将析构函数设置为 protected，提供一个 public 的 static 函数来完成构造，类似于单例模式

如果在栈上分配呢？则是重载 new 操作符，使得 new 操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配.


## 105.C/C++堆和栈的区别

**1.生命周期不同**
	
	堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。

	栈：由编译器（Compiler）自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。

**2.申请方式不同**

	堆：程序中要分配一个堆空间可以使用 new（new 这是 C++中专用的关键字） 关键字、malloc 函数， calloc()函数， realloc 函数实现;
	当不再需要这个堆空间时，可以使用 delete（delete 这是 C++中专用的关键字） 关键字、 free 函数完成释放工作。

	栈：由系统自动分配。只要是局部变量 ，操作系统自动在栈中其开辟空间。比如在 main 函数中定义一个变量 int b,则 b 使用的空间就是栈空间。

**3.底层实现机制不同**

	堆：堆的生长方向是向上生长，内存地址由低到高,一般是通过链表进行存储空间管理，内存上可以是不连续的。

	栈：栈的生长方向是向下生长（有的系统可能是向上生长），，内存地址由高到低。且在使用上， 空间是连续的。

**4.申请空间大小上限不同**

	堆：堆的大小受限于计算机系统中有效的虚拟内存。在 32 位系统上，其大小可以达 4G，使用起来比较灵活。

	栈：在 Windows 下，栈的大小是固定的（是一个编译时就确定的常数），所以程序员不适合在函数内申请过多的栈空间，否则可能会导致程序栈溢出。

**5.内存利用率不同**

	堆：堆空间的申请分配一般是随机的，不连续的内存空间， 容易产生内存碎片。

	栈：由系统自动分配，速度较快，但程序员是无法控制的。

**6.分配方式不同**

	堆：都是动态分配的，没有静态分配的堆。
	
	栈：有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配;动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

[https://www.jb51.net/article/215546.htm](https://www.jb51.net/article/215546.htm)


## 106.讲讲你理解的虚基类

[https://www.cnblogs.com/DOTA-SPE/p/15920853.html](https://www.cnblogs.com/DOTA-SPE/p/15920853.html)

虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。

为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。

**虚基类只能被实例化一次**--->虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。

虚基类子对象是由**最远派生类的构造函数**(在继承结构中建立对象时所指定的类)通过调用虚基类的构造函数进行初始化的。

 派生类的构造函数的成员初始化列表中**必须列出对虚基类构造函数的调用**；如果未列出，则表示使用该虚基类的**缺省构造函数**。


在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，<font color="#F100">虚基类的构造函数先于非虚基类的构造函数执行。</font>

## 107.C++哪些运算符不能被重载？
**成员访问运算符`.`**，**指针运算符 `.*`**，**域解析操作符`::`**，**条件运算符`?:`**,**长度运算符 `sizeof`**之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。

    .* 和 ->* 返回表达式左侧所指定的对象的特定类成员的值


## 108.动态链接和静态链接的区别，动态链接的原理是什么？
**区别**：他们的最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。

**静态库**：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。

**动态库**：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。

**动态链接原理**：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件

## 109.C++中怎么编译C语言代码？
需要使用 C++ 的外部链接功能，即 `extern "C"`。这告诉 C++ 编译器，被这个声明的函数或变量是用 C 的方式进行链接的。

## 110.初始化全局变量和未初始化全局变量有什么区别？
[https://blog.csdn.net/qq_70799748/article/details/130712416](https://blog.csdn.net/qq_70799748/article/details/130712416)

全局变量初始化而且初始值不为0，那么这样的全局变量是放在内存的**.data段**的，如果全局变量初始值为0或者未初始化，那么这样的全局变量是放在**.bss**（Block Started By Symbol）段的。

<font color="#F100">未初始化的全局变量的默认值是 0，而未初始化的局部变量的值却是垃圾值（任意值）。</font>

内存中运行着很多程序，我们的程序只占用一部分空间，这部分空间又可以细分为以下的区域：

**1.程序代码区**：存放函数体的二进制代码。

**2.静态数据区(data area)**：也称全局数据区,包含的数据类型比较多，如全局变量、静态变量、一般常量、字符串常量

(1)全局变量区和静态变量区的存储是返回在一块的，初始化的全局变量和静态变量在一块区域。未初始化的全局变量和未初始化的静态变量在相邻的另一区域。

(2)常量区域包括字符串常量和一般常量存储在另一区域

注意：静态区的内存在程序结束后由系统释放。

**3.堆区**：一般由程序员分配和释放，若程序员不释放，则程序运行结束后由系统回收。malloc(),calloc(),free()，操作的就是这块内存。

注意：这里的堆区不同于数据结构的堆，堆区的分配方式倒是和数据结构的链表比较相似。

**4.栈区**：由系统自动分配释放，存放函数的参数值和局部变量的值等。其操作方式类似于数据结构中的栈。

**5.命令形参区**：存放命令型参数和环境变量的值，如通过`main()`传递的值。


## 111.说一下内联函数及其优缺点

**每调用一次函数,都要为其分配一片栈空间(栈帧)。**并且在函数调用的时候，需要跳转到函数所在的位置，这是需要做很多的准备——比如: 记录程序执行的位置,状态等。因此，**函数调用是有一定时间开销的。**

内联函数是在编译期将函数体内嵌到程序之中，以此来节省函数调用的开销。

**优点**：调用函数是不需要给函数分配占空间，不需要跳转。节省了函数调用的开销，让程序运行更加快速。

**缺点**：内联函数函数体占用的是调用者的栈空间，如果函数体过长，频繁使用内联函数会导致代码编译膨胀问题。不能递归执行。

[https://blog.csdn.net/weixin_61084441/article/details/128776893](https://blog.csdn.net/weixin_61084441/article/details/128776893)


## 112.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

`auto` 仅仅只是一个占位符，在编译期间它会被真正的类型替代，或者说 C++ 中变量必须要有明确类型的，只是这个类型是由编译器自己推导出来的。
使用auto可以提高代码的简洁性和易读性，并减少一些显式类型声明的工作。

1. auto 不能用于函数参数
1. auto 不能用于非静态成员变量
1. auto 无法定义数组
1. 实例化模板时不能使用 auto 作为模板参数。 

函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式具体类型函数的模具，所以模板其实就是将原本应该我们做重复的事情交给了编译器。