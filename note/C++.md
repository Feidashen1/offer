## 1.C和C++的区别
**设计思想上：** C++是面向对象的语言，而C是面向过程的结构化编程语言。

**语法上：**

C++具有封装、继承和多态三大特性。

C++相比较C，增加了许多类型安全的功能，比如强制类型转换、智能指针。

C++支持泛型编程，比如模板类，函数模板等。


## 2.构造函数后面的冒号有什么用？
在构造函数后面加冒号，表示冒号后面接构造函数初始化列表（constructor initialize list），主要有三种应用场景：

1. 对基类进行初始化;
2. 对类成员进行初始化;
3. 对类的const成员变量进行初始化;

由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或者使用初始化列表赋值。


## 3. 函数后面 = default 和 = delete 有什么用？
[http://t.csdnimg.cn/hUk79](http://t.csdnimg.cn/hUk79 "http://t.csdnimg.cn/hUk79")

`=defalut`使得被修饰的函数为编译器默认的形式。只能用于（类的）特殊的成员函数（默认构造函数，复制构造函数，析构函数等）。

`=delete`使得编译器禁止该类型的成员函数生成。例如：1.禁用拷贝构造函数；2.禁用不需要用的参数转换。

对特殊成员函数使用以上修饰符使得代码更容易阅读。


## 4.类的大小和什么有关系？

平时所声明的类只是一种类型定义，它本身是没有大小可言的。

这里所说的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。

类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员均对类的大小无影响。


<font color="#F100">静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类的所有对象共享，并不属于哪个对象。</font>

虚函数对类的大小有影响，是因为虚函数表指针带来的影响；
虚继承对类的大小有影响，是因为虚基表指针带来的影响。

[http://t.csdnimg.cn/FR01C](http://t.csdnimg.cn/FR01C "http://t.csdnimg.cn/FR01C")
**c++空类（这个类不带任何数据）的大小不为0，为1。**


因为：new需要分配不同的内存地址，不能分配内存大小为0的空间，避免除以 sizeof(T)时得到除以0错误，故使用一个字节来区分空类。

## 5.struct 和 typedef struct 什么区别？
C ：

	typedef struct student {
		int a;
	}Stu;

这时声明变量就可以：`Stu stu1;`
如果上面没有加 `typedef` 就必须用 `struct student stu1` 来声明。这里的 `Stu` 实际上就是 `struct Student` 的别名。
另外这里也可以不写 `Student typedef struct {}Stu`; 那声明变量的时候就不能`struct Student stu1;`了只能`Stu stu1;`）


C++:

1. `struct name {int a;}stu;` 这里 `stu` 是一个变量。
2. `typedef struct name{int a;}stu;`这里的 `stu` 是一个结构体类型。


## 6.函数后面加const
`const` 只能加在类的成员函数后面（普通函数不可以），也就是说这些成员函数是只读函数。

1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）

2、加了cosnt的成员函数，表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）
非静态成员函数后面加 `const` 和 `mutable` 是反义词


加了 `const` 的成员函数可以被 非const对象 和 const对象调用。**注意是对象**。

但不加 `const` 的成员函数只能被 非const对象 调用。

<font color="#A100">函数前面加 cosnt 表示返回值是 const，函数后面加 const 表示不可以修改 class 的成员。</font>



## 7.共享数据的保护
1.常引用：所引用的形参不能被更新

	void display(const double& a);

2.常对象：在生存期内不能被更新，但必须被初始化

	A const a(3, 4);

3.常成员函数：不能修改对象中数据成员，也不能调用类中没有被const修饰的成员函数（常对象唯一的对外接口）。如果声明了一个常对象，则该对象只能调用它的常函数！另外，可以用于对重载函数的区分。

	void print();
	void print() const;

4.extern int a;使得其他文件也能访问该变量

声明一个函数或定义函数时，冠以 `static` 的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数（每一个cpp文件就是一个编译单元）


## 8.运算符重载注意
单目运算符最好重载为成员函数，双目最好为友元函数。

`=、[]`只能重载为成员函数，`<<`和`>>`只能重载为友元函数。


## 9.程序内存分配方式以及它们的区别
内存分配大致上可以分成5块：

1. **栈区（stack）**：栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）
1. **堆区（heap）**：一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆时两回事，分配方式类似于链表。
1. **全局区（静态区）（static）**：全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
1. **常量存储区**：常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
1. **程序代码区**：存放函数体的二进制代码。


## 10.全局变量、全局静态变量、静态变量、静态函数

### 全局静态变量和全局变量的区别
1.若程序由一个源文件构成时，全局变量与全局静态变量没有区别；

2.若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即全局静态变量对组成该程序的其他源文件时无效的；

3.具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。

静态变量只被所属源文件使用。


### static的作用
**1、全局静态变量**

在全局变量前加上关键字 `static`，全局变量就被定义成一个全局静态变量。

**存放区**：存放在静态存储区，在整个程序运行期间一直存在。

**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

**作用域**：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

**2、局部静态变量**

在局部变量前加上关键字 `static`，局部变量就被定义成一个局部静态变量。

**存放区**：静态存储区。

**初始化**：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

**作用域**：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

**3、静态函数**

在函数返回类型前加 `static`，函数就被定义为静态函数。函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。
这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**warning**：（没懂）不要在头文件中声明 `static` 的全局函数，不要在cpp内声明 非static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中去，否则cpp内部声明需加上static修饰。

**4、类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**5、类的静态函数**
静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用 `class_name::static_func()` 就可以访问。

### 静态成员函数与普通成员函数的区别
静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）

普通成员函数有this指针，可以访问类中的任意成员（普通成员变量和静态成员变量，好像静态成员函数没有this指针不能通过this访问，但是可以通过类名::访问）；而静态成员函数没有this指针。


## 11.new delete 与 malloc free的联系与区别
`new delete `和 `malloc free`都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄漏或者二次释放。

不同的是，`new delete`是C++`中定义的操作符`，`new` 除了分配空间外，还会调用类的构造函数来完成初始化工作，delete 除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。


## 12.explicit
`explicit` 关键字只能用于类的构造函数的声明上。它的作用是防止构造函数进行的隐式转换。

在C++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担了两个角色：

第一是构造；

第二是默认且隐含的类型转换操作符。即如果构造函数接收到的参数会默认进行隐式转换。

隐式转换看起来很方便，但是某些情况下违背了程序员的本意。这个时候就要加上explicit修饰，指定这个构造器只能被明确的调用/使用，不能进行隐式转换。

	class A
	{
	public:
	    explicit A(int a, int b) : m_a(a), m_b(b) {};
	private:
	    int m_a;
	    int m_b;
	}
	
	int main()
	{
	    A test(1, 2); //正确
	    A test1(2.2, 2); // 错误，存在double->int的隐式转换。
	}


## 13.c++的四种 cast 转换
cast转换是C++的强制转换：`cast-name<target_type>(expression);`

1、`const_cast`
唯一一个可以改变const性质的转换

2、`static_cast`
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

3、`dynamic_cast`
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果时非法的对于指针返回 `null`，对于引用抛出异常。要深入理解内部转换的原理。

向上转换：指的是子类向基类的转换。
向下转换：指的是基类向子类的转换。

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、`reinterpret_cast`
几乎什么都可以转，可能会出问题，尽量少用。

## 14.为什么不用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

C的强制转换 `(type_name)expression`



## 15.mutable关键字
`mutable` 的中文意思时可变的、易变的，跟 constant（即C++里的const）是反义词。在C++中，mutable 也是为了突破 const 的限制而设置的。被 mutable 修饰的变量（**`mutable`只能用于修饰类的非静态数据成员**），将永远处于可变的状态（可以修改成员数据之类的），即使在一个const函数中。

## 16.用const修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 `const` 修饰，那么函数返回值（即指针）的内容不能修改，且该返回值只能被赋给加 `const` 的同类型指针。一般只在返回值为引用或指针时使用，返回其他值时没有必要。

	const char* get_string(void);
	char *str = get_string();//编译报错
	const char *str = get_string();//正确

## 17.宏、const、enum
`#define`不被视为语言的一部分（#define属于预处理器）。

对于单纯常量，最好用 `const` 对象或者 `enum` 替换`#define`。

对于类似函数的宏，尽量使用内联函数替换掉 `#define`


**编译器处理方式不同**: `define` 宏是在预处理阶段展开; `const` 常量是在编译运行阶段使用。

**类型**：
`define` 宏没有类型，不做任何类型检查，仅仅是展开；
`const` 常量没有具体的类型，在编译阶段会执行类型检查。

**起作用的方式**：`#define` 只是简单的字符串替换，没有类型检查。而 `const` 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。正因为 `define` 只是简单的字符串替换，会导致边界效应，很容易犯错。

	#define N 2+3
	const double a = N/2; //结果是2+3/2 = 2+1 = 3
	const double b = (double)N / (double)2;
	//我们预想的答案是2.5，可实际输出的值是2 + 3 / 2 = 3.5


**占用空间**：
`define` 宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，占用代码段空间；
`const` 常量会在内存中分配（可以是在堆中也可以是在栈中） 占用数据段空间

**调试角度**：
`const` 常量是可以进行调试的，`#define` 不能进行调试，因为在预编译阶段就已经替换掉了。

**作用域**：`const` 变量是由作用域的，`#define` 在没有遇到 `#undefine` 之前是没有作用域限制的。

## 18.程序编译
程序编译是指将源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。便已产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。

## 19.class 和 struct 的区别
c++中，class 和 struct 都可以定义一个类。
它们有以下两点区别：

1、默认继承权限，如果不指定，来自 class 的继承按照 private 继承处理，来自struct 的继承按照 public 继承处理。

2、成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是public权限。

<<<<<<< HEAD
## 20.C++ 默认编写并调用了哪些函数
编译器会主动为用户编写的任何类声明一个拷贝构造函数、拷贝复制操作符和一个析构函数，同时如果声明生命任何构造函数，编译器也会为你声明一个 `default` 版本的拷贝构造函数，这些函数都是 `public` 且 `inline` 的。

注意，上边说的是声明，只有当这些函数有调用需求的时候，编译器才会帮你去实现它们。但是编译器替你实现的函数可能在类内引用、类内指针、有const成员以及类型有虚属性的情形下会出问题：

1. 对于拷贝构造函数，要考虑到类内成员有没有深拷贝的需求，如果有的话就需要自己编写拷贝构造函数/操作符，而不是把这件事情交给编译器来做。
1. 对于拷贝构造函数，如果类内有引用成员或 `const` 成员，需要自己定义拷贝行为，因为编译器替你实现的拷贝行为在上述两个场景很有可能是有问题的。
1. 对于析构函数，如果该类有多态需求，请主动将析构函数声明为 `virtual`

## 21.为多态基类声明 virtual
带有多态性质的基类必须将析构函数声明为虚函数，防止指向子类的基类指针在被释放时只局部销毁了该对象。

如果一个类有多态的内涵，那么几乎不可避免的会有基类的指针（或引用）指向子类对象，因为非虚函数没有动态类型，所以如果基类的析构函数不是虚函数，那么在基类指针析构时会直接调用基类的析构函数，造成子类对象仅仅析构了基类的那一部分，有内存泄漏的风险。

除此之外，还需注意：

1. 需要注意的是，普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价。
1. 如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为 `final` （C++ 11），这样禁止派生可以防止误继承造成上述问题。
1. 编译器自动生成的析构函数时非虚的，所以多态基类必须将析构函数显示声明为virtual。


## 22.禁止使用编译器自动生成的函数
如果类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么就应该禁止编译器去自动生成它：

1. 将被禁止生成的函数声明为 `private` 并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。
1. 将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。
2. C++11可以直接使用 `= delete` 来声明拷贝构造函数，显示禁止编译器生成该函数。


## 23.别让异常逃离析构函数
析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。

析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明抛出异常后的代码无法再继续执行，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃。

在析构函数中只负责记录，需要时刻保证析构函数能够执行到底


## 24.不要在构造和析构过程中调用 virtual 函数
在多态环境中，需要重新理解构造函数和析构函数的意义，这两个函数在执行过程中，涉及到了对象类型从基类到子类，再从子类到基类的转变。

一个子类对象开始创建时，首先调用的是基类的构造函数，在调用子类构造函数之前，**该对象将一直保持着“基类对象”的身份而存在**，自然在基类的构造函数中调用的虚函数——将会是基类的虚函数版本，在子类的构造函数中，**原先的基类对象变成了子类对象**，这时子类构造函数里调用的是子类的虚函数版本。

这是一件有意思的事情，这说明**在构造函数中虚函数并不是虚函数**，在不同的构造函数中，调用的虚函数版本并不同，因为随着不同层级的构造函数调用时，对象的类型在实时变化。那么相似的，析构函数在调用的过程中，子类对象的类型从子类退化到基类。


因此，如果无法在基类的构造函数中调用子类的虚函数。


## 25.在 operator= 中处理“自我赋值”
自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要假借指针来实现：

	*pa = *pb;		 			//pa和pb指向同一对象，便是自我赋值。
	arr[i] = arr[j];		//i和j相等，便是自我赋值


那么对于管理一定资源的对象重载的 `operator =`  中，一定要对是不是自我赋值格外小心并且增加预判，因为无论是深拷贝还是资源所有权的转移，原先的内存或所有权一定会被清空才能被赋值，如果不加处理，这套逻辑被用在自我赋值上会发生——先把自己的资源给释放掉了，然后又把以释放掉的资源赋给了自己——出错了

第一种做法是在赋值前增加预判，但是这种做法没有异常安全性，试想如果在删除掉原指针指向的内存后，在赋值之前任何一处抛出了异常，那么原指针就指向了一块已经被删除的内存。
    
    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      if (this == &rhs) return *this;
      
      delete ptr;	
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr将指向一块已经被删除的内存。
      return *this;
    }


如果我们把异常安全性也考虑在内，那么我们就会得到如下方法，令人欣慰的是这个方法也解决了自我赋值的问题。

    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      DataBlock* pOrg = ptr;
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr仍然指向之前的内存。
      delete pOrg;
      return *this;
    }



另一个使用copy and swap技术的替代方案。


## 26.复制对象时勿忘其每一个成分

当你给类多加了成员变量时，不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果忘记处理，编译器也不会报错。

如果类有继承，那么在为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是 `private` 的，所以无法访问它们，应该让子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数：

    //在成员初始化列表显示调用基类的拷贝构造函数
    ChildClass::ChildClass(const ChildClass& rhs) : BaseClass(rhs) {		
      	// ...
    }


除此之外，拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个。

其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此**前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。**


## 27.设计 class 犹如设计 type
每次设计class时最好在脑中过一遍以下问题：

1. 对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。
1. 对象的构造函数与赋值行为应有何区别：构造函数和赋值操作符的区别，重点在资源管理上。
1. 对象被拷贝时应考虑的行为：拷贝构造函数。
1. 对象的合法值是什么？最好在语法层面、至少在编译前应对用户做出监督。
1. 新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。
1. 新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非explicit函数之间的取舍。
1. 新类型是否需要重载操作符。
1. 什么样的接口应当暴露在外，而什么样的技术应当封装在内（public和private）
1. 新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。
1. 这个类是否具备template的潜质，如果有的话，就应改为模板类。


## 28.函数接口应该以const引用的形式传参，而不应该是按值传参

1. 按值传参涉及大量参数的复制，这些副本大多是没有必要的。
1. 如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。
1. 对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。
1. 小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。


## 29.对class内所有成员变量声明为private，private意味着对变量的封装

简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是private了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是语法一致性；其次，对变量的封装意味着，**可以尽量减小因类型内部改变造成的类外外代码的必要改动**。

**public 和 protected属性在一定程度上是等价的**。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种——用这个类创建对象或者继承这个类以设计新的类——以下简称为第一类客户和第二类客户。

从封装的角度来说，一个 public 的成员说明了类的作者决定对类的第一种客户不封装此成员，而一个 protected 的成员说明了类的作者对类的第二种客户不封装此成员。


## 30.若所有参数皆需类型转换，请为此采用non-member函数

如果我们在使用操作符时希望操作符的任意操作数都可能发生隐式类型转换，那么应该把该操作符重载成非成员函数。

首先说明：**如果一个操作符是成员函数，那么它的第一个操作数（即调用对象）不会发生隐式类型转换。**

操作符一旦被设计为成员函数，它在被使用时的特殊性就显现出来了——单从表达式无法直接看出是类的哪个对象在调用这个操作符函数

做为成员函数的操作符默认操作符的第一个操作数应当是正确的类对象——**编译器根据第一个操作数的类型来确定被调用的操作符到底属于哪一个类的**。

举例说明：当 `Ratinoal` 类的构造函数允许 `int` 类型隐式转换为 `Rational` 类型时，`Rational z = x + 2;`是可以通过编译的，因为操作符是被 `Rational` 类型的 `x` 调用，同时将 `2` 隐式转换为 `Ratinoal` 类型，完成加法。但是 `Rational z = 2 + x;`却会引发编译器报错，因为由于操作符的第一个操作数不会发生隐式类型转换，所以加号“+”实际上调用的是`2`——一个 `int` 类型的操作符，因此编译器会试图将 `Rational` 类型的 `x` 转为 `int`，这样是行不通的。


## 31.子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口
在确定是否需要public继承的时候，我们首先要搞清楚子类是否必须拥有父类每一个特性，如果不是，则无论生活经验是什么，都不能视作”is-a”的关系。**public 继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。**


## 32.避免遮掩继承而来的名称
在父类中，虚函数`foo()`被重载了两次，可能是由于参数类型重载（`foo(int)`），也可能是由于`const`属性重载(`foo() const`)。如果子类仅对父类中的`foo()`进行了覆写，那么在子类中父类的另外两个实现(`foo(int) ,foo() const`)也无法被调用，这就是名称遮盖问题——名**称在作用域级别的遮盖是和参数类型以及是否虚函数无关的**，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖。

如果想要重启父类中的函数名称，需要在子类有此需求的作用域中（可能是某成员函数中，可能是 `public` 或 `private` 内）加上 `using Base::foo;`，即可把父类作用域汇总的同名函数拉到目标作用域中，需要注意的是，此时父类中的`foo(int)`和`foo() const`都会被置为可用。

如果只想把父类某个在子类中某一个已经不可见的同名函数复用，可使用`inline forwarding function`。


## 33.区分接口继承和实现继承
成员函数的接口总是会被继承，而public继承保证了，如果某个函数可施加在父类上，那么他一定能够被施加在子类上。不同类型的函数代表了父类对子类实现过程中不同的期望。

- 在父类中声明纯虚函数，是为了**强制子类拥有一个接口，并强制子类提供一份实现。**
- 在父类中声明虚函数，是为了**强制子类拥有一个接口，并为其提供一份缺省实现。**
- 在父类中声明非虚函数，是为了**强制子类拥有一个接口以及规定好的实现，并不允许子类对其做任何更改**。

在这其中，有可能出现问题的是普通虚函数，这是因为*父类的缺省实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应从代码层面提醒子类的设计者做相应的检查_，很可惜，普通虚函数无法实现这个功能*。***一种解决方案是，在父类中为纯虚函数提供一份实现，作为需要主动获取的缺省实现***，当子类在实现纯虚函数时，检查后明确缺省实现可以复用，则只需调用该缺省实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查缺省实现的适用性。

将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者**在于从编译层面提醒子类主动实现接口**，后者则侧重于**给予子类自由度对接口做个性化适配**。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，
**保证所有继承体系内能有其一份实现**。


## 34.不重新定义继承而来的non-virtual函数

如果函数有多态调用的需求，一定记得把它设为虚函数，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。

反之同理，如果一个函数父类没有设置为虚函数，你千万千万不要在子类重载它，也会犯上边类似的错误。

理由就是，多态的动态调用中，只有虚函数是动态绑定，非虚函数是静态绑定的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。

话说回来，**虚函数的意思是“接口一定被继承，但实现可以在子类更改”，而非虚函数的意思是“接口和实现都必须被继承”。**


## 35.绝不重新定义继承而来的缺省参数值
在继承中：

1. 不要更改父类非虚函数的缺省参数值，其实不要重载父类非虚函数的任何东西，不要做任何改变！
1. 虚函数不要写缺省参数值，子类自然也不要改，虚函数要从始至终保持没有缺省参数值。
> 
> 缺省参数是 声明或定义函数 时为函数的 形参指定一个缺省值（默认参数）。

虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的缺省参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。

缺省参数值属于静态绑定的原因是为了提高运行时效率。


## 36.类的复合：一个类的对象可以作为另一个类的成员

什么情况下我们应该用类的复合:

第一种情况，非常简单，说明某一个类“拥有”另一个类对象作为一个属性，比如学生拥有铅笔、市民拥有身份证等，不会出错。

第二种情况被讨论的更多，即“一个类根据另一个类实现”。比如“用stack实现一个queue”，更复杂一点的情况可能是“用一个老版本的Google Chrome内核去实现一个红芯浏览器”。



## 37.审慎地使用private继承
private继承正是表达“通过某工具类实现另一个类”。那么相似的，工具类在目标类中自然应该被隐藏——所有接口和变量都不应对外暴露出来。这也解释了private继承的内涵，它本质是一种__技术封装__，和public继承不同的是，private继承表达的是“**只有实现部分被继承，而接口部分应略去”的思想。**

与private继承的内涵相对应，**在private继承下，父类的所有成员都转为子类私有变量——不提供对外访问的权限**，外界也无需关心子类内有关父类的任何细节。


当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与private继承中做选择呢？


尽可能用复合，除非必要，不要采用private继承。
当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择private继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。


## 38.少使用多继承

原则上不提倡使用多继承，因为多继承可能会引起多父类共用父类，导致在底层子类中出现多余一份的共同祖先类的拷贝。为了避免这个问题C++引入了虚继承，但是虚继承会使子类对象变大，同时使成员数据访问速度变慢，这些都是虚继承应该付出的代价。

## 39.讲一讲封装、继承、多态是什么？
**封装**：将具体实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性，使类成为一个具有内部数据的自我隐藏能力、功能独立的软件模块。

**意义**：保护或防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。


----------


**继承**：子类继承父类的特征和行为，复用了基类的全体数据和成员函数，具有从基类复制而来的数据成员和成员函数（基类私有成员可被继承，但是无法被访问），其中构造函数、析构函数、友元函数、静态数据成员、静态成员函数都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员变量不能重写或修改。

> 如果对一个类或者虚函数使用 final 关键字，则代表不允许再对其内容进行修改:
>  对类使用final关键字，代表它不可以作为基类被继承；
>  对虚函数使用final关键字，代表它不可以在子类中被重写。

**意义**：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期

----------

**多态**：不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。

**意义**：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。


## 40.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？
**实现方式**：多态分为**动态多态**（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和**静态多态**（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数）。

其中动态多态是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做**虚函数表**，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。

> 虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。 
虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说**在代码的编译阶段，虚表就可以构造出来了。**

>**虚表是属于类的，而不是属于某个具体的对象**，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。
><font color="#A100">对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数。</font>


>[虚函数表详解](http://t.csdnimg.cn/sJZb5 "虚函数表详解")

而静态多态则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。**隐藏只与函数名有关，与参数没有关系**）来实现的。

**优点**：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。


## 41.什么时候会执行函数的动态绑定？
符合以下三个条件：

1. 通过指针来调用函数
1. 指针upcast向上转型（继承类向基类的转换称为upcast）
1. 调用的是虚函数

如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的通过虚表的机制。

> "Upcasting"是面向对象编程中的一个概念，它指的是将一个子类对象的引用或指针转换为基类（也就是父类）类型的引用或指针。这种转换是安全的，因为子类对象是其基类对象的一个超集，这意味着子类对象包含其基类的所有成员。


## 42.动态绑定的流程

1. 取出类的虚函数表的地址
1. 根据虚函数表的地址找到虚函数表
1. 根据找到的虚函数的地址调用虚函数。

[C++虚函数表：让多态成为可能的关键](https://blog.csdn.net/qq_21438461/article/details/126362661https://blog.csdn.net/qq_21438461/article/details/126362661)

## 43.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的？
在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针

**虚函数表**：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。

**虚函数指针**：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。

当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。

## 44.智能指针的本质是什么，它们的实现原理是什么？
智能指针就是帮C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而避免内存泄漏。

智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。

实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。

[C++ 智能指针 - 全部用法详解](https://blog.csdn.net/cpp_learner/article/details/118912592?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171379580616800197099831%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171379580616800197099831&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118912592-null-null.142^v100^pc_search_result_base3&utm_term=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&spm=1018.2226.3001.4187)

`auto_ptr`：c++ 98定义的智能指针模板，定义了管理指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用delete 来释放内存。

头文件: `#include <memory>`；用法：`auto_ptr<类型> 变量名(new 类型)`

C++11 后auto_ptr 已经被“抛弃”，已使用 `unique_ptr` 替代！C++11后不建议使用auto_ptr(原因)：
1). 复制或者赋值都会改变资源的所有权；
2). 在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制和可赋值；
3). 不支持对象数组的内存管理


----------

智能指针的三个常用函数：

1. get() 获取智能指针托管的指针地址
1. release() 取消智能指针对动态内存的托管
2. reset() 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉

----------


`unique_ptr`：unique_ptr 和 auto_ptr 用法几乎一样，除了一些特殊

特性：

1. 基于排他所有权模式：两个指针不能指向同一个资源
1. 无法进行左值unique_ptr复制构造，也无法进行左值复制赋值操作，但允许临时右值赋值构造和赋值
1. 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
1. 在容器中保存指针是安全的

----------

`shared_ptr`：可以记录引用特定内存对象的智能指针数量，当复制或拷贝时，引用计数加1，当智能指针析构时，引用计数减1，如果计数为零，代表已经没有指针指向这块内存，那么就释放它。

1.引用计数的使用：

调用 `use_count` 函数可以获得当前托管指针的引用计数。

2.构造

1). `shared_ptr<T> sp1;` 空的shared_ptr，可以指向类型为T的对象

2). `shared_ptr< T > sp2(new T());` 定义shared_ptr,同时指向类型为T的对象

3). `shared_ptr<T[]> sp4;` 空的shared_ptr，可以指向类型为T[]的数组对象 C++17后支持

4). `shared_ptr<T[]> sp5(new T[] { … });` 指向类型为T的数组对象 C++17后支持

5). `shared_ptr< T > sp6(NULL, D());` 空的shared_ptr，接受一个D类型的删除器，使用D释放内存

6).`shared_ptr< T > sp7(new T(), D());`定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存

3.初始化

1). 方式一：构造函数
	
	shared_ptr<int> up1(new int(10));  // int(10) 的引用计数为1
	shared_ptr<int> up2(up1);  // 使用智能指针up1构造up2, 此时int(10) 引用计数为2

2). 方式二：使用make_shared 初始化对象，分配内存效率更高(推荐使用)
make_shared函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr; 用法：

    make_shared<类型>(构造类型对象需要的参数列表);
	shared_ptr<int> up3 = make_shared<int>(2); // 多个参数以逗号','隔开，最多接受十个


4.赋值

	shared_ptrr<int> up1(new int(10));  // int(10) 的引用计数为1
	shared_ptr<int> up2(new int(11));   // int(11) 的引用计数为1
	up1 = up2;	// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2

5.主动释放对象
	
	shared_ptrr<int> up1(new int(10));
	up1 = nullptr ;	// int(10) 的引用计数减1,计数归零内存释放 
	// 或
	up1 = NULL; // 作用同上 

6.重置

`p.reset();` 将p重置为空指针，所管理对象引用计数减1

`p.reset(p1);` 将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控

`p.reset(p1,d); `将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器;p1是一个指针！

7.交换

p1 和 p2 是智能指针

	std::swap(p1,p2); // 交换p1 和p2 管理的对象，原对象的引用计数不变
	p1.swap(p2);    // 交换p1 和p2 管理的对象，原对象的引用计数不变

在使用shared_ptr智能指针时，要注意避免对象交叉使用智能指针的情况！ 否则会导致内存泄露！

----------

`weak_ptr` :设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。 同时 weak_ptr 没有重载`*`和`->`但可以使用 lock 获得一个可用的 shared_ptr 对象。

    shared_ptr<Girl> sp_girl;
	sp_girl = wpGirl_1.lock();

	// 使用完之后，再将共享指针置NULL即可
	sp_girl = NULL;

**expired**：判断当前weak_ptr智能指针是否还有托管的对象，有则返回false，无则返回true

<font color="A100">禁止delete 智能指针get 函数返回的指针：
如果我们主动释放掉get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放</font>


## 45.匿名函数的本质是什么？他的优点是什么？
匿名函数了，也叫做lambda表达式。

	[capture](parameters) specifiers exception attr -> return type { /*code; */ }
	[capture]代表捕获列表，括号内为外部变量的传递方式，包括值传递、引用传递等
	(parameters)代表参数列表，其中括号内为形参，和普通函数的形参一样
	specifiers exception attr代表附加说明符，一般为mutable、noexcept等
	->return type代表lambda函数的返回类型如 -> int、-> string等。在大多数情况下不需要，因为编译器可以推导类型
	{}内为函数主体，和普通函数一样




匿名函数本质上是一个**对象**，在其定义的过程中会创建出一个**栈对象**，内部通过重载()符号实现函数调用的外表。

**优点**：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。


## 46.右值引用是什么，为什么要引入右值引用？
右值引用是为一个临时变量取别名，它只能绑定到一个临时变量或表达式（将亡值）上。实际开发中我们可能需要对右值进行修改（实现移动语义时就需要）而右值引用可以对右值进行修改。


为什么：

1.为了支持移动语义，右值引用可以绑定到临时对象、表达式等右值上，这些右值在生命周期结束后就会被销毁，因此可以在右值引用中窃取其资源，从而避免昂贵的复制操作，实现高效的移动语义。

2.完美转发：右值引用可以绑定到任何类型的右值上，可以将其作为参数传递给函数，并在函数内部将其“转发”到其他函数中，从而实现完美转发。

3.拓展可变参数模板，实现更加灵活的模板编程。


> 左值准确来说是：一个表示数据的表达式(如变量名或解引用的指针），且可以获取他的地址（取地址），可以对它进行赋值；它可以在赋值符号的左边或者右边。

>右值准确来说是：一个表示数据的表达式（如字面常量、函数的返回值、表达式的返回值），且不可以获取他的地址（取地址）；它只能在赋值符号的右边。

>>>左值引用：给左值取别名；右值引用：给右值取别名

>左值引用只能引用左值；const左值引用可以左值，也可以引用右值（因为右值通常是不可以改变的值，所以用const左值引用是可以的）；右值只能引用右值；左值可以通过
>
>（左值）来转化为右值，继而使用右值引用。

	int main()
	{
		// 左值引用只能引用左值，不能引用右值。
		int a = 10;
		int& ra1 = a;   // ra1为a的别名
		//int& ra2 = 10;   // 编译失败，因为10是右值
	 
		// const左值引用既可引用左值，也可引用右值。
		const int& ra3 = 10;
		const int& ra4 = a;
	 
		 //右值引用只能右值，不能引用左值。
		int&& r1 = 10;
	 
	 
		int a = 10;
	    //message : 无法将左值绑定到右值引用
		int&& r2 = a;
	 
	 
		 //右值引用可以引用move以后的左值
		int&& r3 = std::move(a);
	 
		return 0;
	}


左值引用的意义在于:

1.函数传参：实参传给形参时，可以减少拷贝。

2.函数传返回值时，只要是出了作用域还存在的对象，那么就可以减少拷贝。

<font color="#A100">右值引用和左值引用减少拷贝的原理不一样：
左值引用是取别名，直接起作用；
右值引用是间接起作用，实现移动构造和移动赋值,在拷贝的场景中，如果是右值(将亡值)，转移资源

</font>


**右值是不能取地址的，但是给右值取别名后，会导致右值被存储到特定位置，且可以取到该位置的地址。（右值被右值引用以后就成为了左值）**

[【C++】右值引用（极详细版）](https://blog.csdn.net/ChaoFreeandeasy_/article/details/130229252?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171386931016800185849419%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171386931016800185849419&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-130229252-null-null.142^v100^pc_search_result_base9&utm_term=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&spm=1018.2226.3001.4187)


## 47.左值引用和指针的区别？

**是否初始化**：指针可以不用初始化，引用必须初始化

**性质不同**：指针是一个变量，引用是对被引用的对象取一个别名

**占用内存单元不同**：指针有自己的空间地址，引用和被引用对象占同一个空间。

## 48.指针是什么？
指针全名为指针变量，计算机在存储数据是有序存放的，为了能够使用存放的地址，就需要一个地址来区别每个数据的位置，指针变量就是用来存放这些地址的变量。

## 49.weak_ptr真的不计数？是否有计数方式，在哪分配的空间？
计数，控制块中有强弱引用计数

如果是使用 `make_shared` 初始化的函数则它所在的控制块空间是在所引用的 `shared_ptr` 中同一块的空间；

若是 `new` 则控制器所分配的内存与 `shared_ptr` 本身所在的空间不在同一块内存。


## 50.malloc 的内存分配的方式，有什么缺点？
malloc 并不是系统调用，而是C库中的函数，用于动态内存分配，在使用 malloc 分配内存的时候会有两种方式向操作系统申请堆内存:

**方式1**：当用户分配的内存小于128KB时通过 `brk()` 系统调用从堆分配内存；

**实现方式**：将堆顶指针向高地址移动，获取内存空间，如果使用 `free` 释放空间，并不会将内存归还给操作系统，而是会缓存在 `malloc` 的内存池中，待下次使用。

**方式2**：当用户分配的内存大于128KB时通过 `mmap()` 系统调用在文件映射区域分配内存；

**实现方式**为：使用私有匿名映射的方式，在文件映射区分配一块内存，也就是从文件映射区拿了一块内存，`free` 释放内存的时候，会把内存归还给操作系统，内存得到真正释放。

----------

**缺点**：容易造成内存泄漏和过多的内存碎片，影响系统正常运行，还得注意判断内存是否分配成功，而且内存释放后（使用free函数之后指针变量p本身保存的地址并没有改变），需要将 p 的赋值为 `NULL` 拴住野指针。


## 51.为什么不全部使用mmap来分配内存？
因为向操作系统申请内存的时候，是要通过系统调用的，执行系统调用要进入内核态，然后再回到用户态，状态的切换会耗费不少时间，所以申请内存的操作应该避免频繁的系统调用，如果都使用mmap来分配内存，等于每次都要执行系统调用。另外，因为mmap分配的内存每次释放的时候都会归还给操作系统，于是每次mmap分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候就会触发缺页中断。


> **缺页中断**：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。


>**缺页异常被触发通常有两种情况**：
>1.程序设计的不当导致访问了非法的地址；
2.访问的地址是合法的，但是该地址还未分配物理页框（malloc()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存）。


>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
>1、保护CPU现场
2、分析中断原因
3、转入缺页中断处理程序进行处理
4、恢复CPU现场，继续执行


>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
>1、在指令执行期间产生和处理缺页中断信号
2、一条指令在执行期间，可能产生多次缺页中断
3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

[简述缺页中断](https://blog.csdn.net/weixin_52669146/article/details/130589203)

## 52.为什么不全部都用brk？
如果全部使用brk申请内存那么随着程序频繁的调用malloc和free，尤其是小块内存，堆内将产生越来越多的不可用的内存碎片。

>通过调用brk系统调用，程序可以请求操作系统增加或减少它的堆空间，以动态地管理内存。

> brk() 函数是用来修改分配给调用者进程的内存量的。这种修改是通过改变进程的中断值到addr并提供必要的空间数量来实现的。
> 
> brk()函数用于修改分配给调用方进程的内存量。随着中断值的上升，分配的空间数量也在上升。新分配的空间有一个0的值分配给它。如果程序先减去然后再增加断点值，重新分配的空间的值就不会被清空。


## 53.传入一个指针，它如何确定具体要清理多少空间呢？
在申请内存的时候，会多分配**16字节**的内存，里面保存了内存块的详细信息，`free` 会对传入的内存地址向**左偏移16字节**，然后分析出当前内存块的大小，就知道要释放多大的内存空间了。

## 54.define和const的区别是什么？
**编译阶段**：define是在编译预处理阶段进行简单的文本替换，const是在编译阶段确定其值。

**安全性**：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查；const定义的常量是有类型的，是要进行类型判断的。

**内存占用**：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的内存；const定义常量占用静态存储区域的空间，程序运行过程中只有一份。

**调试**：define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量是可以进行调试的。


## 55.程序运行的步骤是什么
**预编译**：将头文件编译，进行宏替换，输出.i文件

**编译**：将其转化为汇编语言文件，主要做词法分析，语义分析以及检查错误，检查无误后将代码翻译成汇编语言，生成.s文件

**汇编**：汇编器将汇编语言文件翻译成机器语言，生成.o文件

**链接**：将目标文件和库链接到一起，生成可执行文件.exe


## 56.（☆）锁的底层原理是什么？
锁的底层是通过CAS，atomic 机制实现。

**CAS机制**：全称为Compare And Swap（比较相同再交换）可以将比较和交换操作转换为原子操作，CAS操作依赖于三个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存在内存之中。（就是每一个线程从主内存复制一个变量副本后，进行操作，然后对其进行修改，修改完后，再刷新回主内存前。再取一次主内存的值，看拿到的主内存的新值与当初保存的快照值，是否一样，如果不一样，说明有其他线程修改，本次修改放弃，重试。）

**atomic机制**：原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何切换到另一个线程。


## 57.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？
内存对齐是处理器为了提高处理性能而对存取数据的起始地址所提出的一种要求。

有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定的地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时将进行对齐，这就具有平台的移植性。

CPU每次寻址有时需要消耗时间的，并且CPU访问内存的时候并不是逐个字节访问，而是以字长为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐内存，处理器需要做多次内存访问，而对齐的内存访问可以减少访问次数，提升性能。

优：提高程序的运行效率，增强程序的可移植性。

## 58.（☆）进程之间的通信方式有哪些？
**管道**：管道分为匿名管道和命名管道，管道本质上是一个内核中的一个缓存，当进程创建管道后会返回两个文件描述符，一个写入端一个输出端。缺点：半双工通信，一个管道只能一个进程写，一个进程读。不适合进程间频繁的交换数据

**消息队列**：可以边发边收，但是每个消息体都有最大长度限制，队列所包含的消息体的总数量也有上限并且在通信过程中存在用户态和内核态之间的数据拷贝问题

**共享内存**：解决了消息队列存在的内核态和用户态之间的数据拷贝问题。

**信号量**：本质上是一个计数器，当使用共享内存的通信方式时，如果有多个进程同时往共享内存中写入数据，有可能先写的进程的内容被其他进程覆盖了，信号量就用于实现进程间的互斥和同步PV操作不限于信号量+-1，而且可以任意加减正整数

信号

套接字

## 59.（☆）线程之间的通信方式有哪些？


## 60.（☆）介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式



select、poll、epoll都是IO多路复用的一种机制，可以监视多个文件描述符，一旦某个文件描述符进入读或写就绪状态，就能够通知系统进行相应的读写操作。

----------

**Select优点**：可移植性好，因为在某些Unix系统中并不支持poll和epoll

对于超时时间提供了更好的精度：微妙，而poll和epoll都是毫秒级

**Select缺点**：支持监听的文件描述符 fd 的数量有限制，最大数量默认是1024个

Select 需要维护一个用来存放文件描述符的数据结构，每次调用 select 都需要把 fd 集合从用户区拷贝到内核区，而 select 系统调用后有需要把 fd 集合从内核区拷贝到用户区，这个系统开销在 fd 数量很多的时候会很大。



----------

**Poll优点（相对于select而言）**：没有最大文件描述符数量的限制，poll 基于链表存储主要解决了这个最大文件描述符数量的限制（当然，他还是有限制的，上限为操作系统能支持的能开启的最大文件描述符数量），优化了编程接口，减少了函数调用参数，并且，每次调用 select 函数时，都必须重置该函数的三个 fd_set 类型的参数值，而 poll 不需要重置。

**Poll缺点**：poll 和 select 一样同样都需要维护一个用来存放文件描述符的数据结构，当注册的文件描述符无限多时，会使得用户态和内核区之间传递该数据结构的复制开销很大。每次 poll 系统调用时，需要把文件描述符 fd 从用户态拷贝到内核区，然后 poll 系统调用返回前，又需要把文件描述符 fd 集合从内核区拷贝到用户区，这个内存拷贝的系统开销在fd数量很多的时候会很大。

----------

**Epoll优点**：和poll一样没有最大文件描述符数量的限制，epoll 虽然也需要维护用来存放文件描述符的数据结构（epoll_event），但是它只需要将该数据结构拷贝一次，不需要重复拷贝，并且它只在调用 epoll_ctl 系统调用时拷贝一次要监听的文件描述符数据结构到内核区，在调用 epoll_wait 的时候不需要再把所有的要监听的文件描述符重复拷贝进内核区，这就解决了 select 和 poll 种内存复制开销的问题。

**Epoll缺点**：目前只有Linux操作系统支持epoll，不支持跨平台使用，而Unix操作系统上是使用kqueue。

**Epoll水平触发（LT）**：对于读操作，只要缓冲区内容不为空，LT模式返回读就绪；

对于写操作，只要缓冲区还不满，LT模式会返回写就绪。

**Epoll边缘触发（ET）**：对于读操作，当缓冲区由不可读变为可读的时候，有新数据到达时，进程修改了 EPOLL_CTL_MOD 修改 EPOLLIN 事件时

在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。

当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait() 时，它不会通知你，也就是它**只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你**。通常配合将文件描述符设置为非阻塞状态一起使用，这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。


## 61.类的生命周期
类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载、验证、准备、解析、初始化、使用和卸载七个阶段**。其中验证，准备，解析三个部分统称为**连接**

- 全局对象在main开始前被创建，main退出后被销毁。
- 静态对象在第一次进行作用域时被创建，在main退出后被销毁。
- 局部对象在进入作用域时被创建，在退出作用域时被销毁。
- New 创建的对象直到内存被释放的时候都存在。


## 62.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？
构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。

析构函数可以是虚函数：vptr已经完成初始化，析构函数可以声明为虚函数，且类有继承时，析构函数常常必须为虚函数。

要注意，使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。

## 63.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？
因为在多进程中易发生多进程对资源进行竞争，如果一个进程集合里面的每一个进程都在等待这个集合中的其他一个进程才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁。产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件。解决死锁的方法就是破坏上述任意一种条件。

## 64.描述一下面向过程和面向对象
**面向对象**：就是将问题分解为各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为，相比面向过程，代码更易维护和复用。但是代码效率相对较低。

**面向过程**：就是将问题分析出解决问题的步骤，然后将这些步骤一步一步的实现，使用的时候一个一个调用就好。代码效率更高但是代码复用率低，不易维护。


## 65.++i是左值还是右值，++i和i++哪个效率更高？
++i是左值，因为++i返回的是一个左值没有发生拷贝，所以效率更高。

## 66.介绍一下vector、list的底层实现原理和优缺点
**Vector优点**：可使用下标随机访问，尾插尾删效率高

**缺点**：前面部分的插入删除效率低，扩容有消耗，可能存在一定的空间浪费。

**原理**：底层是由一块连续的内存空间组成，由三个指针实现的分别是**头指针（**表示目前使用空间的头），**尾指针**（表示目前使用空间的尾）和**可用空间尾指针**实现

----------

**List优点**：按需申请内存，不需要扩容，不会造成内存空间浪费。在任意位置的插入删除下效率高。

**缺点**：不支持下标随机访问

**原理**：底层是由双向链表实现的

## 67.静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）
静态变量，全局变量，常量都在编译阶段完成初始化和内存分配。其他变量都是在编译阶段进行初始化，运行阶段内存分配.。

## 68.如何实现多进程？
在Linux中C++使用fork函数来创建进程

而windows中C++使用createprocess来创建进程


## 69.空对象指针为什么能调用函数？
在类的初始化的时候，编译器会将它的函数分配到类的外部，这也包括静态成员函数，这样做主要是为了节省内存，如果我们在调用类中的的成员函数时没有使用类中的任何成员变量，它不会使用到this指针所以可以正常调用这个函数。

## 70.shared_ptr线程安全吗？
智能指针中的引用计数是线程安全的，但是智能指针所指向的对象的线程安全问题，智能指针没有做任何保障线程不安全。也就是说它所管理的资源可以线程安全的释放，**只保证线程安全的管理资源的生命期**，不保证其资源可以线程安全地被访问。

## 71.push_back()左值和右值的区别是什么？
如果 push_back（）的参数是左值，则使用它拷贝构造新对象，如果是右值，则使用它移动构造新对象。

## 72.move底层是怎么实现的？
move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。

优点：可以将左值变成右值而避免拷贝构造，将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝。

> std::move是C++11新增加的一个函数模板，其主要功能是将一个左值强制转换为一个右值引用。

>其原型定义如下：

>template<typename T>
>typename remove_reference<T>::type&& move(T&& arg) noexcept;

>其中remove_reference是一个类型转换模板，其主要功能是去除模板类型T的引用类型，返回一个非引用类型。

>函数move接收一个泛型参数，该参数被声明为一个右值引用，也就是T&&。当函数move接收到一个左值参数时，其会将该参数强制转换为一个右值引用，并返回一个右值引用类型的转换结果。

>在C++11中，移动语义的引入解决了传递复制构造函数和复制赋值运算符中的性能问题。当使用std::move函数将一个左值转换为右值引用时，可以避免不必要的对象复制和内存分配，从而提高程序的性能和效率。

## 73.完美转发的原理是什么？
完美转发是指函数模板可以将自己的参数完美的转发给内部调用的其他函数，完美是指不仅能够准确的转发参数的值，还能保证被转发参数的左、右值属性不变，使用引用折叠的规则，将传递进来的左值以左值传递出来，将传递进来的右值以右值的方式传出。

## 74.空类中有什么函数？
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符

取值运算符、const取值运算符

## 75.explicit用在哪里？有什么作用？
只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。


## 76.成员变量初始化的顺序是什么？
成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。**类中const成员常量必须在构造函数初始化列表中初始化。类中static成员变量，只能在类外初始化。**

顺序：基类的静态变量或全局变量，派生类的静态变量或者全局变量，基类的成员变量，派生类的成员变量。

## 77.指针占用的大小是多少？
64位电脑上占8字节，32位的占4字节，我们平时所说的计算机多少位是指计算机CPU中通用寄存器一次性处理、传输、暂时保存的信息的最大长度。即CPU在单位时间内能一次处理的二进制的位数，因此CPU所能访问的内存所有地址由多少位组成，而8比特位表示1字节，就可以得出在不同位数的机器中指针的大小。

## 78.野指针和内存泄漏是什么？如何避免？
内存泄漏：是指程序中以动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

避免：使用智能指针管理资源，在释放对象数组时使用delete[]，尽量避免在堆上分配内存

野指针：指向一个已删除的对象或未申请访问受限内存区域的指针。

避免：对指针进行初始化，用已合法的可访问内存地址对指针初始化，指针用完释放内存，将指针赋值nullptr。

## 79.malloc 和 new 的区别是什么？
malloc/free是标准库函数，new/delete是C++运算符

malloc分配内存失败返回空，new失败抛异常

new/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。

New返回有类型的指针，malloc返回无类型的指针

分配内存的位置：malloc从堆上动态分配内存，new是从自由存储区为对象动态分配内存（取决于operator new的实现，可以为堆还可以是静态存储区）

new申请内存的步骤：调用operator new函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。

delete：先调用对象的析构函数，再调用operator delete函数释放内存空间


## 80.(☆)多线程会发生什么问题？线程同步有哪些手段？
会引发资源竞争的问题，频繁上锁会导致程序运行效率低下，甚至会导致发生死锁。

**线程同步手段**：使用atomic原子变量，使用互斥量也就是上锁，使用条件变量或信号量制约对共享资源的并发访问。


## 81.什么是STL？
它是C++标准库的重要组成部分，不仅是一个可复用的组件库也是一个包含了数据结构与算法的软件架构。

STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。

> [STL基础知识 简介](https://blog.csdn.net/weixin_53332395/article/details/123948946)

## 82.对比迭代器和指针的区别
迭代器不是指针，是一个模板类，通过重载了指针的一些操作符模拟了指针的一些功能，迭代器返回的是对象引用而不是对象的值。

指针能够指向函数而迭代器不行,迭代器只能指向容器

## 83.空间配置器?

空间配置器是操作系统开辟的一大段内存空间。STL需要扩容申请内存时，就从空间配置器中申请，不需要再经过操作系统。并且，它还能回收释放的空间，供下一次使用。一个进程中有一个空间配置器，进程中所有容器需要的空间都到对应空间配置器申请。进程终止，对应空间配置器空间释放。

空间配置器有两级结构，一级空间配置器是用来处理大块内存，二级空间配置器处理小块内存。SGI-STL规定以**128字节作为小块内存和大块内存的分界线**。

**为什么这样区分成两级？**

因为STL容器，一般申请的都会是小块的内存，二级空间配置器，主要是管理容器申请空间和释放的空间。
如果用户申请的空间直接大于的128字节直接找的是一级空间配置器申请空间。

----------

**一级空间配置器**：
一级空间配置器原理很简单，直接是对malloc和free进行了封装，并且增加了C++中的申请空间失败抛异常机制。
主要的作用是：向操作系统申请内存，申请失败会抛异常。
为什么不直接用 C++ 的 new 和 delete，因为这里并不需要调用构造函数和析构函数。

----------

**二级空间配置器**：
二级空间配置器专门负责处理小于128字节的小块内存。

SGI-STL采用了内存池的技术来提高申请空间的速度以及减少额外空间的浪费，采用哈希桶的方式来提高用户获取空间的速度和高效管理。

[https://blog.csdn.net/weixin_51164515/article/details/125743478](https://blog.csdn.net/weixin_51164515/article/details/125743478)

## 84.NULL和nullptr的区别与联系？
`NULL` 是一个预处理器变量，在头文件 `cstdlib` 中定义为 0 值。预处理器是运行在编译过程之前的一段程序，预处理变量不属于命名空间 std，它是由预处理器负责管理。当用到一个预处理变量时，在编译时，预处理器会自动把它替换为实际值，因此使用 NULL 初始化指针和使用 0 初始化指针是一样的。

`nullptr` 是一个字面值常量，它可以被转化为任何其他类型的指针。

另外，把int 型变量直接赋值给指针是错误的操作，即使 int 型变量等于 0 也不行！

为了解决二义性，C++11标准引入了关键字nullptr，它作为一种空指针常量。


## 85.为什么C 中 (void*)0 是空指针常量，而C++中不是？

因为 C 语言中任何类型的指针都可以（隐式地）转换为 void* 型，反过来也行。
而 C++ 中void* 型不能隐式地转换为别的类型指针（例如：int  *p = (void *) 0;  使用C++编译器编译会报错）。


## 86.(☆)线程有哪些状态，线程锁有哪些？
五种状态：创建，就绪，运行，阻塞，死亡

线程锁的种类：互斥锁，条件锁，自旋锁，读写锁，递归锁


## 87.解释说明一下 map 和 unordered_map？
map 内部实现是一个红黑树，内部所有的元素都是有序的，而 hashmap 则是内部实现了一个哈希表，内部存储元素是无序的

**map优点**：有序性，其次是内部实现的是一个红黑树，使得很多操作都可以在logn的复杂度下可以实现效率较高。

**map缺点**：空间占用率高

**unorderedmap优点**：查找效率非常高；

**unorderedmap缺点**：哈希表的建立比较费时间。


## 88.vector中的push_back()和emplace_back()的区别、以及使用场景
当使用 `push_back` 时会先调用类的有参构造函数创建一个临时变量，再将这个元素拷贝或者移动到容器之中，而 `emplace_back` 则是直接在容器尾部进行构造比 push_back 少进行一次构造函数调用。在大部分场景中 `emplace_back` 可以替换 `push_back`，但是 `push_back` 会比 `emplace_back` 更加安全，`emplace_back` 只能用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中则需要使用 `push_back`。


## 89.(☆)如何实现线程安全，除了加锁还有没有其他的方式？
除了锁之外还可以使用互斥量（防止多个线程来同时访问共享资源，从而避免数据竞争的问题），原子操作（原子操作是不可分割的，使用原子操作可以确保在多线程环境中操作是安全的），条件变量（协调线程之间的协作，用来在线程之间传递信号，从而控制线程的执行流程）等方式。

## 90.vector扩容，resize和reserve的区别？
使用resize改变的是vector的大小（size），可能会添加或删除元素。

使用reserve改变的是vector的容量（capacity），不会改变当前元素的数量，仅仅是为了优化内存使用和性能。

## 91.vector 扩容为了避免重复扩容做了哪些机制？
当vector内存不够时本身内存会以1.5或者2倍的增长，以减少扩容次数

引入了reserve，自定义vector最大容量

## 92.C++中空类的大小是多少？
1字节

空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。如果没有这一个字节的占位，那么空类就无所谓实例化了，因为实例化的过程就是在内存中分配一块地址。

注意：**当该空白类作为基类时，该类的大小就优化为0了，这就是所谓的空白基类最优化。**

注意：**空白基类最优化无法被施加于多重继承上只适合单一继承**。


## 93.weak_ptr 是怎么实现的？
实现依赖于计数器和寄存器实现的，计数器用来记录弱引用的数量，寄存器用来存储shared_ptr

shared_ptr：a 和 b的对象内部，具有各自指向对方的shared_ptr，并且 a 和 b 的引用计数都是2.当程序退出时，引用计数减为1，对象并不会被析构掉。


weak_ptr是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，即就是将一个weak_ptr绑定到shared_ptr不会改变shared_ptr的引用计数。不论是否有用weak_ptr指向一旦最后一个指向对象的shared_ptr被销毁，对象就会是释放。从这个角度看，weak_ptr更像是一个shared_ptr的助手，weak_ptr并不拥有对对象的管辖权，weak_ptr指向shared_ptr的目标也不会增加计数器值。

[weak_ptr](https://blog.csdn.net/m0_57719144/article/details/131153455)

## 94.虚函数的底层原理是什么？

C++中的虚函数是一种特殊类型的成员函数，用于实现运行时多态性。虚函数允许在基类中使用基类指针或引用来调用派生类的函数实现，从而根据对象的实际类型来执行相应的函数代码。

----------


虚函数的作用和优势包括：

1. **多态性**：通过虚函数，可以在运行时根据对象的实际类型来选择调用相应的函数实现。这样可以实现多态性，使得程序更加灵活和易于扩展。
1. **继承和接口**：虚函数为派生类提供了一种方式来继承基类的接口。基类中声明的虚函数在派生类中可以被覆盖（重写）以提供特定的实现。
1. **避免判断对象类型**：通过使用虚函数，不需要手动判断对象的实际类型，而是让编译器自动处理，使代码更加简洁和可读。
1. **动态绑定**：虚函数通过动态绑定（Dynamic Binding）实现多态性。在运行时，基类指针或引用会根据对象的实际类型调用相应的虚函数，而不是根据指针或引用的类型。

----------


**底层原理：**

在底层，虚函数的实现依赖于虚函数表（VTable）和虚指针（VPtr）。

**虚函数表（VTable）**：对于包含虚函数的类，编译器会为该类创建一个虚函数表。虚函数表是一个包含了虚函数指针的数组，每个虚函数对应一个表项。每个类只有一个虚函数表，不管有多少个对象实例。*虚函数表在编译阶段就确定，并在程序运行时使用*。

**虚指针（VPtr）**：对于包含虚函数的类，每个对象都会有一个虚指针，用于指向该对象所属类的虚函数表。这个虚指针通常是隐藏的，存储在对象的内存布局的开始位置。通过虚指针，程序可以在运行时找到正确的虚函数表，从而实现动态绑定。

当调用一个虚函数时，程序会根据对象的虚指针找到对应的虚函数表，然后根据函数在虚函数表中的索引找到正确的函数实现并调用。这就是C++中虚函数实现多态性的底层原理。

需要注意的是，虚函数的使用会引入虚函数表和虚指针，略微增加了对象的内存开销和函数调用的性能损耗，但对于大多数情况而言，这种开销是可以接受的，并且带来了更强大的代码组织和设计能力。


## 95.一个函数f(int a,int b)，其中a和b的地址关系是什么？
a和b的地址是相邻的。


## 96.移动构造和拷贝构造的区别是什么？
**移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交**，在一些特定场景下，可以减少不必要的拷贝。

比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。而**拷贝构造则是将传入的对象复制一份然后放进新的内存中**。

## 97.(☆)lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？
所谓捕获列表，其实可以理解为参数的一种类型，**lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用**。 根据传递的行为，捕获列表也分为以下几种：

1. **值捕获**：
与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝

2. **引用捕获：**
与引用传参类似，引用捕获保存的是引用，值会发生变化。

3. **隐式捕获**：
手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 & 或 = 向编译器声明采用 引用捕获或者值捕获。
总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：

	（1）[] 空捕获列表；
	（2）[name1, name2, …] 捕获一系列变量；
	（3）[&] 引用捕获, 让编译器自行推导捕获列表；
	（4）[=] 值捕获, 让编译器执行推导应用列表；



4. **容器for_each遍历中嵌入Lambda 表达式**：
利用stl中迭代写法for_each进行动态数组内元素奇偶数的判断。

[https://blog.csdn.net/Dasis/article/details/121372235](https://blog.csdn.net/Dasis/article/details/121372235)

----------


按值捕获和引用捕获，默认的引用捕获可能会导致悬挂引用，引用捕获会导致闭包包含一个局部变量的引用或者形参的引用，如果一个由lambda创建的闭包的生命周期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。解决方法是对个别参数使用值捕获。

[C++11：lambda表达式的陷阱](https://blog.csdn.net/zzhongcy/article/details/88019153?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-88019153-blog-121372235.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-88019153-blog-121372235.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6)

## 98.哈希碰撞的处理方法

**链地址法**：将所有的哈希地址相同的记录都链接在同一链表中

**开放定址法**：当遇到哈希冲突时，去寻找一个新的空闲的哈希地址（线性探测，平方探测）。

**多次哈希**：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数直到不发生冲突为止，虽然不易发生聚集，但是增加了计算时间。

**建立公共溢出区**：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。查找时，先从哈希表查，查不到再去公共溢出区查。


## 99.unordered_map 的扩容过程
当 `unordered_map` 中的元素数量 **达到桶的负载因子（0.75）时，会重新分配桶的数量** （通常会按照原有桶的数量 `*2` 的方式进行扩容，但是具体的增长策略也可以通过修改容器中的 `max_load_factor` 成员变量来进行调整），并 **将所有的元素重新哈希到新的桶中**。


> unordered_map是一个关联容器，存储key,value.其中元素并没有特别的次序关系.
> 
> 特点：
> 
> 1. 关联容器中的元素是通过主键（Key）而不是它们在容器中的绝对位置来引用的。
> 2. 无序（Unordered）无序容器通过 hash 表来组织它们的元素，允许通过主键快速地访问元素。
> 3. 映射（Map）每个元素为一个值（Mapped value）绑定一个键（Key）：以主键来标志主要内容等于被映射值的元素。
> 4. 键唯一（Unique keys）容器中不存在两个元素有相同的主键。
> 5. 能够感知内存分配器的（Allocator-aware）容器使用一个内存分配器对象来动态地处理它的存储需求。
> 
> 在 unordered_map 内部，元素不会按任何顺序排序，而是通过主键的 hash 值将元素分组放置到
> 各个槽（Bucket，也可译成“桶”）中，这样就能通过主键快速地访问各个对应的元素（平均耗时为一个常量，即时间复杂度为 O(1)）。


## 100.vector如何判断应该扩容？（size和capacity）
由当前容器内元素数量的大小和容器最大大小进行比较如果二者相等就会进行扩容，一般是1.5倍，部分的有两倍

## 101.构造函数是否能声明为虚函数？为什么？
构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的 `vptr` 指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找 `vptr` ，但此时 `vptr` 还没有完成初始化，导致无法构造对象。

## 102.类中static函数是否能声明为虚函数？
不能，因为类中的 `static` 函数是所有类实例化对象所共有的，没有 `this` 指针，而虚函数依靠 `vptr` 和 `vtable` 来处理，`vptr` 是一个指针，在类中的构造函数中生成，并且只能通过 `this` 指针访问，对于静态成员函数来说，他没有 `this` 指针，无法访问 `vptr`，因此 `static` 函数无法声明为虚函数.

## 103.(☆)哪些函数不能被声明为虚函数？
常见的不不能声明为虚函数的有：**普通函数（非成员函数）；静态成员函数；内联成员函数；构造函数；友元函数。**

**普通函数(非成员函数)**:多态依托于类实现，因此普通函数不可被声明为虚函数

**构造函数**:虚表指针在构造函数中初始化，而虚函数保存在虚表中，调用虚函数时需要通过虚表指针找到虚函数;
若构造函数是虚函数，则调用构造函数需要先得到虚表指针，而虚表指针又需要在构造函数中初始化，矛盾

**内联成员函数**:内联函数在编译时被展开，而多态是运行时多态，也就是运行时才确定要调用哪个虚函数，矛盾

**静态成员函数**:虚函数保存在虚表中，调用虚函数时需要通过 this 指针得到虚表指针，再通过虚表指针找到虚函数,而静态函数不传入 this 函数，因此不可声明为虚函数

**友元函数**:对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。


## 104.(☆)如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）
将构造函数设置为私有，这样只能使用new运算符来建立对象，但是我们必须准备一个destory函数来进行内存的释放，然后将析构函数设置为 protected，提供一个 public 的 static 函数来完成构造，类似于单例模式

如果在栈上分配呢？则是重载 new 操作符，使得 new 操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配.


## 105.C/C++堆和栈的区别

**1.生命周期不同**
	
	堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。

	栈：由编译器（Compiler）自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。

**2.申请方式不同**

	堆：程序中要分配一个堆空间可以使用 new（new 这是 C++中专用的关键字） 关键字、malloc 函数， calloc()函数， realloc 函数实现;
	当不再需要这个堆空间时，可以使用 delete（delete 这是 C++中专用的关键字） 关键字、 free 函数完成释放工作。

	栈：由系统自动分配。只要是局部变量 ，操作系统自动在栈中其开辟空间。比如在 main 函数中定义一个变量 int b,则 b 使用的空间就是栈空间。

**3.底层实现机制不同**

	堆：堆的生长方向是向上生长，内存地址由低到高,一般是通过链表进行存储空间管理，内存上可以是不连续的。

	栈：栈的生长方向是向下生长（有的系统可能是向上生长），，内存地址由高到低。且在使用上， 空间是连续的。

**4.申请空间大小上限不同**

	堆：堆的大小受限于计算机系统中有效的虚拟内存。在 32 位系统上，其大小可以达 4G，使用起来比较灵活。

	栈：在 Windows 下，栈的大小是固定的（是一个编译时就确定的常数），所以程序员不适合在函数内申请过多的栈空间，否则可能会导致程序栈溢出。

**5.内存利用率不同**

	堆：堆空间的申请分配一般是随机的，不连续的内存空间， 容易产生内存碎片。

	栈：由系统自动分配，速度较快，但程序员是无法控制的。

**6.分配方式不同**

	堆：都是动态分配的，没有静态分配的堆。
	
	栈：有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配;动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

[https://www.jb51.net/article/215546.htm](https://www.jb51.net/article/215546.htm)


## 106.讲讲你理解的虚基类

[https://www.cnblogs.com/DOTA-SPE/p/15920853.html](https://www.cnblogs.com/DOTA-SPE/p/15920853.html)

虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。

为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。

**虚基类只能被实例化一次**--->虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。

虚基类子对象是由**最远派生类的构造函数**(在继承结构中建立对象时所指定的类)通过调用虚基类的构造函数进行初始化的。

 派生类的构造函数的成员初始化列表中**必须列出对虚基类构造函数的调用**；如果未列出，则表示使用该虚基类的**缺省构造函数**。


在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，<font color="#F100">虚基类的构造函数先于非虚基类的构造函数执行。</font>

## 107.C++哪些运算符不能被重载？
**成员访问运算符`.`**，**指针运算符 `.*`**，**域解析操作符`::`**，**条件运算符`?:`**,**长度运算符 `sizeof`**之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。

    .* 和 ->* 返回表达式左侧所指定的对象的特定类成员的值


## 108.动态链接和静态链接的区别，动态链接的原理是什么？
**区别**：他们的最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。

**静态库**：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。

**动态库**：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。

**动态链接原理**：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件

## 109.C++中怎么编译C语言代码？
需要使用 C++ 的外部链接功能，即 `extern "C"`。这告诉 C++ 编译器，被这个声明的函数或变量是用 C 的方式进行链接的。

## 110.初始化全局变量和未初始化全局变量有什么区别？
[https://blog.csdn.net/qq_70799748/article/details/130712416](https://blog.csdn.net/qq_70799748/article/details/130712416)

全局变量初始化而且初始值不为0，那么这样的全局变量是放在内存的**.data段**的，如果全局变量初始值为0或者未初始化，那么这样的全局变量是放在**.bss**（Block Started By Symbol）段的。

<font color="#F100">未初始化的全局变量的默认值是 0，而未初始化的局部变量的值却是垃圾值（任意值）。</font>

内存中运行着很多程序，我们的程序只占用一部分空间，这部分空间又可以细分为以下的区域：

**1.程序代码区**：存放函数体的二进制代码。

**2.静态数据区(data area)**：也称全局数据区,包含的数据类型比较多，如全局变量、静态变量、一般常量、字符串常量

(1)全局变量区和静态变量区的存储是返回在一块的，初始化的全局变量和静态变量在一块区域。未初始化的全局变量和未初始化的静态变量在相邻的另一区域。

(2)常量区域包括字符串常量和一般常量存储在另一区域

注意：静态区的内存在程序结束后由系统释放。

**3.堆区**：一般由程序员分配和释放，若程序员不释放，则程序运行结束后由系统回收。malloc(),calloc(),free()，操作的就是这块内存。

注意：这里的堆区不同于数据结构的堆，堆区的分配方式倒是和数据结构的链表比较相似。

**4.栈区**：由系统自动分配释放，存放函数的参数值和局部变量的值等。其操作方式类似于数据结构中的栈。

**5.命令形参区**：存放命令型参数和环境变量的值，如通过`main()`传递的值。


## 111.说一下内联函数及其优缺点

**每调用一次函数,都要为其分配一片栈空间(栈帧)。**并且在函数调用的时候，需要跳转到函数所在的位置，这是需要做很多的准备——比如: 记录程序执行的位置,状态等。因此，**函数调用是有一定时间开销的。**

内联函数是在编译期将函数体内嵌到程序之中，以此来节省函数调用的开销。

**优点**：调用函数是不需要给函数分配占空间，不需要跳转。节省了函数调用的开销，让程序运行更加快速。

**缺点**：内联函数函数体占用的是调用者的栈空间，如果函数体过长，频繁使用内联函数会导致代码编译膨胀问题。不能递归执行。

[https://blog.csdn.net/weixin_61084441/article/details/128776893](https://blog.csdn.net/weixin_61084441/article/details/128776893)


## 112.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

`auto` 仅仅只是一个占位符，在编译期间它会被真正的类型替代，或者说 C++ 中变量必须要有明确类型的，只是这个类型是由编译器自己推导出来的。
使用auto可以提高代码的简洁性和易读性，并减少一些显式类型声明的工作。

1. auto 不能用于函数参数
1. auto 不能用于非静态成员变量
1. auto 无法定义数组
1. 实例化模板时不能使用 auto 作为模板参数。 

函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式具体类型函数的模具，所以模板其实就是将原本应该我们做重复的事情交给了编译器。

## 113.map 和 set 的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)
**序列式容器**：vector/list/string/deque；
序列式容器才支持push等操作，关联式容器不支持

**关联式容器**：map/set/unordered_map/unordered_set；set和map的底层实现是**平衡搜索二叉树**



- **set的特性**：①、会对插入的数据自动排序 ②、set是不允许修改值的 ③、set中不允许出现重复的数值，即使存在，也只会留一个
- **set的遍历**：①、迭代器遍历 ②、范围for遍历（因为支持迭代器遍历就一定支持范围for）
- set的拷贝构造
- **set的插入**只有insert，其没有push、pop等，因为它是关联式容器
- set的find，**find找到了会返回被查找元素的迭代器，没找到返回end()，故应检查找没找到**
- **set的删除**：①、erase(待删除位置的迭代器)  ②、erase(待删除数据) ③、erase(s.begin(), s.end())【即迭代器头和尾，其效果等价于clear】

> set的find和库里面提供的find有什么区别呢？
> （1）都可实现查找，区别在于效率
> （2）set是搜索二叉树的：时间复杂度：O（logN），而算法中的是O（N）
> （3）算法中的find是个模板，其实现是为了所有容器可以通用它，故set尽量用自己的find 


- map就是搜索树中的key/value模型
- map的遍历：①、迭代器遍历 ②、范围for遍历
- map的类型是pair，pair存的一个是key的，一个是value的类型
- map的构造函数：①、pair构造函数 ②、make_pair函数模板构造一个pair对象


`multiset` 和 `multimap` 除了在set和map的基础上支持数据重复出现外，根本没什么区别

`Map` 中存储的是 `Key-Value` 的键值对，`Set` 中只存储了 `Key`


都是红黑树，

`find` 查找需要判断返回的结果才知道有没有查询成功。

`[]`不管有没有就是 `0`，如果原先不存在该 `key`，则插入，如果存在则覆盖插入，

`at` 方法则会进行越界检查，这会损失性能，如果存在则返回它的值，如果不存在则抛出异常。


## 114.详细说一说 fcntl 的作用
**作用**：用于控制打开的文件描述符的一些属性和行为。

	#include <unistd.h>
	#include <fcntl.h>
	int fcntl(int fd, int cmd, ... /* arg */ );

有五个功能：

1.复制一个现有的描述符(cmd=F_DUPFD)

2.获得/设置文件描述符标记（cmd=F_GETFD或F_SETFD）

3.获取/设置文件状态标记（cmd=F_GETFL或F_SETFL）

4.获取设置异步IO所有权（cmd=F_GETOWN或F_SETFL）

5.获取设置记录锁（cmd=F_GETLK或F_SET）


## 115.C++的面向对象主要体现在那些方面？

体现在C++引入了面向对象的一些特征，例如加入了封装继承多态的特点。（然后介绍一下封装继承多态）


## 116.介绍一下 extern C 关键字，为什么会有这个关键字？
extern "C" 关键字常用于 C++ 和 C 混合编程中，用于指定函数或变量采用 C 语言的命名和调用约定。加上 extern "C" 后，会指示编译器这部分代码按 C 语言（而不是C++）的方式进行编译。

> 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名（而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名）。

也就是说：C++和C对产生的函数名字的处理是不一样的，extern "C"的目的就是主要实现C与C++的相互调用问题。

## 117.讲一讲迭代器失效及其解决方法
迭代器的主要作用：就是让算法能够不用关心底层数据结构，其底层实际就是一个指针，或者是对指针进行了封装

**迭代器失效**：实际就是迭代器底层对应指针所指向的空间被销毁了，而使用一块已经被释放的空间，造成的后果是程序崩溃(即如果继续使用已经失效的迭代器，程序可能会崩溃)。


总结：迭代器失效分三种情况考虑，也是非三种数据结构考虑，分别为数组型，链表型，树型数据结构。

**数组型数据结构：** 该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

**链表型数据结构：** 对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

**树形数据结构：** 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

注意：经过 erase(iter) 之后的迭代器完全失效，该迭代器 iter 不能参与任何运算，包括 iter++,*ite

[迭代器失效的几种情况总结](https://blog.csdn.net/lujiandong1/article/details/49872763?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-49872763-blog-130630570.235%5Ev43%5Epc_blog_bottom_relevance_base8&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-49872763-blog-130630570.235%5Ev43%5Epc_blog_bottom_relevance_base8&utm_relevant_index=6)

## 118.编译器是如何实现重载的？
在编译时，编译器如果遇到了函数，就会在符号表里面命名一个符号来存放函数的地址，

1.如果函数的使用在定义之前编译，无法在符号表中找到对应函数地址，则先标记为“`？`”（暂时未知），在全部编译结束后的链接过程将“`？`”在符号表里找到并替代为相应的函数地址，

2.如果函数的定义在使用之前编译，则可以直接在符号表里找到对应函数地址直接使用，

而在C语言中的符号表是以函数名为符号来存储函数地址，函数名相同的重载函数的地址应该不同，于是符号表中存在两个同符号的函数地址，在查找使用时会存在歧义和冲突。

而C++符号表中的符号不是以函数名命名的，称为**函数名修饰规则**，虽然函数名相同，但是函数参数等其他属性不同，取的符号也不同，所以不会产生查询歧义的问题，使得函数可以重载。


## 119.什么是函数调用约定？
函数调用约定就是对函数调用的一个约束和规定，描述了函数参数是怎么传递和由谁清除堆栈的。它决定了，函数参数传递的方式（是否采用寄存器传递参数，采用哪个寄存器传递参数，参数压栈的顺序等），函数调用结束后栈指针由谁恢复（被调用的函数恢复还是调用者恢复），函数修饰名的产生方法。

__stdcall：是standardcall的缩写，是C++的标准调用方式，规则如下：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。被调用函数自动清理堆栈，返回值在EAX。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上“@”和参数的字节数。

__cdecl：是C DECLaration的缩写（declaration，声明），表示C语言的默认函数调用方法，规定如下：所有参数从右往左依次入栈，所有参数由调用者清除，称为手动清栈。返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，由于由调用者清理栈，所以允许可变参数函数存在。

__fastcall：是快速调用约定，通过寄存器来传送参数，规则如下：用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍然自右向左压栈传送。被调用函数在返回前清理传送参数的内存栈，返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上“@”前缀，在函数名后加上“@”和参数的字节数。

__thiscall：是唯一一个不能明确指明的函数修饰符，thiscall只能用于处理C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定，由于成员函数调用还有一个this指针，因此必须特殊处理，规定如下：采用栈传递参数，参数从右向左入栈，如果参数个数确定，this指针通过TCX传递给被调用者，如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不确定的，调用者清理堆栈，否则由被调函数清理堆栈，
__thiscall不是关键字，程序员不能使用

__pascal：与 __stdcall一样，在VC中已经被废弃

## 120.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？
类内普通成员函数可以调用类内静态变量，因为类内静态变量在编译时就已经完成了初始化和内存分配，类内普通函数调用类内静态变量说明类已经完成实例化，所以可以调用。

静态函数可以直接访问静态变量，静态函数不能直接访问非静态变量，但是可以通过将类实例化对象后，静态函数去访问对象的非静态成员变量。


## 121.强制类型转换有哪几种类型，分别有什么特点？原理是什么？
**Static_cast**：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。

1. 用于类层次结构中基类和派生类之间指针或引用的转换，进行上行切换（把派生类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。
2. 用于基本类型之间的转换，如把int转换成char，这种类型的转换也需要开发人员来保证
3. 把空指针转换成目标类型的空指针。
4. 把任意类型的表达式转换成void类型
5. 涉及到类时，只能在有相互联系的类型中进行相互转换，不一定包含虚函数

**注意**：不能转换掉表达式中的const，volitale，__unaligned属性


----------

**Const_cast**：用于强制去除类似于const这种不能被修改的常数特性。

1. 用来修改类型的const或者volatile属性，除了const或volatile修饰之外，type_id和expression的类型是一样的。
2. 常量指针被转化为非常量指针，并且仍然指向原来的对象
3. 常量引用被转换为非常量引用，并且仍指向原来的对象，常量对象被转换成非常量对象。

**注意**：const_cast 不适用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，即**去除常量性的对象必须为指针或者引用**。


----------

**Reinterpret_cast**：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。

1. 传入类型必须是一个指针，引用，算术类型，函数指针，成员函数或成员指针
2. 它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。

**注意**：在强制转换的过程中只是比特位的拷贝，在使用中必须特别谨慎。


----------

**Dynamic_cast**：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。

1. 不能用于内置的基本数据类型的强制转换。
2. 如果转换成功会返回一个指向类的指针或者引用，转换失败会返回NULL。
3. 进行转换的时候基类中一定要有虚函数，否则编译不通过（因为类中存在虚函数就说明它有想让基类指针或引用指向派生类对象的情况，此时转换才有意义）。
4. 在类的转换时，在类层次间进行上行转换时，与 `static_cast` 的转换效果是一样的，在下行转换时，它具有类型检查功能，比 `static_cast` 更安全。

**注意**：向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。如果转换目标是指针类型转换失败，则结果返回0，如果是引用类型则抛出`std::bad_cast`异常

原理：改变了其内存二进制的存储形式。

## 122.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

**回调函数**是指使用者自己定义一个函数，实现这个函数的程序内容，然后别人把这个函数（入口地址）作为参数传入别人的函数中，由别人的函数在运行时来调用的函数，简单说就是放发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。

可以把调用者和被调用者分开。调用者不关心谁是被调用者，所以它只需要知道的，只是一个存在某种特定类型原型，某些限制条件的被调用函数。

优点：

1. 可以让实现方根据回调方的多种形态进行不同的处理和操作
1. 可以让实现方，根据自己的需要定制回调方的不同形态
1. 可以将耗时的操作隐藏在回调方，不影响实现方其他信息的展示。
1. 让代码的逻辑更加集中，更加易读。

缺点：

1. 回调函数过多会导致代码难以维护
1. 回调函数容易造成资源竞争：如果回调函数中有共享资源访问，容易出现资源争抢，导致程序出错
1. 代码可读性差，可能会破坏代码的结构和可读性

**本质**：是将函数当作参数使用，目的是为了使程序更加普适。



## 123.什么是尾递归？
尾递归时递归的一种特殊情形，尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数。核心思想是边调用便产生结果。

**原理**：当编译器检测到一个函数调用是尾递归的时候，它会覆盖当前的活动记录而不是在栈中创建一个新的。编译器可以做到这一点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可以做，因此也就没有保存栈帧的必要了，通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。

**特点**：在尾部调用的是函数自身，可通过优化使得计算仅占用常量栈空间。

## 124.为什么会有栈溢出，为什么栈会设置容量？
*栈空间是预设的*，它通常用于存放临时变量，如果你在函数内部定义一个局部变量，空间超出了设置的栈空间大小，就会溢出。
不仅如此，如果函数嵌套太多，也会发生栈溢出，因为函数没有结束前，函数占用的变量也不被释放，占用了栈空间。

**原因**：是栈的地址空间必须连续，如果任其任意成长，会给内存管理带来困难。对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大。

## 125.二叉树和平衡二叉树的区别
二叉树没有平衡因子的限制，而平衡二叉树有。

二叉树可能退化为链表，而平衡二叉树不会。

## 126.平衡二叉树的优缺点
**优点**：避免了二叉排序树可能出现最极端情况（退化为链表），其平均查找的时间复杂度为logN

**缺点**：对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。


## 127.什么是this指针，为什么存在this指针？
类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的由编译器自动完成。

## 128.什么是重载、重写、隐藏？
重载：函数名相同，函数参数不同，两个函数在同一作用域。

重写：两个函数分别在子类和父类中，函数名，返回值，参数均相同，函数必须为虚函数。

隐藏：在继承关系中，子类实现了一个和父类名字名字一样的函数。这样子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关。


## 127.静态成员函数可以是虚函数吗？为什么？
它不属于类中的任何一个对象或示例，属于类共有的一个函数，不依赖于对象调用，静态成员函数没有this指针，无法放进虚函数表。

## 128.构造函数可以为虚函数吗？为什么？
虚表指针是存储在对象的内存空间，当调虚函数时，是通过虚表指针指向的虚表里的函数地址进行调用的。如果将构造函数定义为虚函数，就要通过虚表指针指向的虚表的构造函数地址来调用。而构造函数是实例化对象，定义为虚函数后，对象空间还没有实例化，那就没有虚表指针，自然无法调用构造函数，那构造函数就失去意义，所以不能将构造函数定义为虚函数。

## 129.make_shared 函数的优点，缺点？
`shared_ptr`：可以指向特定类型的对象，用于自动释放所指的对象；

`make_shared`：功能是在动态内存中分配一个对象并初始化它，返回指向此对象的 `shared_ptr`；


	shared_ptr<string> p1 = make_shared<string>(10, '9');  
	shared_ptr<string> p2 = make_shared<string>("hello");  
	shared_ptr<string> p3 = make_shared<string>(); 


从上面可以看出：

1）`make_shared` 是一个模板函数；

2）`make_shared` 必须显式指定想要创建的对象类型，如上题所示 `make_shared(10, 9)`,如果不传递显式模板实参 `string` 类型，`make_shared` 无法从`(10, ‘9’)`两个模板参数中推断出其创建对象类型。

3）`make_shared` 在传递参数格式是可变的，参数传递为生成类型的构造函数参数，因此在创建 `shared_ptr` 对象的过程中调用了类型 `T` 的某一个构造函数。


----------
`shared_ptr` 需要维护引用计数的信息。

**强引用**，用来记录当前有多少个存活的 `shared_ptr` 正在持有该对象，共享的对象会在最后一个强引用离开的时候销毁（也可能释放）

**弱引用**，用来记录当前有多少个正在观察该对象的 `weak_ptr`，当最后一个弱引用离开的时候，共享的内部信息控制块会被销毁和释放（共享的对象也会被释放，如果还没有释放的话）

**如果通过使用原始的 `new` 表示分配对象，然后传递给 `shared_ptr`（也就是 `shared_ptr` 的构造函数）的话，`shared_ptr` 的实现没有办法选择，而只能单独的分配控制块**

[C/C++编程：理解make_shared](https://blog.csdn.net/zhizhengguan/article/details/123700323)

`std::shared_ptr` 构造函数会执行两次内存申请，
`std::shared_ptr` 在实现的时候使用 `refcount` 技术，因此内部会有一个计数器(控制块)用来管理数据和一个指针。

**因此在  `std::shared_ptr<A> p2(new A)` 的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请**。


----------


`std::make_shared<A>()`则是只执行一次内存申请，将数据和控制块的申请放到一起。

因为 `make_shared` 只申请一次内存，因此控制块和数据块在一起，只有但控制块中不再使用时，内存才会释放。
但是如果还有 `weak_ptr` 指向该块对象所在的内存，存放管理对象的部分内存仍然不会被释放，因而导致在所有其他 `weak_ptr` 销毁前整块内存（尽管被管理对象已经析构了）将不会进入系统的内存池循环使用

----------


**优点**：

1. 减少内存分配次数：与 `std::shared_ptr` 相比，`std::make_shared` 只进行一次内存分配，这可以减少内存碎片和分配开销。
1. 提高性能：由于只进行一次内存分配，因此 `std::make_shared` 在某些情况下可以提高性能。
1. 简化代码：使用 `std::make_shared` 可以简化代码，避免显式地创建和管理 `std::shared_ptr` 控制块的开销。

**缺点**：当构造函数是保护或者私有的时候无法使用 make_shared 函数。

会导致 `weak_ptr` 保持控制块的生命周期，连带着保持了对象分配的内存，只有当最后一个 `weak_ptr` 离开作用域时，内存才会被释放，对于内存要求高的场景来说，是一个需要注意的问题。



## 130.函数调用进行的操作
1.将参数压栈：按照参数顺序的逆序进行，如果参数中有对象则先进行拷贝构造；

2.保存返回地址：即函数调用结束返回后接着执行的语句的地址；

3.保护维护函数栈帧信息的寄存器内容如，SP（堆栈指针），FP（栈帧指针）等。

4.保存一些通用寄存器的内容：因为有些通用寄存器会被所有函数用到，所以在函数调用之前，这些寄存器就可能已经放置了对函数有用的信息。

5.调用函数，函数执行完毕；

6.恢复通用寄存器的值；

7.恢复保存函数栈帧信息的那些寄存器的值；

8.通过移动栈指针，销毁函数的栈帧；

9.将保存的返回地址出栈，并赋给寄存器。

10.通过移动栈指针，回收传给函数的参数所占用的空间。


----------

# const

## 131.说说 const int *a, int const *a, const int a, int *const a, const int *const a 分别是什么，有什么特点。
`const int *a==int const *a`：可以通过 a 访问整数值，但不能通过 a 修改该整数的值，指针本身是可变的，可以指向不同的整数；

>首先 a 是一个整形指针，而 const 修饰的是 int*，表示 a 所指向的地址的内容不能被改变，但是 a 本身还可以指向别的地址。

`const int a`：a变量变成常量，不可修改；

`int *const a`：a的值可以更改，但是指向它的指针不能更改；

>a 是一个指向整形变量的指针，但与 `const int* a` 不同，`const` 修饰的是 `a` 本身，那么效果也就可想而知，并且 `int* const a` 在声明时就**必须初始化**，它表示的含义与 `const int* a` 相反，它**表示 a 本身一旦指向一个地址后就不能重新指向别的地址，但可以用解引用的方式改变其指向的空间的值。**


`int const *const a`：a本身和指向它的指针都不能更改。

>const 同时修饰了 int* 和 a 本身，就表示 a 既不能通过解引用的方式改变其所指的空间的值，同时 a 一旦被初始化后就不能再指向别的地址。

## 132.const 成员函数
常函数内不能修改成员变量

对于类的成员函数，有时候必须指定其返回值为 `const` 类型，以使得其返回值不为“左值”。

如果成员变量被 `mutable` 关键字修饰，那么就可以在常函数中修改

## 133.const 和 #define 的区别
（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。
而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。

（2）有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。

（3）#define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用。

（4）#define定义的常量不分配内存，而const定义的常量会分配在常量存储区中。

## 134.什么 const 在常量区，什么 const 在栈区，什么 const 放入符号表优化？

- 如果const修饰的是全局变量放到常量区（不可以通过地址修改该变量的值，定义为全局变量或者static变量的const常量通常被存放在常量区）
- 如果const修饰的是局部变量放在栈区（虽然是只读的，但可以通过变量指针修改变量的值，但是修改后的值只能在函数内部使用）
- 如果const修饰的变量没有被使用则会放到符号表中，其内容不会分配空间（如果一个const变量没有被使用，那么它就不会被分配内存，而是被优化掉。这种情况下，const 常量的值会被放在符号表中，而不会被放在内存中。当程序需要使用 const 变量时，编译器会根据符号表中的信息生成相应的指令。）

## 135.C++ 中内存中的几个区域分别存放什么？
在 C++ 中，内存被分为以下几个区域：

- **栈区（Stack）**：由编译器自动分配和释放，存放函数的参数值、局部变量的值等，其大小受限于操作系统和硬件。
- **堆区（Heap）**：由程序员手动分配和释放，通常用于动态内存分配，其大小受限于系统可用的虚拟内存大小。
- **全局区/静态区（Data Segment）**：存放全局变量、静态变量等，包括初始化和未初始化的数据，其大小由编译器决定。
- **常量区**：存储常量，一般不允许修改。
- **代码区（Code Segment）**：存放程序的二进制码。

在程序执行期间，操作系统会为每个进程分配一段内存，进程的内存空间被划分为多个段，每个段有其独立的属性和限制。C++ 中的内存分区可以帮助程序员更好地管理内存，提高程序的效率和可靠性。

## 136.堆和栈的区别？
在计算机科学中，堆(heap)和栈(stack)都是内存中用于存储数据的区域，但是它们在访问方式、内存管理方式和用途等方面存在很大的差别。


----------

**为什么要把堆和栈分开？-- 设计思想**

第一，从软件设计的角度看，**栈代表了处理逻辑**，**而堆代表了数据**。

这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

第二，堆与栈的分离，使得**堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）**。

这种共享的收益是很多的。一方面这种共享提供了一种**有效的数据交互方式**(如：共享内存)，另一方面，**堆中的共享常量和缓存可以被所有栈访问，节省了空间**。

第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。**由于栈只能向下生长，因此就会限制住栈存储内容的能力**。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

>为什么栈向下增长？
>
>这个问题与虚拟地址空间的分配规则有关，每一个可执行程序，从低地址到高地址依次是：text，data，bss(BSS段（Block Started by Symbol segment）是计算机程序中的一个重要概念，主要用来存放程序中未初始化的全局变量和静态变量)，堆，栈，环境参数变量；其中堆和栈之间有很大的地址空间空闲着，在需要分配空间的时候，堆向上涨，栈往下涨。

>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以**最大程度地共用这块剩余的地址空间，达到利用率的最大化**

第四，面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，**对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中**。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。


----------
**堆和栈访问方式的区别**

栈是一种后进先出(LIFO)的数据结构，数据的添加和删除只能在栈顶进行，而且只能访问栈顶的元素，访问其他元素必须先弹出栈顶的元素。栈的访问速度比堆快。

堆是一种无序的数据结构，数据的添加和删除没有任何限制，任何一个数据都可以通过指针进行访问。但是，由于堆内存的分配和释放不是按照固定的顺序进行的，所以访问堆中的数据需要较多的时间。


----------
**堆和栈内存管理方式的区别**

栈内存的分配和释放由系统自动完成，无需程序员手动干预。在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

大多数编译器中，参数是从右向左入栈。（可以使得 C/C++ 中函数参数可变的特性更方便）

堆内存的分配和释放由程序员手动完成。程序员需要显式地请求内存分配，并在不需要该内存时显式地释放该内存，否则会出现内存泄漏的问题。

----------
**函数调用栈**

- 在 C++ 中，函数调用栈是一个运行时的数据结构，用于管理程序中的函数调用。每当**调用一个函数时，都会在调用栈上创建一个新的栈帧**，该栈帧包含了函数的参数、局部变量和返回地址等信息。
- 当程序调用一个函数时，该函数的参数被压入栈中，接着程序跳转到该函数的入口点，开始执行函数体内的语句。在函数体内，函数的局部变量也会被分配在栈帧中，然后按照语句**顺序执行**。
- 在函数返回时，**返回值会被存储在特定的寄存器中，并将栈帧弹出调用栈**。返回地址被恢复，程序再次从该地址继续执行。如果函数有多个返回点，则返回地址可能存储在栈中的某个位置，由于这些返回地址被存储在堆栈中，因此**函数调用栈也被称为堆栈**。
- 如果一个函数调用了另一个函数，则新的函数的栈帧会被压入当前栈帧的顶部。这样就可以递归地调用函数，直到函数返回。当函数返回时，栈帧将被弹出，控制权将返回到调用该函数的函数。



----------
**堆和栈的用途**

- 栈通常用于存储程序的局部变量、函数的参数、函数的返回地址等临时性数据。
- 堆通常用于存储程序中的动态数据，如使用malloc()或new()函数分配的内存，可以在程序的任何位置访问。堆还用于存储一些需要动态分配的数据结构，如链表、树等。
- 总的来说，栈和堆都是非常重要的内存管理方式，它们分别适用于不同的场合和用途。在编写程序时，需要根据具体的需求和要求选择合适的内存管理方式，以保证程序的效率和稳定性。


## 137.静态变量存放在哪？为什么？
在C/C++中，静态变量（static变量）存放在程序的全局数据区（Data Segment）或者全局代码区（Code Segment）中，具体存放位置取决于静态变量的作用域和存储类型。

- 如果静态变量在**函数内部定义**，那么它的**作用域仅限于该函数**，但是它的存储类型是静态的，也就是说这个变量在程序运行期间只被初始化一次，然后一直存在于内存中。这种情况下， **静态变量会被存放在全局数据区中**。
- 如果静态变量在**函数外部定义**，那么它的作用域可以是整个程序，这种情况下**静态变量也会被存放在全局数据区中**。
- 但是如果静态变量是**const类型**的，它就会被存放在全局代码区中。因为const类型的变量是只读的，**放在代码区可以避免被意外修改**。

----------


# 虚函数

## 138.C++ 虚函数和纯虚函数的区别？
[虚函数和纯虚函数的区别](https://blog.csdn.net/hackbuteer1/article/details/7558868)

<font color="#F100">
1.定义一个函数为虚函数，不代表函数为不被实现的函数。

2.定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

3.定义一个函数为纯虚函数，才代表函数没有被实现。
</font>

4.定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

**虚函数只能借助于指针或者引用来达到多态的效果。**

----------


**纯虚函数**：纯虚函数是**在基类中声明的**虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“`=0`” `virtual void funtion1()=0`

**引入原因：**

1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

2、在很多情况下，基类本身生成对象是不合情理的。

**同时含有纯虚拟函数的类称为抽象类，它不能生成对象。**

<font color="#F100">定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。</font>


----------
总结：

1. 纯虚函数声明如下： `virtual void funtion1()=0; `纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2. 虚函数声明如下：`virtual ReturnType FunctionName(Parameter)；`虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3. 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4. 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5. 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6. 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7. 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8. 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。


## 139.什么是动态绑定？
动态绑定是将一个过程调用与相应代码链接起来的行为。是指与给定的过程调用相关联的代码，只有在运行期才可知的一种绑定，他是多态实现的具体形式。

**C++中的实现原理：** 
C++中，通过基类的引用或指针调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。

**虚函数表的实现：**
C++中动态绑定是通过虚函数实现的。而虚函数是通过一张虚函数表（virtual table）实现的。这个表中记录了虚函数的地址，解决继承、覆盖的问题，保证动态绑定时能够根据对象的实际类型调用正确的函数。

**虚函数表的指针位置：**
在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。


## 140.虚函数在什么时候调用？
虚函数在运行时根据实际对象的类型来确定调用哪个函数，而不是根据指针或引用的类型来确定。当一个虚函数被定义为类的成员函数时，它会被标记为虚函数。

在调用虚函数时，程序会查找该函数的实际类型，并在运行时调用该类型的实现。这就允许程序在运行时动态地选择执行哪个版本的虚函数，从而实现多态性。虚函数通常与基类指针或引用一起使用，可以实现基类指针或引用调用派生类的函数。

## 141.虚函数表的大小
虚函数表是一个存储虚函数指针的数组，每个类有一个虚函数表，每个对象有一个指向虚函数表的指针。虚函数表的大小取决于类中有多少个虚函数，而对象中的虚函数表指针的大小取决于编译器和操作系统2。一般来说，在32位系统下，指针占4个字节，在64位系统下，指针占8个字节。

## 142.C++ 中哪些函数不能被声明为虚函数？
**构造函数**：构造函数不能被声明为虚函数。

因为构造函数是用来创建对象的，而虚函数是根据对象的类型来动态调用的。如果构造函数是虚函数，那么在创建对象时就无法确定调用哪个版本的构造函数，会导致逻辑错误

**友元函数**：友元函数实际上并不属于类的成员函数，所以不能被定义为虚函数

**普通函数**：普通函数只能被重载，不能被重写


## 143.为什么虚函数不能是模板函数？
因为模板函数在编译时会被实例化为多个不同的函数，而虚函数需要在运行时才能确定调用哪个函数。在C++中，虚函数的实现依赖于虚函数表（vtable）和虚函数指针（vptr），而这些在编译时就需要确定下来。因此，虚函数不能是模板函数。

## 144.虚函数表既然希望类的所有对象共享为什么不放在全局区？
虚函数表不能放在全局区，因为**全局区是存放全局变量和静态变量的**，而虚函数表不是变量，而是一组指向类成员函数的指针。如果放在全局区，会导致内存浪费和混乱。

混乱：**虚函数表是在编译期就确定了大小和内容的**，而全局区是在运行期才分配空间的。如果把虚函数表放在全局区，就需要在运行期动态地为每个类分配空间，并且要保证不同类之间不会发生冲突。这样就增加了程序的复杂度和出错的可能性。


## 145.菱形继承
菱形继承（Diamond Inheritance）是一种多重继承的情况，其中一个派生类同时继承自两个直接或间接共同基类，而这两个基类又继承自同一个共同的基类。这样就形成了一种菱形的继承结构，因此称为"菱形继承"。

> 假设Person类有一个成员变量_age，Student类的对象中包含了这个 _age 成员，Teacher类的对象中也包含了 _age 成员，但是 Assistant 类依次继承了 Student 和 Teacher类，不考虑其他成员，就最终结果而言，Assistant 类中确实包含了两份 _age 成员。

>**冗余性**：存在重复的数据，比如_age 要存两份
**>二义性**：如果要访问 _age 成员，是访问 Student 类的 _age，还是访问 Teacher类的_age


解决方法：将两个父类添加成 `virtual`，相当于爷爷直接拿出指针给孙子


    
> 其实就是将 Student 类和 Teacher 类重复的部分，放到一个公共位置，访问的时候，直接访问这块公共位置。


## 146.volatile 关键字
在 C++ 中，关键字 volatile 用于声明一个变量是易变的（volatile variable），即该变量可能会在程序中的任意时刻被意外地改变。这意味着，当读取一个易变的变量时，**编译器不会从缓存中读取该变量的值，而是每次都会从内存中重新读取该变量的值**。同样地，当写入一个易变的变量时，编译器也不会将该变量的值存储在缓存中，而是**立即将该变量的值写入内存中**。

## 147.一个参数既可以是 const 还可以是 volatile 吗？为什么？ 
是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为程序不应该试图去修改它。

一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。

volatile 修饰符告诉 complier 变量值可以以任何不被程序明确指明的方式改变，最常见的例子就是外部端口的值，它的变化可以不用程序内的任何赋值语句就有可能改变的，这种变量就可以用 volatil e来修饰，complier 不会优化掉它。

const 修饰的变量在程序里面是不能改变的，但是可以被程序外的东西修改，就象上面说的外部端口的值，如果仅仅使用 const，有可能 complier 会优化掉这些变量，加上 volatile 就万无一失了。


## 148.一个指针可以是volatile吗？为什么？ 
是的。因为指针和普通变量一样，有时也有变化程序的不可控性。

常见例：子中断服务子程序修改一个指向一个 buffer 的指针时，必须用 volatile 来修饰指针。

[一文彻底搞懂volatile用法](https://blog.csdn.net/qq_41709234/article/details/123028868)

# 构造函数

## 149.什么时候调用拷贝构造函数？

- 用已经初始化的对象给另一个初始化的对象赋值
- 函数用对象作为返回值
- 函数用对象作为参数


## 150.析构函数为什么要用虚的？
	A* p = new B;
	delete p;（A是父类 B是子类）
如果不定义虚析构 那么删除P只调用A的析构
定义为虚析构之后，删除P就会调用AB的析构

虚析构函数是为了解决父类指针指向子类对象时，释放子类对象的资源时，释放不完全，造成的内存泄漏问题。

## 151.为什么用移动构造函数？
在C++中，当一个对象被复制时，其内部资源通常会被复制，这可能会导致性能问题，特别是在处理大型数据结构时。

移动语义是指，当一个对象被移动而不是复制时，其内部资源可以被“窃取”，而不需要进行复制操作。移动操作比复制操作更高效，因为它不需要分配新的内存或复制现有的内存。


## 152.C++类内是否可以定义引用？
可以，但是必须使用成员初始化列表为引用变量初始化，构造函数的形参也必须是引用类型，因为引用必须在创建时被初始化，并且不能在其生存期内引用不同的对象。

C++类内可以定义引用成员变量，但要遵循以下三个规则：

- 不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误。
- 构造函数的形参也必须是引用类型
- 不能在构造函数的函数体赋值（为什么不是说初始化呢？因为所有的成员变量都是在初始化列表中完成的），必须在初始化列表中进行初始化。**构造函数分为初始化和计算两个阶段，前者对应成员初始化链表，后者对应构造函数函数体**。引用必须在初始化阶段，也即在成员初始化链表中完成，否则编译时会报错（引用未初始化）。


----------


# 模板


## 153.模板类是什么时候实现的？
模板类的实现不是在程序运行时期间动态生成的，而是在编译阶段根据需要进行实例化和生成对应的代码。这也是为什么在使用模板类时，模板类的声明和定义通常需要放在头文件中，以便编译器在需要的地方进行实例化，并生成相应的代码。

## 154.模板的具体化
当模板使用某种类型类型实例化后生成的类或函数不能满足需要时，可以考虑对模板进行具体化。具体化时可以修改原模板的定义，当使用该类型时，按照具体化后的定义实现，具体化相当于对某种类型进行特殊处理。


## 155.模板的声明和定义为什么不能分开写，要想分开写该怎么做？
模板的声明和定义不能分开写的原因是，编译器在编译模板时需要知道模板的完整定义，才能根据具体的类型参数生成相应的代码。如果只有声明而没有定义，编译器就无法生成正确的代码，链接时就会出现未定义引用的错误。

方法一：一种是在声明文件中包含定义文件；
这样做的好处是可以保持声明和定义的分离，但缺点是每次修改定义文件都需要重新编译所有包含声明文件的源文件。

	// template.cpp
	template <typename T>
	void swap(T& a, T& b) {
	  T temp = a;
	  a = b;
	  b = temp;
	}


法二：在定义文件中显式实例化需要用到的类型参数；这样做的好处是可以避免重复编译和代码膨胀，但缺点是需要提前知道所有可能用到的类型参数，并且每增加一个类型参数都需要修改定义文件。
    
	// template.cpp
	template <typename T>
	void swap(T& a, T& b) {
	  T temp = a;
	  a = b;
	  b = temp;
	}
	
	// explicit instantiation for int and double types
	template void swap<int>(int&, int&);
	template void swap<double>(double&, double&);


## 156.模板的特化，全特化，偏特化

- **模板特化**是指为某些特定类型提供不同于通用模板的具体实现
- **全特化**是指为所有的模板参数都指定具体类型或值的情况
- **偏特化**是指只为部分的模板参数指定具体类型或值，或者限制参数的范围。偏特化只适用于类模板，不适用于函数模板


## 157.模板在编译时生成的代码是否会相同，生成的相同的代码如何处理？
- 一种情况是，如果模板的定义和声明都放在头文件中，并且在多个源文件中被包含和使用，那么编译器会为每个源文件生成相同的模板实例化代码。这样会导致目标文件中存在重复的代码段，增加了目标文件的大小，并且可能引起链接错误。为了避免这种情况，可以使用 extern 关键字来声明一个外部模板，在一个源文件中显式地实例化该模板，并且在其他源文件中只引用该实例化。
- 另一种情况是，如果模板的定义放在一个源文件中，并且在其他源文件中被包含和使用，那么编译器会根据不同的类型参数生成不同的模板实例化代码。这样可以避免重复的代码段，但是**也可能导致链接错误，因为其他源文件无法找到该源文件中定义的模板**。为了避免这种情况，可以将模板的声明放在头文件中，并且在需要使用该模板的源文件中包含该头文件。


## 158.C++构造函数调用顺序

1.     创建派生类的对象，基类的构造函数优先被调用（也优先于派生类里的成员类）；
2.    如果类里面有成员类，成员类的构造函数优先被调用；(也优先于该类本身的构造函数）
3.     基类构造函数如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序而不是它们在成员初始化表中的顺序；
4.     成员类对象构造函数如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序而不是它们出现在成员初始化表中的顺序；
5.     派生类构造函数，作为一般规则派生类构造函数应该不能直接向一个基类数据成员赋值而是把值传递给适当的基类构造函数,否则两个类的实现变成紧耦合的（tightly coupled）将更加难于正确地修改或扩展基类的实现。（基类设计者的责任是提供一组适当的基类构造函数）

综上可以得出，初始化顺序：

父类构造函数–>成员类对象构造函数–>自身构造函数


----------


# STL

## 159.vector 的第二个模板形参？
vector 的第二个模板形参是分配器（allocator），用于分配和管理 vector 内部存储元素的内存。分配器可以控制内存分配的策略，例如内存池等。如果不指定分配器，默认使用 std::allocator。

分配器通常是一个模板类，提供了 allocate 和 deallocate 等成员函数来分配和释放内存。在 vector 内部，使用分配器来分配和释放存储元素的内存，可以方便地替换默认的内存分配器，实现自定义的内存分配策略。

> vecotr 特点：顺序序列、动态数组、尾删有较佳性能

## 160.vector 调用 resize 的时候，如果是元素是一个类，会不会调用这些函数的析构函数？
如果调用 resize 函数使得 vector 的大小变小了，那么后面的元素会被析构掉，也就是会调用元素类的析构函数。如果调用 resize 函数使得 vector 的大小变大了，那么新添加的元素会调用元素类的默认构造函数进行初始化，而不会调用析构函数。

## 161.使用Vector需要注意什么？
- 为避免频繁的扩容操作，可以使用 reserve() 方法在插入元素之前预留一定的空间，以提高性能


- 在使用 vector 进行大量元素操作时，可以使用 emplace_back() 方法而不是 push_back() 方法，以避免元素拷贝的开销
- 在需要删除元素时，可以使用 erase() 方法进行删除。但是，需要注意的是，如果要删除多个元素，应该首先对要删除的元素进行排序，并使用 erase() 方法一次性删除，以避免多次删除操作


> void reserve( size_type new_cap );   //不改变vector的大小size，改变vector的容量capacity


## 162.如果扩容时会引发自定义类型挨个复制构造，C++有什么机制来避免这一点？
在进行 vector 扩容时，如果存储的是自定义类型，会挨个复制构造元素，可能会造成性能问题。为了避免这一点，可以使用移动语义来优化。

在 C++11 引入的移动语义中，我们可以通过 std::move() 函数将一个对象转化为右值引用，这样就可以在元素的拷贝构造函数中实现移动语义，将对象的资源所有权从一个对象转移到另一个对象中，而不是进行深拷贝。


## 163.各种容器的特点
deque 特性：

- 双向队列
- 在两端增删元素有较佳性能

list 特性：

- 双向链表
- 不支持随机存取

set 特性：

- 不允许相同元素
- 自动排序
- 原理：红黑树

map 特性：

- first和second，并且根据first排序
- 实现原理：红黑树
- map不允许容器中有重复的key值元素

红黑树的性质，各种操作时间复杂度：

- 自动排序，稳定
- 查找，插入，删除都是O（logn）

unordered_map

- umap底层是哈希表

## 164.哈希表跟红黑树的比较，优缺点、适用场合，各种操作的时空复杂度

哈希表适合小数据，查找插入删除最好都是O(1)，最坏O(n)，缺点是容易发生哈希冲突，设计哈希函数也比较困难
红黑树适合大数据集，但是代码实现较为复杂


## 165.空间配置器？
在C++ STL中，空间配置器便是用来实现内存空间(一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用 malloc 和 free 实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用链表 free_list 来维护内存池（memory pool），free_list 通过 union 结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

## 166.迭代器用过吗？什么时候会失效？
**顺序容器**使用删除会使后面的迭代器失效（自动往前进一，导致地址全变，所以会失效），解决办法：it=earse(it)，即返回删除元素下一个的迭代器；
**关联容器** map 由于内部是红黑树，使用 erase 不会失效，但是需要记录一下下一个元素的迭代器，list 使用上面两种方法都行

## 167.迭代器和指针的区别？
迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一些操作符，–>、++、–等。迭代器封装了指针，是一个**“可遍历STL（ Standard Template Library）容器内全部或部分元素”**的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。

迭代器相对于指针的优点在于，它提供了一些安全性和抽象性的保证。例如，如果你使用一个指向数组元素的指针，你可以对它进行任何操作，包括越界访问和非法修改等操作，这可能会导致内存错误和程序崩溃。而如果你使用一个vector迭代器，则可以避免这些问题，因为**迭代器会自动检查越界和非法操作，并在出错时抛出异常或者进行其他处理**。


## 168.说说 STL 中 resize 和 reserve 的区别？
capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。

size：指的是此时容器中实际的元素个数。可以通过下标访问 0-(size-1) 范围内的对象。

resize 既修改 capacity 大小，也修改 size 大小；
reserve 只修改 capcaity 大小。

resize 既分配了空间，也创建了对象；reserve 表示容器预留空间，但并不是真正的创建对象，需要通过 insert() 或 push_back() 等创建对象。

## 169.STL 容器动态链接可能产生的问题?
给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。

**产生问题的原因**：容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。


----------


# 新特性

## 170.智能指针
`std::shared_ptr` 是一种共享式智能指针，它可以让多个 `shared_ptr` 实例同时拥有同一个内存资源。`shared_ptr` 内部维护了一个计数器，记录当前有多少个`shared_ptr `实例共享同一块内存。只有当计数器变为 `0` 时，才会自动释放内存。因此，`shared_ptr` 可以避免多个指针指向同一块内存时出现的内存泄漏和悬空指针等问题。

`std::unique_ptr` 是一种独占式智能指针，它可以保证指向的内存只被一个 `unique_ptr` 实例所拥有。当 `unique_ptr` 被销毁时，它所拥有的内存也会被自动释放。
`unique_ptr` 还支持移动语义，因此可以通过 `std::move` 来转移拥有权。

> 使用 release() 方法来移交指向的对象，release方法将一个对象的内存的管理权限丢弃，一般会交给另一个对象。

`weak_ptr` 用来解决 `shared_prt` 相互引用冲突的结果。
> **解决循环引用**：当两个或多个对象相互持有对方的 `shared_ptr`，会形成循环引用，导致对象无法释放。通过将其中一个对象的指针设置为 `weak_ptr`，而不是 `shared_ptr`，可以打破循环引用，避免内存泄漏。
> 
**安全地访问对象**：在需要访问被 `shared_ptr` 管理的对象时，可以通过 `weak_ptr` 的 `lock()` 方法尝试转换为 `shared_ptr`，如果对象仍然存在，则返回一个有效的 `shared_ptr`，否则返回一个空指针。
>
**提高性能**：`weak_ptr` 不会增加对象的引用计数，因此不会影响对象的生命周期，也不会阻止对象的销毁。这样可以更灵活地管理对象的生命周期，提高程序性能。

## 171.怎么知道weak_ptr失效了没?
可以通过`expired()`函数来判断一个 `weak_ptr` 是否已经失效，如果`expired()`返回 `true`，则表示它指向的对象已经被销毁或释放了。另外，使用 `lock()` 函数获取 `weak_ptr` 指向的对象时，如果返回的是一个空的 `shared_ptr`，也可以判断 `weak_ptr` 是否已经失效。

> `bool expired() const noexcept; `函数返回 `weak_ptr` 对象是否是空的，或是它所属的所有者组中不再有 `shared_ptr`。此函数与 `use_count() == 0` 意义相同。
> `shared_ptr<element_type> lock() const noexcept; `函数返回一个 `shared_ptr`，其中包含 `weak_ptr` 对象在未过期时保留的信息。如果 `weak_ptr` 对象已过期（包括它是否为空），该函数将返回一个空的 `shared_ptr`（就像默认构造的一样）。

[weak_ptr 智能指针的使用](https://blog.csdn.net/tianyexing2008/article/details/131249712?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-131249712-blog-120806965.235^v43^pc_blog_bottom_relevance_base8&spm=1001.2101.3001.4242.3&utm_relevant_index=7)

----------

# lambda表达式

**lambda语法：** `[capture] (parameters) mutable ->return-type{statement}`

**[capture]含义：**

- `[]`。没有任何函数对象参数。
- `[=]`。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。
- `[&]`。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。
- `[this]`。函数体内可以使用 Lambda 所在类中的成员变量。
- `[a]`。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。
- `[&a]`。将 a 按引用进行传递。

**（parameters）含义：**

标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&a, &b))
两种方式进行传递。

`[](int x, int y) -> int { return x + y; }` 圆括号 “()” 表示 Lambda 表达式的参数列表，可以包含零个或多个参数。在这个例子中，Lambda表达式有两个参数，分别是一个整数 “x” 和一个整数 “y”

**mutable 或 exception 声明：**

这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。
exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。

**->return-type->**

返回值类型：标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return
的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略

**{statement}{函数体}**

标识函数的实现，这部分不能省略，但函数体可以为空。


## 172.Lambda 表达式如何对应到函数对象？
当定义一个 Lambda 表达式时，编译器会生成一个与 Lambda 表达式对应的新的（未命名的）函数对象类型和该类型的一个对象。这个函数对象可以重载函数调用运算符()，从而具有类似函数的行为。

## 173.圆括号传参数是如何实现的？
圆括号传参数是通过函数调用运算符()来实现的。

当你使用圆括号传递参数给一个 lambda 表达式时，实际上是调用了它生成的函数对象的函数调用运算符()，并将参数传递给它。

函数调用运算符()会根据 lambda 表达式的定义来执行相应的代码，并返回一个值（如果有的话）。

所以，你**可以把圆括号传参数看作是一种调用函数对象的方式**，它让你不需要知道函数对象的名字或者类型就可以使用它。

## 174.方括号捕获外部变量（闭包）是如何实现的?
**闭包**是一个捕获了全局上下文的常量或者变量的函数，通俗来讲，闭包可以是常量也可以是函数

方括号捕获外部变量（闭包）是通过**将外部变量作为函数对象的成员**来实现的。

当你在方括号中指定一个外部变量时，编译器会为你生成一个函数对象类型，它包含了这个外部变量作为它的一个成员。

当你创建一个函数对象时，这个成员会被初始化为外部变量的值或者引用，这取决于你是用`=`还是`&`来捕获它。

当你调用函数对象时，这个成员就可以在 lambda 表达式中使用，就像一个普通的局部变量一样。

所以，你可以把方括号捕获外部变量看作是一种创建闭包的语法糖，它让你不需要显式地定义一个类或者接口来保存外部变量的状态。

- **值捕获（capture by value）**：使用 “=”
-将外部变量按值进行捕获。Lambda表达式会在创建时将外部变量的值复制一份到闭包中
- **引用捕获（capture by reference）**：使用 “&”。将外部变量按引用进行捕获。Lambda表达式会在创建时绑定到外部变量的内存地址，以便在Lambda表达式中修改变量的值
- **隐式捕获** ：使用 “[]” 作为空方括号，表示隐式捕获所有在Lambda表达式中使用的外部变量。在Lambda表达式中使用的变量会被自动按值进行捕获。

	对于值捕获和隐式捕获，Lambda表达式在创建时会复制一份外部变量的值到闭包中，如果在Lambda表达式中修改闭包中的变量值，不会影响外部变量的值。而对于引用捕获，Lambda表达式会直接操作外部变量，可以改变其值。



----------



# 右值引用
右值引用是C++11引入的一种引用类型，它用于表示临时对象和即将销毁的对象。

**左值**是指可以出现在赋值运算符左边的表达式，也就是***具有内存地址且可被取地址的表达式***。通常来说，变量、对象以及可以引用的表达式都是左值。左值表示的是一个具体的内存位置，可以对其进行读取和写入操作。

**右值**是指不能出现在赋值运算符左边的表达式，通常是***临时性的、不具有明确内存地址的值***。字面常量、临时对象、函数返回值等都属于右值。右值表示的是一个临时的值，不能被取地址。

**左值引用**是 C++ 中最常见的引用类型，用于绑定到左值表达式上。左值引用通过 & 符号表示。

**右值引用**是 C++11 引入的一个重要特性，用于绑定到临时对象或右值表达式上，以支持移动语义和完美转发。右值引用通过 && 符号表示。

	int num = 10;
	//int && a = num;  //右值引用不能初始化为左值
	int && a = 10;
和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：
	
	int&& a = 10;
	a = 100;
	std::cout << a << std::endl;//输出100
右值引用的具体案例包括移动语义和完美转发




## 175.移动语义？
移动语义是 C++11引入的重要特性，旨在**提高资源管理的效率和性能**。

在传统的拷贝操作中，对象的资源是通过复制（拷贝构造函数）的方式从一个对象传递到另一个对象，这会涉及到深拷贝操作，即将资源完全复制一份，导致了额外的开销。

而移动语义则引入了右值引用和移动构造函数（移动赋值运算符），允许对象的资源在不需要进行深拷贝的情况下进行高效地转移。简单的理解，**移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”**。换句话说，就是以浅拷贝的方式复制指针，然后将原指针置为空指针。**移动构造函数就是通过移动语义的方式来初始化对象的。**

	std::vector<int> vec1 = {1, 2, 3};
	std::vector<int> vec2 = std::move(vec1);


## 176.如何将左值强制转换为右值？
move函数

	int x = 10;
	int&& r = move(x);   //将左值强制转换为右值

## 177.移动构造函数和拷贝构造函数的区别？
- 拷贝构造函数用于创建一个新对象，并将其初始化为**已存在的对象的副本**。这个过程通常涉及到**内存的分配和数据的复制**，因此它可能比较昂贵。
- 移动构造函数用于创建一个新对象，并将其初始化为**另一个对象的资源所有权的转移**。这个过程通常涉及到**指针的复制**，而不是数据的复制，因此它通常比拷贝构造函数更加高效。移动构造函数通常会使用右值引用来接受一个临时对象或者一个即将被销毁的对象，并将其资源所有权转移到新对象中。

## 178.转发和完美转发？
转发是指在函数中将参数按照原始的类型和值，转发给另一个函数。

**常规转发** 是指将参数通过传值或引用的方式传递给另一个函数，这是C++中的传参方式。
但是在传递参数时，会存在一些问题。例如，当我们想把一个右值参数传递给一个函数时，我们可能会遇到编译器错误。另一个例子是当我们要将一个右值参数转发给一个函数时，但是我们不知道该使用传值还是传引用，因为这个决定取决于被调用的函数的定义。为了解决这些问题，C++11 引入了完美转发。

在常规转发中，参数被传递给了被调用函数，但是它们的类型都是引用类型，因此**在函数内部处理时，不会进行任何类型转换**。也就是说，**如果我们传递给常规转发的参数是一个左值，那么被调用函数内部处理时，它们依然是左值引用；如果我们传递的是一个右值，那么它们依然是右值引用**。这样可能会导致一些效率问题，比如如果被调用函数需要将参数进行复制，那么这个过程可能会比较耗时。
	
	//错误案例
	void func(int&& x) {
	    std::cout << "传递右值参数：" << x << std::endl;
	}
	
	template <typename T>
	void wrapper(T&& arg) {
	    func(arg);  // 尝试将通用引用参数传递给接受右值引用的函数，会导致编译错误
	}
	
	int main() {
	    int value = 42;
	    wrapper(std::move(value));  // 将左值转换为右值传递给 wrapper
	    return 0;
	}
**普通的引用传递无法正确地将右值参数传递给接受右值引用的函数**，这种情况下需要使用完美转发来解决。

**完美转发** 是指将参数以原始的类型和值传递给另一个函数，并保留其右值或左值特性。
这可以通过使用转发引用（forwarding reference）和 std::forward 函数来实现。**转发引用是一种通用引用，它可以引用任何类型的值，并且可以保留值的右值或左值特性。** 当我们使用转发引用作为函数的参数时，我们可以在函数内部使用 `std::forward` 来将参数转发给另一个函数，以保留参数的右值或左值特性。

- 必须使用转发引用作为参数类型。
- 必须使用 std::forward 函数进行转发
- 被转发的参数必须是右值或左值引用。


在完美转发中，我们使用了转发引用 `T&&`，并在函数内部使用了 `std::forward` 函数来进行类型转换。这样可以保留参数的原有类型特性，使得被调用函数内部处理时，参数的类型会根据传递给它的参数类型进行调整，从而避免了一些不必要的类型转换操作。此外，通过完美转发，我们还可以保留参数的右值特性，避免了一些额外的复制操作，从而提高了代码的效率。

	void func(int& x) {
	    std::cout << "传引用：" << x << std::endl;
	}
	template <typename T>
	void wrapper(T&& arg) {
	    func(std::forward<T>(arg));  // 使用 std::forward 进行完美转发
	}
	int main() {
	    int value = 42;
	    wrapper(value);  // 正确地将左值参数传递给 wrapper，然后再传递给 func
	    return 0;
	}

----------


# Static 关键字

**面向过程**

**静态全局变量**：静态全局变量在声明它的整个文件中都是可见的，而在文件之外是不可见的；（作用域是整个文件）变量的生存周期存在于整个程序运行期间。

**静态局部变量**：内存存放在程序的全局数据区中，静态局部变量在程序执行到该对象声明时，会被首次初始化。其后运行到该对象的声明时，不会再次初始化（只会被初始化一次），变量的生存周期存在于整个程序运行期间。

> 无论是静态全局变量还是静态局部变量都存放在全局区

**静态函数（主要目的确定作用域）**：作用域只在声明它的文件当中，不能被其他文件引用，其他文件可以定义同名的全局函数，其他文件想要调用本文件的静态函数，需要显式的调用 extern 关键字修饰其声明。

**面向对象**

**静态成员变量**：用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。
> 诞生比构造函数早，在类声明的时候就产生了；
静态数据成员必须显式的初始化分配内存，在其包含类没有任何实例化之前已经有内存分配；

静态数据成员与其他成员一样，遵从`public,protected,private`的访问规则；静态数据成员内存存储在全局数据区，只随着进程的消亡而消亡。

静态数据成员不进入程序全局命名空间，不会与其他全局名称的同名同类型变量冲突，静态数据成员可以实现C++的封装特性，由于其遵守类的访问权限规则，所以相比全局变量更加灵活；

**静态成员函数**：静态成员函数不能访问非静态(包括成员函数和数据成员)，但是非静态可以访问静态。

在没有实例化的类对象的条件下可以调用类的静态成员函数；
**静态成员函数中没有隐含的 this 指针，所以静态成员函数不可以操作类中的非静态成员**（类的非静态成员是在类实例化后存在的，而类的成员函数可以在类没有实例化的时候调用，故不能操作类的非静态成员）；

**初始化**

对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。

而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造（静态全局和静态局部）。
然而，静态成员变量与静态局部变量和全局变量不同，它们必须在类的外部进行初始化，并且在程序开始执行之前就已经被分配内存并初始化了。


----------

# C++ 编译过程
- 预编译：在预处理阶段，预处理器会处理以#开头的预处理指令，比如#include、宏定义等。预处理器会展开头文件，替换宏定义，并进行条件编译等操作，生成一个被预处理后的源文件。
- 编译：编译阶段是将预处理后的源文件翻译成汇编代码的过程。编译器会对源代码进行词法分析、语法分析、语义分析和优化，最终生成相应的汇编代码。
- 汇编：汇编阶段将上一步生成的汇编代码翻译成目标文件。汇编器会将汇编代码转换成机器指令，生成一个二进制目标文件（.obj 文件或 .o 文件）。
- 链接：链接阶段是将多个目标文件和库文件合并成一个可执行文件的过程。链接器会解析目标文件之间的引用关系，填充地址空间，解决符号重定位，并将它们合并成一个可执行文件（.exe 文件或可执行程序）。

**动态链接和静态链接**

**静态**：连接的时候就把需要的函数或者过程放进了可执行文件中，即使静态库删除了依旧可以运行；

**动态**：是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，动态库删除就找不到函数了。


----------


# 内联函数
如果函数是内联的，编译器在编译时，会把内联函数的实现替换到每个调用内联函数的地方，可以与宏函数作类比，但**宏函数不会进行类型检查**。


## 179. 内联函数的意义？
引入内联函数主要是解决一些频繁调用的小函数消耗大量空间的问题。

通常情况下，在调用函数时，程序会将控制权从调用程序处转移到被调用函数处，在这个过程中，传递参数、寄存器操作、返回值等会消耗额外的时间和内存，如果调用的函数代码量很少，也许转移到调用函数的时间比函数执行的时间更长。

## 180.哪些不适合作为内联函数？
1. 递归调用本身的函数
1. 包含复杂语句的函数，例如：for、while、switch 等；
1. 函数包含静态变量（内联函数的定义和调用是在编译期进行的，而不是在运行期。编译器会将内联函数的代码直接嵌入到调用它的地方，从而避免了函数调用的开销。但是，这也意味着每次调用内联函数时，都会生成一份新的函数代码。
**如果内联函数中有静态变量，那么每次生成新的函数代码时，也会生成新的静态变量。这样就会导致多个静态变量共存于程序中，并且互相独立，无法保持一致性**）；

## 181.使用内联的缺点？
如果使用很多内联函数，生成的二进制文件会变大；

编译的时间会增加，因为每次内联函数有修改，就需要重新编译代码。

所以，并不是所有函数都要声明为内联函数，需要视具体情况而定。

## 182. 内联函数和宏的区别?
**宏函数是在预编译的时候把所有的宏名用宏体来替换**，简单的说就是字符串替换 ；而**内联函数则是在编译的时候进行代码插入**，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

**宏定义是没有类型检查的**，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型检查，内联函数满足函数的性质，比如有返回值、参数列表等

----------


# 程序启动的过程?
1. 加载可执行程序：操作系统根据可执行的文件信息，分配进程空间，将代码段，数据段，BSS段等映射到进程的虚拟空间中
1. 初始化：操作系统调用C++运行库的初始化代码，进行初始化，包括初始化全局变量，构造静态对象等
1. 调用main（）函数
1. 根据程序设计和逻辑，在运行过程中，可能需要分配动态内存、创建新的线程、进行 I/O 操作等。
1. 退出：当 main() 函数执行完毕，或者调用 exit() 函数结束程序运行，操作系统会回收进程空间和资源，完成程序的退出过程。
2. 

----------


# 多态
静态多态：编译器在编译期间完成的，编译器会根据实参类型来推断该调用哪个函数，如果有对应的函数，就调用，没有则在编译时报错。

动态多态

## 183.动态绑定是什么？
**动态绑定是指在运行时确定函数的实际调用函数**。如果一个函数被声明为虚函数，那么在运行时就可以使用动态绑定，使得调用正确的实现。这种绑定通常是通过虚函数表（Virtual Table）来实现的，虚函数表是一个存储指向虚函数地址的指针数组，每个包含虚函数的类都有一个虚函数表。例如调用 ptr->speak() 时，根据指针实际指向的对象类型进行动态绑定，调用相应的 speak() 实现

## 184.多态的好处?
增强程序的可扩充性，即程序需要修改或增加功能时，只需改动或增加较少的代码。简化代码，使得不同的子类对象都可以使用同一个名称的函数，而具有不同的实现。实现动态绑定，即在运行时根据对象的实际类型来调用相应的虚函数。


## 185.多态的形式
- 虚函数多态
- 类模板多态
- 重载多态

## 186.32位整型在大小端的区别
小端：78 56 34 12(低位在低字节)
大端：12 34 56 78(低位在高字节)

## 187.内存对齐
经过内存对齐之后，CPU 的内存访问速度大大提升。因为 CPU 把内存当成是一块一块的，块的大小可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是一块一块进行读取的，**块的大小称为内存读取粒度**。

比如说 CPU 要读取一个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进行处理即可。

如果数据是从 1 字节开始的，就首先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4字节的数据进入寄存器，所以说，当内存没有对奇时，寄存器进⾏了很多额外的操作，大大降低了 CPU 的性能。

## 188.内存对齐的原因？
**平台原因**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

**性能原因**：应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次就可以了。

## 189.什么时候不应该内存对齐？
什么时候不希望进行内存对齐呢？一般来说，当我们追求空间效率而不是时间效率时，我们可以选择取消或者减小内存对齐。例如，在嵌入式系统中，由于资源有限，我们可能更关心节省空间而不是提高速度。此时我们可以使用编译器提供的选项来调整或者关闭内存对齐。

## 190.内存对齐的规则？
- 对于结构体的各个成员，第一个成员位于偏移为 `0` 的位置，结构体第一个成员的偏移量( `offset` )为  `0`，以后每个成员相对于结构体首地址的 `offset` 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
- 有效对齐值是给定值 `#pragma pack (n) `和结构体中最长数据类型长度中较小的那个，其中 ` n ` 是编译器提供的选项，可以是 `1,2,4,8,16` 等。
- 除了结构成员需要对齐，结构本身也需要对齐，结构的长度必须是编译器默认的对齐长度和成员中最长类型中最小的数据大小的倍数对齐。

## 191.指针和引用的区别？
引用和引用变量共同占一个空间，可以说，指针看的是地址，引用看的是变量本身，所以引用更加安全（不能取到引用本身的地址。如果去取引用的地址，编译器会帮你变成去所指向变量的地址。所以对引用取地址，其实取到的是所指向的值的地址）

## 192.浅拷贝和深拷贝的区别？
浅拷贝只复制指针，新旧两个东西共享同一块内存，当对象拥有动态分配的内存时，使用浅拷贝可能会导致资源泄露或内存访问错误
深拷贝会创建一个新的对象，包括内存，这意味着每个对象都有自己独立的内存副本，即使一个对象被改变，另一个也不会受影响

## 193.struct和class的区别？
struct默认公有继承，class默认私有继承;

struct内不能声明函数，class可以

## 194.导入 C 函数的关键字是什么，C++ 编译时和 C 有什么不同？
- C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

- 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而 C 语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

## 195.函数指针
- 函数A（）；
- 函数B（）；
- Bfuc(A);
- B就是回调

- 意义：因为传进来的函数是不确定的。可以传函数1，也可以传函数2，直接在函数体里面调用就写死了，可以用这种方法实现多态。


## 196.new 和 malloc？
- new是操作符 malloc是函数
- new在调用的时候先分配内存，再调用构造函数，释放的时候先调用析构，后释放内存；而 malloc 没有构造函数和析构函数。
- new 发生错误抛出异常，malloc 返回 null
- new 返回具体类型指针，malloc 需要强制转换

## 197.delete 如何知道该释放多大的空间，这些信息存在什么位置？
- 一种是在分配内存时，在内存首地址之前存储一个额外的值，表示数组的大小或者元素个数。这样，在释放内存时，就可以根据这个值来确定要释放多少空间。
- 另一种是在编译时，编译器会记录数组类型和大小的信息，并在生成代码时，将这些信息传递给delete[]操作符。这样，在运行时，delete[]就可以根据类型和大小来调用相应的析构函数和free函数

## 198.delete[]和delete的区别，基本数据类型的数组使用delete可以释放完全吗？
当new申请的是C++对象数组时，delete和delete []差别就很大了，delete只会析构一个对象
delete和delete[]的区别主要在于是否调用析构函数。如果用delete[]，则在回收空间之前所有对象都会首先调用自己的析构函数。基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用delete和delete[]都是应该可以的；但是对于类对象数组，只能用delete[]。否则可能会造成内存泄漏或者其他错误。