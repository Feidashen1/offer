## 1.C和C++的区别
**设计思想上：** C++是面向对象的语言，而C是面向过程的结构化编程语言。

**语法上：**

C++具有封装、继承和多态三大特性。

C++相比较C，增加了许多类型安全的功能，比如强制类型转换、智能指针。

C++支持泛型编程，比如模板类，函数模板等。


## 2.构造函数后面的冒号有什么用？
在构造函数后面加冒号，表示冒号后面接构造函数初始化列表（constructor initialize list），主要有三种应用场景：

1. 对基类进行初始化;
2. 对类成员进行初始化;
3. 对类的const成员变量进行初始化;

由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或者使用初始化列表赋值。


## 3. 函数后面 = default 和 = delete 有什么用？
[http://t.csdnimg.cn/hUk79](http://t.csdnimg.cn/hUk79 "http://t.csdnimg.cn/hUk79")

`=defalut`使得被修饰的函数为编译器默认的形式。只能用于（类的）特殊的成员函数（默认构造函数，复制构造函数，析构函数等）。

`=delete`使得编译器禁止该类型的成员函数生成。例如：1.禁用拷贝构造函数；2.禁用不需要用的参数转换。

对特殊成员函数使用以上修饰符使得代码更容易阅读。


## 4.类的大小和什么有关系？

平时所声明的类只是一种类型定义，它本身是没有大小可言的。

这里所说的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。

类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员均对类的大小无影响。


<font color="#F100">静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类的所有对象共享，并不属于哪个对象。</font>

虚函数对类的大小有影响，是因为虚函数表指针带来的影响；
虚继承对类的大小有影响，是因为虚基表指针带来的影响。

[http://t.csdnimg.cn/FR01C](http://t.csdnimg.cn/FR01C "http://t.csdnimg.cn/FR01C")
**c++空类（这个类不带任何数据）的大小不为0，为1。**


因为：new需要分配不同的内存地址，不能分配内存大小为0的空间，避免除以 sizeof(T)时得到除以0错误，故使用一个字节来区分空类。

## 5.struct 和 typedef struct 什么区别？
C ：

	typedef struct student {
		int a;
	}Stu;

这时声明变量就可以：`Stu stu1;`
如果上面没有加 `typedef` 就必须用 `struct student stu1` 来声明。这里的 `Stu` 实际上就是 `struct Student` 的别名。
另外这里也可以不写 `Student typedef struct {}Stu`; 那声明变量的时候就不能`struct Student stu1;`了只能`Stu stu1;`）


C++:

1. `struct name {int a;}stu;` 这里 `stu` 是一个变量。
2. `typedef struct name{int a;}stu;`这里的 `stu` 是一个结构体类型。


## 6.函数后面加const
`const` 只能加在类的成员函数后面（普通函数不可以），也就是说这些成员函数是只读函数。

1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）

2、加了cosnt的成员函数，表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）
非静态成员函数后面加 `const` 和 `mutable` 是反义词


加了 `const` 的成员函数可以被 非const对象 和 const对象调用。**注意是对象**。

但不加 `const` 的成员函数只能被 非const对象 调用。

<font color="#A100">函数前面加 cosnt 表示返回值是 const，函数后面加 const 表示不可以修改 class 的成员。</font>



## 7.共享数据的保护
1.常引用：所引用的形参不能被更新

	void display(const double& a);

2.常对象：在生存期内不能被更新，但必须被初始化

	A const a(3, 4);

3.常成员函数：不能修改对象中数据成员，也不能调用类中没有被const修饰的成员函数（常对象唯一的对外接口）。如果声明了一个常对象，则该对象只能调用它的常函数！另外，可以用于对重载函数的区分。

	void print();
	void print() const;

4.extern int a;使得其他文件也能访问该变量

声明一个函数或定义函数时，冠以 `static` 的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数（每一个cpp文件就是一个编译单元）


## 8.运算符重载注意
单目运算符最好重载为成员函数，双目最好为友元函数。

`=、[]`只能重载为成员函数，`<<`和`>>`只能重载为友元函数。


## 9.程序内存分配方式以及它们的区别
内存分配大致上可以分成5块：

1. **栈区（stack）**：栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）
1. **堆区（heap）**：一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆时两回事，分配方式类似于链表。
1. **全局区（静态区）（static）**：全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
1. **常量存储区**：常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
1. **程序代码区**：存放函数体的二进制代码。


## 10.全局变量、全局静态变量、静态变量、静态函数

### 全局静态变量和全局变量的区别
1.若程序由一个源文件构成时，全局变量与全局静态变量没有区别；

2.若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即全局静态变量对组成该程序的其他源文件时无效的；

3.具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。

静态变量只被所属源文件使用。


### static的作用
**1、全局静态变量**

在全局变量前加上关键字 `static`，全局变量就被定义成一个全局静态变量。

**存放区**：存放在静态存储区，在整个程序运行期间一直存在。

**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

**作用域**：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

**2、局部静态变量**

在局部变量前加上关键字 `static`，局部变量就被定义成一个局部静态变量。

**存放区**：静态存储区。

**初始化**：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

**作用域**：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

**3、静态函数**

在函数返回类型前加 `static`，函数就被定义为静态函数。函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。
这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**warning**：（没懂）不要在头文件中声明 `static` 的全局函数，不要在cpp内声明 非static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中去，否则cpp内部声明需加上static修饰。

**4、类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**5、类的静态函数**
静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用 `class_name::static_func()` 就可以访问。

### 静态成员函数与普通成员函数的区别
静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）

普通成员函数有this指针，可以访问类中的任意成员（普通成员变量和静态成员变量，好像静态成员函数没有this指针不能通过this访问，但是可以通过类名::访问）；而静态成员函数没有this指针。


## 11.new delete 与 malloc free的联系与区别
`new delete `和 `malloc free`都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄漏或者二次释放。

不同的是，`new delete`是C++`中定义的操作符`，`new` 除了分配空间外，还会调用类的构造函数来完成初始化工作，delete 除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。


## 12.explicit
`explicit` 关键字只能用于类的构造函数的声明上。它的作用是防止构造函数进行的隐式转换。

在C++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担了两个角色：

第一是构造；

第二是默认且隐含的类型转换操作符。即如果构造函数接收到的参数会默认进行隐式转换。

隐式转换看起来很方便，但是某些情况下违背了程序员的本意。这个时候就要加上explicit修饰，指定这个构造器只能被明确的调用/使用，不能进行隐式转换。

	class A
	{
	public:
	    explicit A(int a, int b) : m_a(a), m_b(b) {};
	private:
	    int m_a;
	    int m_b;
	}
	
	int main()
	{
	    A test(1, 2); //正确
	    A test1(2.2, 2); // 错误，存在double->int的隐式转换。
	}


## 13.c++的四种 cast 转换
cast转换是C++的强制转换：`cast-name<target_type>(expression);`

1、`const_cast`
唯一一个可以改变const性质的转换

2、`static_cast`
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

3、`dynamic_cast`
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果时非法的对于指针返回 `null`，对于引用抛出异常。要深入理解内部转换的原理。

向上转换：指的是子类向基类的转换。
向下转换：指的是基类向子类的转换。

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、`reinterpret_cast`
几乎什么都可以转，可能会出问题，尽量少用。

## 14.为什么不用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

C的强制转换 `(type_name)expression`



## 15.mutable关键字
`mutable` 的中文意思时可变的、易变的，跟 constant（即C++里的const）是反义词。在C++中，mutable 也是为了突破 const 的限制而设置的。被 mutable 修饰的变量（**`mutable`只能用于修饰类的非静态数据成员**），将永远处于可变的状态（可以修改成员数据之类的），即使在一个const函数中。

# 16.用const修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 `const` 修饰，那么函数返回值（即指针）的内容不能修改，且该返回值只能被赋给加 `const` 的同类型指针。一般只在返回值为引用或指针时使用，返回其他值时没有必要。

	const char* get_string(void);
	char *str = get_string();//编译报错
	const char *str = get_string();//正确

## 17.宏、const、enum
`#define`不被视为语言的一部分（#define属于预处理器）。

对于单纯常量，最好用 `const` 对象或者 `enum` 替换`#define`。

对于类似函数的宏，尽量使用内联函数替换掉 `#define`


**编译器处理方式不同**: `define` 宏是在预处理阶段展开; `const` 常量是在编译运行阶段使用。

**类型**：
`define` 宏没有类型，不做任何类型检查，仅仅是展开；
`const` 常量没有具体的类型，在编译阶段会执行类型检查。

**起作用的方式**：`#define` 只是简单的字符串替换，没有类型检查。而 `const` 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。正因为 `define` 只是简单的字符串替换，会导致边界效应，很容易犯错。

	#define N 2+3
	const double a = N/2; //结果是2+3/2 = 2+1 = 3
	const double b = (double)N / (double)2;
	//我们预想的答案是2.5，可实际输出的值是2 + 3 / 2 = 3.5


**占用空间**：
`define` 宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，占用代码段空间；
`const` 常量会在内存中分配（可以是在堆中也可以是在栈中） 占用数据段空间

**调试角度**：
`const` 常量是可以进行调试的，`#define` 不能进行调试，因为在预编译阶段就已经替换掉了。

**作用域**：`const` 变量是由作用域的，`#define` 在没有遇到 `#undefine` 之前是没有作用域限制的。

## 18.程序编译
程序编译是指将源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。便已产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。

## 19.class 和 struct 的区别
c++中，class 和 struct 都可以定义一个类。
它们有以下两点区别：

1、默认继承权限，如果不指定，来自 class 的继承按照 private 继承处理，来自struct 的继承按照 public 继承处理。

2、成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是public权限。

## 20.C++ 默认编写并调用了哪些函数
编译器会主动为用户编写的任何类声明一个拷贝构造函数、拷贝复制操作符和一个析构函数，同时如果声明生命任何构造函数，编译器也会为你声明一个 `default` 版本的拷贝构造函数，这些函数都是 `public` 且 `inline` 的。

注意，上边说的是声明，只有当这些函数有调用需求的时候，编译器才会帮你去实现它们。但是编译器替你实现的函数可能在类内引用、类内指针、有const成员以及类型有虚属性的情形下会出问题：

1. 对于拷贝构造函数，要考虑到类内成员有没有深拷贝的需求，如果有的话就需要自己编写拷贝构造函数/操作符，而不是把这件事情交给编译器来做。
1. 对于拷贝构造函数，如果类内有引用成员或 `const` 成员，需要自己定义拷贝行为，因为编译器替你实现的拷贝行为在上述两个场景很有可能是有问题的。
1. 对于析构函数，如果该类有多态需求，请主动将析构函数声明为 `virtual`

## 21.为多态基类声明 virtual
带有多态性质的基类必须将析构函数声明为虚函数，防止指向子类的基类指针在被释放时只局部销毁了该对象。

如果一个类有多态的内涵，那么几乎不可避免的会有基类的指针（或引用）指向子类对象，因为非虚函数没有动态类型，所以如果基类的析构函数不是虚函数，那么在基类指针析构时会直接调用基类的析构函数，造成子类对象仅仅析构了基类的那一部分，有内存泄漏的风险。

除此之外，还需注意：

1. 需要注意的是，普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价。
1. 如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为 `final` （C++ 11），这样禁止派生可以防止误继承造成上述问题。
1. 编译器自动生成的析构函数时非虚的，所以多态基类必须将析构函数显示声明为virtual。


## 22.禁止使用编译器自动生成的函数
如果类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么就应该禁止编译器去自动生成它：

1. 将被禁止生成的函数声明为 `private` 并省略实现，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。
1. 将上述的可能的链接错误转移到编译期间。设计一不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂。
2. C++11可以直接使用 `= delete` 来声明拷贝构造函数，显示禁止编译器生成该函数。


## 23.别让异常逃离析构函数
析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。

析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明抛出异常后的代码无法再继续执行，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃。

在析构函数中只负责记录，需要时刻保证析构函数能够执行到底


## 24.不要在构造和析构过程中调用 virtual 函数
在多态环境中，需要重新理解构造函数和析构函数的意义，这两个函数在执行过程中，涉及到了对象类型从基类到子类，再从子类到基类的转变。

一个子类对象开始创建时，首先调用的是基类的构造函数，在调用子类构造函数之前，**该对象将一直保持着“基类对象”的身份而存在**，自然在基类的构造函数中调用的虚函数——将会是基类的虚函数版本，在子类的构造函数中，**原先的基类对象变成了子类对象**，这时子类构造函数里调用的是子类的虚函数版本。

这是一件有意思的事情，这说明**在构造函数中虚函数并不是虚函数**，在不同的构造函数中，调用的虚函数版本并不同，因为随着不同层级的构造函数调用时，对象的类型在实时变化。那么相似的，析构函数在调用的过程中，子类对象的类型从子类退化到基类。


因此，如果无法在基类的构造函数中调用子类的虚函数。


## 25.在 operator= 中处理“自我赋值”
自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要假借指针来实现：

	*pa = *pb;		 			//pa和pb指向同一对象，便是自我赋值。
	arr[i] = arr[j];		//i和j相等，便是自我赋值


那么对于管理一定资源的对象重载的 `operator =`  中，一定要对是不是自我赋值格外小心并且增加预判，因为无论是深拷贝还是资源所有权的转移，原先的内存或所有权一定会被清空才能被赋值，如果不加处理，这套逻辑被用在自我赋值上会发生——先把自己的资源给释放掉了，然后又把以释放掉的资源赋给了自己——出错了

第一种做法是在赋值前增加预判，但是这种做法没有异常安全性，试想如果在删除掉原指针指向的内存后，在赋值之前任何一处抛出了异常，那么原指针就指向了一块已经被删除的内存。
    
    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      if (this == &rhs) return *this;
      
      delete ptr;	
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr将指向一块已经被删除的内存。
      return *this;
    }


如果我们把异常安全性也考虑在内，那么我们就会得到如下方法，令人欣慰的是这个方法也解决了自我赋值的问题。

    SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      DataBlock* pOrg = ptr;
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr仍然指向之前的内存。
      delete pOrg;
      return *this;
    }



另一个使用copy and swap技术的替代方案。


## 26.复制对象时勿忘其每一个成分

当你给类多加了成员变量时，不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。如果忘记处理，编译器也不会报错。

如果类有继承，那么在为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是 `private` 的，所以无法访问它们，应该让子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数：

    //在成员初始化列表显示调用基类的拷贝构造函数
    ChildClass::ChildClass(const ChildClass& rhs) : BaseClass(rhs) {		
      	// ...
    }


除此之外，拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个。

其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此**前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。**


## 27.设计 class 犹如设计 type
每次设计class时最好在脑中过一遍以下问题：

1. 对象该如何创建销毁：包括构造函数、析构函数以及 new 和 delete 操作符的重构需求。
1. 对象的构造函数与赋值行为应有何区别：构造函数和赋值操作符的区别，重点在资源管理上。
1. 对象被拷贝时应考虑的行为：拷贝构造函数。
1. 对象的合法值是什么？最好在语法层面、至少在编译前应对用户做出监督。
1. 新的类型是否应该复合某个继承体系，这就包含虚函数的覆盖问题。
1. 新类型和已有类型之间的隐式转换问题，这意味着类型转换函数和非explicit函数之间的取舍。
1. 新类型是否需要重载操作符。
1. 什么样的接口应当暴露在外，而什么样的技术应当封装在内（public和private）
1. 新类型的效率、资源获取归还、线程安全性和异常安全性如何保证。
1. 这个类是否具备template的潜质，如果有的话，就应改为模板类。


## 28.函数接口应该以const引用的形式传参，而不应该是按值传参

1. 按值传参涉及大量参数的复制，这些副本大多是没有必要的。
1. 如果拷贝构造函数设计的是深拷贝而非浅拷贝，那么拷贝的成本将远远大于拷贝某几个指针。
1. 对于多态而言，将父类设计成按值传参，如果传入的是子类对象，仅会对子类对象的父类部分进行拷贝，即部分拷贝，而所有属于子类的特性将被丢弃，造成不可预知的错误，同时虚函数也不会被调用。
1. 小的类型并不意味着按值传参的成本就会小。首先，类型的大小与编译器的类型和版本有很大关系，某些类型在特定编译器上编译结果会比其他编译器大得多。小的类型也无法保证在日后代码复用和重构之后，其类型始终很小。


## 29.对class内所有成员变量声明为private，private意味着对变量的封装

简单的来说，把所有成员变量声明为 private 的好处有两点。首先，所有的变量都是private了，那么所有的 public 和 protected 成员都是函数了，用户在使用的时候也就无需区分，这就是语法一致性；其次，对变量的封装意味着，**可以尽量减小因类型内部改变造成的类外外代码的必要改动**。

**public 和 protected属性在一定程度上是等价的**。一个自定义类型被设计出来就是供客户使用的，那么客户的使用方法无非是两种——用这个类创建对象或者继承这个类以设计新的类——以下简称为第一类客户和第二类客户。

从封装的角度来说，一个 public 的成员说明了类的作者决定对类的第一种客户不封装此成员，而一个 protected 的成员说明了类的作者对类的第二种客户不封装此成员。


## 30.若所有参数皆需类型转换，请为此采用non-member函数

如果我们在使用操作符时希望操作符的任意操作数都可能发生隐式类型转换，那么应该把该操作符重载成非成员函数。

首先说明：**如果一个操作符是成员函数，那么它的第一个操作数（即调用对象）不会发生隐式类型转换。**

操作符一旦被设计为成员函数，它在被使用时的特殊性就显现出来了——单从表达式无法直接看出是类的哪个对象在调用这个操作符函数

做为成员函数的操作符默认操作符的第一个操作数应当是正确的类对象——**编译器根据第一个操作数的类型来确定被调用的操作符到底属于哪一个类的**。

举例说明：当 `Ratinoal` 类的构造函数允许 `int` 类型隐式转换为 `Rational` 类型时，`Rational z = x + 2;`是可以通过编译的，因为操作符是被 `Rational` 类型的 `x` 调用，同时将 `2` 隐式转换为 `Ratinoal` 类型，完成加法。但是 `Rational z = 2 + x;`却会引发编译器报错，因为由于操作符的第一个操作数不会发生隐式类型转换，所以加号“+”实际上调用的是`2`——一个 `int` 类型的操作符，因此编译器会试图将 `Rational` 类型的 `x` 转为 `int`，这样是行不通的。


## 31.子类必须涵盖父类的所有特点，必须无条件继承父类的所有特性和接口
在确定是否需要public继承的时候，我们首先要搞清楚子类是否必须拥有父类每一个特性，如果不是，则无论生活经验是什么，都不能视作”is-a”的关系。**public 继承关系不会使父类的特性或接口在子类中退化，只会使其扩充。**


## 32.避免遮掩继承而来的名称
在父类中，虚函数`foo()`被重载了两次，可能是由于参数类型重载（`foo(int)`），也可能是由于`const`属性重载(`foo() const`)。如果子类仅对父类中的`foo()`进行了覆写，那么在子类中父类的另外两个实现(`foo(int) ,foo() const`)也无法被调用，这就是名称遮盖问题——名**称在作用域级别的遮盖是和参数类型以及是否虚函数无关的**，即使子类重载了父类的一个同名，父类的所有同名函数在子类中都被遮盖。

如果想要重启父类中的函数名称，需要在子类有此需求的作用域中（可能是某成员函数中，可能是 `public` 或 `private` 内）加上 `using Base::foo;`，即可把父类作用域汇总的同名函数拉到目标作用域中，需要注意的是，此时父类中的`foo(int)`和`foo() const`都会被置为可用。

如果只想把父类某个在子类中某一个已经不可见的同名函数复用，可使用`inline forwarding function`。


## 33.区分接口继承和实现继承
成员函数的接口总是会被继承，而public继承保证了，如果某个函数可施加在父类上，那么他一定能够被施加在子类上。不同类型的函数代表了父类对子类实现过程中不同的期望。

- 在父类中声明纯虚函数，是为了**强制子类拥有一个接口，并强制子类提供一份实现。**
- 在父类中声明虚函数，是为了**强制子类拥有一个接口，并为其提供一份缺省实现。**
- 在父类中声明非虚函数，是为了**强制子类拥有一个接口以及规定好的实现，并不允许子类对其做任何更改**。

在这其中，有可能出现问题的是普通虚函数，这是因为*父类的缺省实现并不能保证对所有子类都适用，因而当子类忘记实现某个本应有定制版本的虚函数时，父类应从代码层面提醒子类的设计者做相应的检查_，很可惜，普通虚函数无法实现这个功能*。***一种解决方案是，在父类中为纯虚函数提供一份实现，作为需要主动获取的缺省实现***，当子类在实现纯虚函数时，检查后明确缺省实现可以复用，则只需调用该缺省实现即可，这个主动调用过程就是在代码层面提醒子类设计者去检查缺省实现的适用性。

将纯虚函数、虚函数区分开的并不是在父类有没有实现——纯虚函数也可以有实现，其二者本质区别在于父类对子类的要求不同，前者**在于从编译层面提醒子类主动实现接口**，后者则侧重于**给予子类自由度对接口做个性化适配**。非虚函数则没有给予子类任何自由度，而是要求子类坚定的遵循父类的意志，
**保证所有继承体系内能有其一份实现**。


## 34.不重新定义继承而来的non-virtual函数

如果函数有多态调用的需求，一定记得把它设为虚函数，否则在动态调用（基类指针指向子类对象）的时候是不会调用到子类重载过的函数的，很可能会出错。

反之同理，如果一个函数父类没有设置为虚函数，你千万千万不要在子类重载它，也会犯上边类似的错误。

理由就是，多态的动态调用中，只有虚函数是动态绑定，非虚函数是静态绑定的——指针（或引用）的静态类型是什么，就调用那个类型的函数，和动态类型无关。

话说回来，**虚函数的意思是“接口一定被继承，但实现可以在子类更改”，而非虚函数的意思是“接口和实现都必须被继承”。**


## 35.绝不重新定义继承而来的缺省参数值
在继承中：

1. 不要更改父类非虚函数的缺省参数值，其实不要重载父类非虚函数的任何东西，不要做任何改变！
1. 虚函数不要写缺省参数值，子类自然也不要改，虚函数要从始至终保持没有缺省参数值。
> 
> 缺省参数是 声明或定义函数 时为函数的 形参指定一个缺省值（默认参数）。

虚函数在大多数情况是供动态调用，而在动态调用中，子类做出的缺省参数改变其实并没有生效，反而会引起误会，让调用者误以为生效了。

缺省参数值属于静态绑定的原因是为了提高运行时效率。


## 36.类的复合：一个类的对象可以作为另一个类的成员

什么情况下我们应该用类的复合:

第一种情况，非常简单，说明某一个类“拥有”另一个类对象作为一个属性，比如学生拥有铅笔、市民拥有身份证等，不会出错。

第二种情况被讨论的更多，即“一个类根据另一个类实现”。比如“用stack实现一个queue”，更复杂一点的情况可能是“用一个老版本的Google Chrome内核去实现一个红芯浏览器”。



## 37.审慎地使用private继
private继承正是表达“通过某工具类实现另一个类”。那么相似的，工具类在目标类中自然应该被隐藏——所有接口和变量都不应对外暴露出来。这也解释了private继承的内涵，它本质是一种__技术封装__，和public继承不同的是，private继承表达的是“**只有实现部分被继承，而接口部分应略去”的思想。**

与private继承的内涵相对应，**在private继承下，父类的所有成员都转为子类私有变量——不提供对外访问的权限**，外界也无需关心子类内有关父类的任何细节。


当我们拥有“用一个类去实现另一个类”的需求的时候，如何在类的复合与private继承中做选择呢？


尽可能用复合，除非必要，不要采用private继承。
当我们需要对工具类的某些方法（虚函数）做重载时，我们应选择private继承，这些方法一般都是工具类内专门为继承而设计的调用或回调接口，需要用户自行定制实现。


## 38.少使用多继承

原则上不提倡使用多继承，因为多继承可能会引起多父类共用父类，导致在底层子类中出现多余一份的共同祖先类的拷贝。为了避免这个问题C++引入了虚继承，但是虚继承会使子类对象变大，同时使成员数据访问速度变慢，这些都是虚继承应该付出的代价。

## 39.