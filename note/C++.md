## 1.C和C++的区别
**设计思想上：** C++是面向对象的语言，而C是面向过程的结构化编程语言。

**语法上：**

C++具有封装、继承和多态三大特性。

C++相比较C，增加了许多类型安全的功能，比如强制类型转换、智能指针。

C++支持泛型编程，比如模板类，函数模板等。


## 2.构造函数后面的冒号有什么用？
在构造函数后面加冒号，表示冒号后面接构造函数初始化列表（constructor initialize list），主要有三种应用场景：

1. 对基类进行初始化;
2. 对类成员进行初始化;
3. 对类的const成员变量进行初始化;

由于const成员变量的值无法在构造函数内部初始化，因此只能在变量定义时赋值或者使用初始化列表赋值。


## 3. 函数后面 = default 和 = delete 有什么用？
[http://t.csdnimg.cn/hUk79](http://t.csdnimg.cn/hUk79 "http://t.csdnimg.cn/hUk79")

`=defalut`使得被修饰的函数为编译器默认的形式。只能用于（类的）特殊的成员函数（默认构造函数，复制构造函数，析构函数等）。

`=delete`使得编译器禁止该类型的成员函数生成。例如：1.禁用拷贝构造函数；2.禁用不需要用的参数转换。

对特殊成员函数使用以上修饰符使得代码更容易阅读。


## 4.类的大小和什么有关系？

平时所声明的类只是一种类型定义，它本身是没有大小可言的。

这里所说的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。

类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数、静态成员函数、静态数据成员、静态常量数据成员均对类的大小无影响。


<font color="#F100">静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类的所有对象共享，并不属于哪个对象。</font>

虚函数对类的大小有影响，是因为虚函数表指针带来的影响；
虚继承对类的大小有影响，是因为虚基表指针带来的影响。

[http://t.csdnimg.cn/FR01C](http://t.csdnimg.cn/FR01C "http://t.csdnimg.cn/FR01C")
**c++空类（这个类不带任何数据）的大小不为0，为1。**


因为：new需要分配不同的内存地址，不能分配内存大小为0的空间，避免除以 sizeof(T)时得到除以0错误，故使用一个字节来区分空类。

## 5.struct 和 typedef struct 什么区别？
C ：

	typedef struct student {
		int a;
	}Stu;

这时声明变量就可以：`Stu stu1;`
如果上面没有加 `typedef` 就必须用 `struct student stu1` 来声明。这里的 `Stu` 实际上就是 `struct Student` 的别名。
另外这里也可以不写 `Student typedef struct {}Stu`; 那声明变量的时候就不能`struct Student stu1;`了只能`Stu stu1;`）


C++:

1. `struct name {int a;}stu;` 这里 `stu` 是一个变量。
2. `typedef struct name{int a;}stu;`这里的 `stu` 是一个结构体类型。


## 6.函数后面加const
`const` 只能加在类的成员函数后面（普通函数不可以），也就是说这些成员函数是只读函数。

1、非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）

2、加了cosnt的成员函数，表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用）
非静态成员函数后面加 `const` 和 `mutable` 是反义词


加了 `const` 的成员函数可以被 非const对象 和 const对象调用。**注意是对象**。

但不加 `const` 的成员函数只能被 非const对象 调用。

<font color="#A100">函数前面加 cosnt 表示返回值是 const，函数后面加 const 表示不可以修改 class 的成员。</font>



## 7.共享数据的保护
1.常引用：所引用的形参不能被更新

	void display(const double& a);

2.常对象：在生存期内不能被更新，但必须被初始化

	A const a(3, 4);

3.常成员函数：不能修改对象中数据成员，也不能调用类中没有被const修饰的成员函数（常对象唯一的对外接口）。如果声明了一个常对象，则该对象只能调用它的常函数！另外，可以用于对重载函数的区分。

	void print();
	void print() const;

4.extern int a;使得其他文件也能访问该变量

声明一个函数或定义函数时，冠以 `static` 的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数（每一个cpp文件就是一个编译单元）


## 8.运算符重载注意
单目运算符最好重载为成员函数，双目最好为友元函数。

`=、[]`只能重载为成员函数，`<<`和`>>`只能重载为友元函数。


## 9.程序内存分配方式以及它们的区别
内存分配大致上可以分成5块：

1. **栈区（stack）**：栈，就是那些由编译器在需要时分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）
1. **堆区（heap）**：一般由程序员分配、释放，若程序员不释放，程序结束时可能由系统回收。注意，它与数据结构中的堆时两回事，分配方式类似于链表。
1. **全局区（静态区）（static）**：全局变量和静态变量被分配到同一块内存中。程序结束后由系统释放。
1. **常量存储区**：常量字符串就是放在这里的，不允许修改，程序结束后由系统释放。
1. **程序代码区**：存放函数体的二进制代码。


## 10.全局变量、全局静态变量、静态变量、静态函数

### 全局静态变量和全局变量的区别
1.若程序由一个源文件构成时，全局变量与全局静态变量没有区别；

2.若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即全局静态变量对组成该程序的其他源文件时无效的；

3.具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。

静态变量只被所属源文件使用。


### static的作用
**1、全局静态变量**

在全局变量前加上关键字 `static`，全局变量就被定义成一个全局静态变量。

**存放区**：存放在静态存储区，在整个程序运行期间一直存在。

**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显式初始化）

**作用域**：全局静态变量在声明它的文件之外是不可见的，准确来说作用域是从定义之处开始，到文件结尾。

**2、局部静态变量**

在局部变量前加上关键字 `static`，局部变量就被定义成一个局部静态变量。

**存放区**：静态存储区。

**初始化**：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非它被显示初始化）

**作用域**：作用域仍然是局部作用域，当定义它的语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存当中，只不过我们不能对其进行访问，除非该函数再次被调用，并且该局部静态变量值不变。

**3、静态函数**

在函数返回类型前加 `static`，函数就被定义为静态函数。函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只在声明它的文件当中可见，不能被其他文件所用。
这个函数只可以被本cpp内使用，不会和其他cpp中的同名函数引起冲突。

**warning**：（没懂）不要在头文件中声明 `static` 的全局函数，不要在cpp内声明 非static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中去，否则cpp内部声明需加上static修饰。

**4、类的静态成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会被破坏隐藏的原则，也就是保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

**5、类的静态函数**
静态成员函数和静态成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名，可以直接使用 `class_name::static_func()` 就可以访问。

### 静态成员函数与普通成员函数的区别
静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数）

普通成员函数有this指针，可以访问类中的任意成员（普通成员变量和静态成员变量，好像静态成员函数没有this指针不能通过this访问，但是可以通过类名::访问）；而静态成员函数没有this指针。


## 11.new delete 与 malloc free的联系与区别
`new delete `和 `malloc free`都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄漏或者二次释放。

不同的是，`new delete`是C++`中定义的操作符`，`new` 除了分配空间外，还会调用类的构造函数来完成初始化工作，delete 除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。


## 12.explicit
`explicit` 关键字只能用于类的构造函数的声明上。它的作用是防止构造函数进行的隐式转换。

在C++中，一个参数的构造函数（或者除了第一个参数外其余参数都有默认值的多参构造函数），承担了两个角色：

第一是构造；

第二是默认且隐含的类型转换操作符。即如果构造函数接收到的参数会默认进行隐式转换。

隐式转换看起来很方便，但是某些情况下违背了程序员的本意。这个时候就要加上explicit修饰，指定这个构造器只能被明确的调用/使用，不能进行隐式转换。

	class A
	{
	public:
	    explicit A(int a, int b) : m_a(a), m_b(b) {};
	private:
	    int m_a;
	    int m_b;
	}
	
	int main()
	{
	    A test(1, 2); //正确
	    A test1(2.2, 2); // 错误，存在double->int的隐式转换。
	}


## 13.c++的四种 cast 转换
cast转换是C++的强制转换：`cast-name<target_type>(expression);`

1、`const_cast`
唯一一个可以改变const性质的转换

2、`static_cast`
任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

3、`dynamic_cast`
用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果时非法的对于指针返回 `null`，对于引用抛出异常。要深入理解内部转换的原理。

向上转换：指的是子类向基类的转换。
向下转换：指的是基类向子类的转换。

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、`reinterpret_cast`
几乎什么都可以转，可能会出问题，尽量少用。

## 14.为什么不用C的强制转换？
C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

C的强制转换 `(type_name)expression`



## 15.mutable关键字
`mutable` 的中文意思时可变的、易变的，跟 constant（即C++里的const）是反义词。在C++中，mutable 也是为了突破 const 的限制而设置的。被 mutable 修饰的变量（**`mutable`只能用于修饰类的非静态数据成员**），将永远处于可变的状态（可以修改成员数据之类的），即使在一个const函数中。

# 16.用const修饰函数的返回值
如果给以“指针传递”方式的函数返回值加 `const` 修饰，那么函数返回值（即指针）的内容不能修改，且该返回值只能被赋给加 `const` 的同类型指针。一般只在返回值为引用或指针时使用，返回其他值时没有必要。

	const char* get_string(void);
	char *str = get_string();//编译报错
	const char *str = get_string();//正确

## 17.宏、const、enum
`#define`不被视为语言的一部分（#define属于预处理器）。

对于单纯常量，最好用 `const` 对象或者 `enum` 替换`#define`。

对于类似函数的宏，尽量使用内联函数替换掉 `#define`


**编译器处理方式不同**: `define` 宏是在预处理阶段展开; `const` 常量是在编译运行阶段使用。

**类型**：
`define` 宏没有类型，不做任何类型检查，仅仅是展开；
`const` 常量没有具体的类型，在编译阶段会执行类型检查。

**起作用的方式**：`#define` 只是简单的字符串替换，没有类型检查。而 `const` 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。正因为 `define` 只是简单的字符串替换，会导致边界效应，很容易犯错。

	#define N 2+3
	const double a = N/2; //结果是2+3/2 = 2+1 = 3
	const double b = (double)N / (double)2;
	//我们预想的答案是2.5，可实际输出的值是2 + 3 / 2 = 3.5


**占用空间**：
`define` 宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存，占用代码段空间；
`const` 常量会在内存中分配（可以是在堆中也可以是在栈中） 占用数据段空间

**调试角度**：
`const` 常量是可以进行调试的，`#define` 不能进行调试，因为在预编译阶段就已经替换掉了。

**作用域**：`const` 变量是由作用域的，`#define` 在没有遇到 `#undefine` 之前是没有作用域限制的。

## 18.程序编译
程序编译是指将源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。便已产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。

## 19.class 和 struct 的区别
c++中，class 和 struct 都可以定义一个类。
它们有以下两点区别：

1、默认继承权限，如果不指定，来自 class 的继承按照 private 继承处理，来自struct 的继承按照 public 继承处理。

2、成员的默认访问权限。class 的成员默认是 private 权限，struct 默认是public权限。

## 20.






