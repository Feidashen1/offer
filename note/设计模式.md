## 1.观察者模式
**意图**：
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**动机**：
将一个系统设计成一系列相互协作的类有一个常见的副作用：*需要维护相关对象之间的一致性*。

观察者模式定义一种交互，即发布-订阅：

- 一个对象当自身状态发生改变时，会发出通知，但是并不知道谁是他的接收者，但每个接收者都会接收到通知，这些接受者称为观察者。
- 作为对通知的响应，每个观察者都将查询目标状态，然后改变自身的状态以和目标状态进行同步。


**使用场景**：
使对象封装为独立的改变和使用；
一个对象改变同时需要改变其它对象，而不知道具体有多少对象需要改变；
不希望对象是紧耦合的。

**参与者：**

- Subject：目标，知道它的观察者，提供注册和删除观察者对象的接口
- Observer：观察者，为那些在目标发生改变时需获得通知的对象定义一个更新接口
- ConcreteSubject：具体目标，存储对象状态，状态改变时，向各个观察者发出通知
- ConcreteObserver：具体观察者，维护一个指向ConcreteSubject对象的引用，存储有关状态，实现更新接口update，使自身状态与目标的状态保持一致

**优缺点：**

- 目标和观察者之间松耦合
- 支持广播通信：Subject发送的通知不需要指定它的接受者。通知被自动广播给所有已向该目标对象登记的有关对象。
- 意外的更新：看似无害的操作可能会引起观察者错误的更新。

[https://www.cnblogs.com/suzhou/p/dp16obsvr.html](https://www.cnblogs.com/suzhou/p/dp16obsvr.html)

## 2.工厂模式
在工厂模式中，我们在创建对象时不会对客户端暴漏创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，**一般在创建复杂对象时，考虑使用**；在创建简单对象时，建议直接 new 完成一个实例对象的创建。

### 简单工厂模式
主要特点是需要**在工厂类中做判断**，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。

缺点：工厂类中**集中了所有产品类的创建逻辑**，如果产品量较大，会使工厂类变得非常臃肿。

### 工厂方法模式
定义一个创建对象的接口，其子类去具体实现这个接口以完成具体的工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。

缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。

### 抽象工厂模式
抽象工厂模式提供创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。当存在多个产品系列，而客户端只是用一个系列时，可以考虑使用抽象工厂模式。

缺点：当增加一个新系列的产品时，不仅需要实现集体的产品类，还需要增加一个新的创建接口，扩展相对困难。


[https://blog.csdn.net/qq_52358027/article/details/132906467](https://blog.csdn.net/qq_52358027/article/details/132906467)


## 3.策略模式
策略模式是指定义一系列的算法，把它们单独封装起来，并且使他们可以相互替换，使得算法可以独立于使用它们的客户端而变化，也就是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为角色引起环境变化表现出不同的行为。相对于使用大量的if…else，使用策略模式可以减低复杂度，是的代码更容易维护。

缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。



## 4.适配器模式
适配器模式可以将一个类的接口转换成客户端希望的另一个接口，是的原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。通俗的讲就是当我们已经有了一些类，而这些类不能满足新的需求，此时就可以考虑是否能将现有的类适配成可以满足新需求的类。**适配器类需要继承或依赖现有的类，实现想要的目标接口。**

缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。


## 5.单例模式
单例模式顾名思义，**保证一个类仅可以实例化一个对象，并提供一个可以访问它的全局接口**。
实现单例模式必须注意以下几点：

1. 单例类只能有一个实例化对象；
2. 单例类必须自己提供一个实例化对象；
3. 单例类必须提供一个可以访问唯一实例化对象的接口。

**懒汉单例模式：**
不到万不得已就不会去实例化类，也就是说在第一次用到类实例化的时候才会去实例化一个对象。在访问量较小，甚至可能不回去访问的情况下，采用懒汉实现，这是以时间换空间。

**饿汉单例模式：**
在单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是空间换时间。