# 硬件结构
## 1.冯诺依曼模型
运算器、控制器、存储器、输入设备、输出设备

运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。

存储单元和输入输出设备要与中央处理器打交道离不开总线。

**内存**：存储的区域是线性的，存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1。

**中央处理器**：CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据（32位4字节，64位8字节）。

**常见的寄存器种类：**

- **通用寄存器**，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。
- **程序计数器**，用来存储 CPU 要执行下一条指令「所在的**内存地址**」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。
- **指令寄存器**，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。

**总线**：用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：

- **地址总线**，用于指定 CPU 将要操作的内存地址；
- **数据总线**，用于读写内存的数据；
- **控制总线**，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；

## 2.程序执行的基本过程
一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。

CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 CPU 的**指令周期**。

CPU 执行程序的过程如下：

- 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。
- 第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；
- 第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；


> 数据和指令是分开区域存放的，存数据的是「数据段」，存放指令区域的地方称为「正文段」。

> 指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过解析机器码来知道指令的内容；不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码。


## 3.CPU 指令周期的四个阶段？
大多数 CPU 都使用来流水线的方式来执行指令，所谓的流水线就是把一个任务拆分成多个小任务，于是一条指令通常分为 4 个阶段：

1. CPU 通过程序计数器读取（控制器）对应内存地址（存储器）的指令，这个部分称为 Fetch（取得指令）；
1. CPU 对指令进行解码（控制器），这个部分称为 Decode（指令译码）；
1. CPU 执行指令（运算器、控制器），这个部分称为 Execution（执行指令）；
1. CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store（数据回写）；


## 4.指令的类型与执行速度
指令从功能角度划分，可以分为 5 大类：

1. **数据传输**类型的指令，比如 store/load 是寄存器与内存间数据传输的指令，mov 是将一个内存地址的数据移动到另一个内存地址的指令；
1. **运算**类型的指令，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；
1. **跳转**类型的指令，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 if-else、switch-case、函数调用等。
1. **信号**类型的指令，比如发生中断的指令 trap；
1. **闲置**类型的指令，比如指令 nop，执行后 CPU 会空转一个周期；

对于 CPU 来说，在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。
>  1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。

<font color = "#F100">程序的 CPU 执行时间 = CPU 时钟周期数（CPU Cycles）和时钟周期时间（Clock Cycle Time）的乘积 </font>

<font color = "#F100"> CPU 时钟周期数 = 指令数 与 每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）的乘积</font>

因此，<font color="#F8A">**程序的 CPU 执行时间 = 指令数 * CPI *  时钟周期时间** </font>

- 指令数，表示执行程序所需要多少条指令，以及哪些指令。这个层面是基本靠编译器来优化，毕竟同样的代码，在不同的编译器，编译出来的计算机指令会有各种不同的表示方式。
- 每条指令的平均时钟周期数 CPI，表示一条指令需要多少个时钟周期数，现代大多数 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU 时钟周期数尽可能的少;
- 时钟周期时间，表示计算机主频，取决于计算机硬件。有的 CPU 支持超频技术，打开了超频意味着把 CPU 内部的时钟给调快了，于是 CPU 工作速度就变快了，但是也是有代价的，CPU 跑的越快，散热的压力就会越大，CPU 会很容易奔溃。

## 5.磁盘与内存



##1.共享内存使用时无访问控制——不会堵塞等待
我们把共享内存实际上是映射到了我们进程地址空间的用户空间了(堆和栈之间)。对每一个进程而言，挂接到自己的上下文中的共享内存，属于自己的空间，类似于堆空间或者栈空间，可以被用户直接使用，不需要调用系统接口。
共享内存，因为他自身的特性，它没有任何访问控制，共享内存被双方直接看到，属于双方的用户空间，可以直接通信，但是不安全!

## 2.共享内存是所有进程间通信速度最快的——解释
管道：父进程把外设的数据写入(拷贝)到自己进程的上下文代码中，再把自己进程上下文代码write写入(拷贝)进管道文件中，子进程管道文件中的数据read读入(拷贝)进子进程上下文代码中，再把子进程上下文代码刷(拷贝)到外设上，要进行4次拷贝。
而共享内存：进程1把外设的数据写入(拷贝)共享内存时，进程2就能立马看到，并使用共享内存的数据，如果不刷到外设上，只需1次拷贝即可，所以共享内存最快。

## 3.管道和共享内存的区别
- 管道需要在内核和用户空间进行四次的数据拷贝：由用户空间的buf中将数据拷贝到内核中 -> 内核将数据拷贝到内存中 -> 内存到内核 -> 内核到用户空间的buf；而共享内存则只拷贝两次数据：用户空间到内存 -> 内存到用户空间。
- 管道用循环队列实现，连续传送数据可以不限大小。共享内存每次传递数据大小是固定的;
- 共享内存可以随机访问被映射文件的任意位置，管道只能顺序读写；
- 管道可以独立完成数据的传递和通知机制，共享内存需要借助其他通讯方式进行消息传递；
- **两者之间最大的区别**： 共享内存区是最快的可用IPC形式，一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递，就不再通过执行任何进入内核的系统调用来传递彼此的数据，节省了时间。




