## 1.do{ ... }while(0) 的用途
**1.帮助定义复杂的宏以避免错误**
> do 能确保大括号里的逻辑能被执行，而 while(0) 能确保该逻辑只被执行一次，即与没有循环时一样；
> [https://www.cnblogs.com/lanxuezaipiao/p/3535674.html](https://www.cnblogs.com/lanxuezaipiao/p/3535674.html)


**2.避免使用goto控制程序流**
>由于 goto 不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用 do{}while(0)来进行统一的管理

**3.避免由宏引起的警告**
>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用`do{...}while(0)`来定义空宏：`#define EMPTYMICRO do{}while(0) `，这样在编译的时候就不会产生警告。

**4.定义单一的函数块来完成复杂的操作**
>当你的功能很复杂，变量很多你又不愿意增加一个函数的时候，使用`do{}while(0)`;，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。

## 2.socket accept 发生在三次握手的哪一步？
客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

## 3.没有 accept 或 listen 能建立 TCP 连接吗？
可以。

- accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

- 客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是**没有服务端参与**，也就是没有 listen，就能 TCP 建立连接。

服务端如果只 bind 了 IP 地址和端口，没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。


## 4.程序是如何表示 TCP 发送方和接收方滑动窗口呢？

**发送方**

发送方滑动窗口：| 已发送并收到ACK | 已发送未收到ACK | 未发送但大小在接受方处理范围内 | 未发送大于范围 |

TCP 发送方滑动窗口方案使用**三个指针**来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

1. 指向的是已发送但未收到确认的第一个字节的序列号；
2. 指向的是已发送但未收到确认的第一个字节的序列号；
3. 指向超范围的第一个字节，是个相对指针，利用前两个绝对指针求出。


**接收方**

接收方滑动窗口：| 已成功接收并确认的数据（等待应用进程读取） | 未收到数据但可以接收的数据 | 未收到数据并不可以接收的数据 |

其中三个接收部分，使用两个指针进行划分：

1. 绝对指针，指向期望从发送方发送来的下一个数据字节的序列号；
2. 相对指针，指向未收到数据并不可以接收的数据的第一个字节；



## 5.