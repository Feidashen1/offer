## 1.do{ ... }while(0) 的用途
**1.帮助定义复杂的宏以避免错误**
> do 能确保大括号里的逻辑能被执行，而 while(0) 能确保该逻辑只被执行一次，即与没有循环时一样；
> [https://www.cnblogs.com/lanxuezaipiao/p/3535674.html](https://www.cnblogs.com/lanxuezaipiao/p/3535674.html)


**2.避免使用goto控制程序流**
>由于 goto 不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用 do{}while(0)来进行统一的管理

**3.避免由宏引起的警告**
>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用`do{...}while(0)`来定义空宏：`#define EMPTYMICRO do{}while(0) `，这样在编译的时候就不会产生警告。

**4.定义单一的函数块来完成复杂的操作**
>当你的功能很复杂，变量很多你又不愿意增加一个函数的时候，使用`do{}while(0)`;，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。

## 2.socket accept 发生在三次握手的哪一步？
客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

## 3.没有 accept 或 listen 能建立 TCP 连接吗？
可以。

- accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

- 客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是**没有服务端参与**，也就是没有 listen，就能 TCP 建立连接。

服务端如果只 bind 了 IP 地址和端口，没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。


## 4.程序是如何表示 TCP 发送方和接收方滑动窗口呢？

**发送方**

发送方滑动窗口：| 已发送并收到ACK | 已发送未收到ACK | 未发送但大小在接受方处理范围内 | 未发送大于范围 |

TCP 发送方滑动窗口方案使用**三个指针**来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

1. 指向的是已发送但未收到确认的第一个字节的序列号；
2. 指向的是已发送但未收到确认的第一个字节的序列号；
3. 指向超范围的第一个字节，是个相对指针，利用前两个绝对指针求出。


**接收方**

接收方滑动窗口：| 已成功接收并确认的数据（等待应用进程读取） | 未收到数据但可以接收的数据 | 未收到数据并不可以接收的数据 |

其中三个接收部分，使用两个指针进行划分：

1. 绝对指针，指向期望从发送方发送来的下一个数据字节的序列号；
2. 相对指针，指向未收到数据并不可以接收的数据的第一个字节；



## 5.什么是argc参数和argv参数？
argc和argv是两个用于传递命令行参数的参数。

- argc（argument count）是一个整数，表示传递给程序的命令行参数的数量（包括程序本身）。它至少为1，因为第一个参数始终是程序的名称(argv[0])。
- argv（argument vector）是一个指向字符串数组的指针，每个字符串表示一个命令行参数。第一个元素argv[0]是程序的名称，后续元素argv[1]、argv[2]，以此类推，表示其他命令行参数。

## 6.C++（.）和（-＞）运算符用法
C++中，点运算符（.）用于访问类的成员变量和成员函数，而箭头运算符（->）用于通过指针访问类的成员变量和成员函数。

点运算符用法：

- 访问类的成员变量：对象名.成员变量名
- 访问类的成员函数：对象名.成员函数名(参数列表)

箭头运算符用法：

- 访问指针指向的对象的成员变量：指针->成员变量名
- 访问指针指向的对象的成员函数：指针->成员函数名(参数列表)

需要注意的是**，箭头运算符只能用于指向类对象的指针**，而不能用于普通对象。

[https://blog.csdn.net/weixin_45055461/article/details/132247105](https://blog.csdn.net/weixin_45055461/article/details/132247105)

## 7.C++ 单例模式？
单例 Singleton 是设计模式的一种，其特点是只提供**唯一一个类的实例**，具有**全局变量**的特点，**在任何位置都可以通过接口获取到**那个唯一实例；
具体运用场景如：

- 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动；
- 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取；
- 日志，需要确保即使多个线程或进程同时打印消息，消息也将按顺序打印，不会出现乱码或交错；

**问题：为什么需要单例模式？**

两个原因：

- 节省资源。一个类只有一个实例，不存在多份实例，节省资源。
- 方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。


但是在实现单例模式时，需要考虑到线程安全的问题。

**问题：单例模式分类？**

单例模式可以分为 懒汉式 和 饿汉式 ，两者之间的区别在于创建实例的时间不同。

- **懒汉式：**
系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。这种方式要考虑线程安全。

- **饿汉式：**
系统一运行，就初始化创建实例，当需要时，直接调用即可。这种方式本身就线程安全，没有多线程的线程安全问题。

**问题：单例类的特点？**

- 构造函数和析构函数为私有类型，目的是禁止外部构造和析构。
- 拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。
- 类中有一个获取实例的静态方法，可以全局访问。

[C++ 单例模式总结（5种单例实现方法）](https://gitcode.csdn.net/65e6e7161a836825ed787677.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NjI1OTk5LCJleHAiOjE3MTY1MzczMjQsImlhdCI6MTcxNTkzMjUyNCwidXNlcm5hbWUiOiJGRFM5OTk5OSJ9.0AtBexPqRckfTu7996AB0xDbysx_YF6c8Ap3ZEF8Je0)

## 8.单例模式实现？

**静态局部变量的懒汉单例（推荐）**
> C++ 11标准中新增了一个特性叫 Magic Static：如果变量在初始化时，并发线程同时进入到static声明语句，并发线程会阻塞等待初始化结束。
> 
这样可以保证在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性，同时也避免了new对象时指令重排序造成对象初始化不完全的现象。并且相比较与使用智能指针以及 mutex 来保证线程安全和内存安全来说，这样做能够提升效率。

**加锁的懒汉式单例**


- **方法1：返回普通指针**
- **方法2：返回智能指针**


**使用 C++11 std::call_once 实现

> std::call_once的作用是很简单的，　就是保证函数或者一些代码段在并发或者多线程的情况下，始终只会被执行一次。懒汉单例**



**饿汉式单例**

[https://blog.csdn.net/unonoi/article/details/121138176
](https://blog.csdn.net/unonoi/article/details/121138176)

## 9.C++ 日志工具 - Log4cpp 
Log4cpp是一个开源的C++类库，它提供了在C++程序中使用日志和跟踪调试的功能。

Log4cpp有三个主要的组件：日志类别（Category）、输出源（Appender）和布局（Layout）。

1）**日志类别（Category）** 含义是：如果配置文件中设置的级别是 DEBUG，则任意的 log 都能打印出来；但如果配置的级别是 ERROR，则只有高于 ERROR 优先级的日志才可以打印出来。

日志的常用优先级：DEBUG < INFO < WARN < ERROR < FATAL。

2）**输出源（Appender）** 用来输出日志（被layout格式化后）写到什么地方去，比如文件、命令行、内存等。也可以定义自己的 appender 输出日志信息到别的设备上。log4cpp 提供的 appender 如下： FileAppender 输出到文件 RollingFileAppender 输出到回卷文件，即当文件到达某个大小后回卷 ConsoleAppender 输出到控制台。

3）**布局（Layout）**：显示样式 PatternLayout 表示让用户根据类似于C语言printf函数的转换模式来指定输出格式。

三个组件之间的关系：

Category 和 Appender 的关系是：多个 Appender 可以附加到一个 Category 上，这样一个日志消息可以同时输出到多个设备上。
Appender 和 Layout 的关系是：Layout 附加在 Appender 上，appender 调用 layout 处理完日志消息后，记录到某个设备上。


## 10.try-catch
     try{ // 可能抛出异常的语句 }catch(exceptionType variable){ // 处理异常的语句 }

try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。

## 11.INI文件的解析器-inipaerse
Dictionary 是由一组无序的键（keys）和对应的值（values）组成的数据集合。每个键必须是独一无二的，而值可以重复。Dictionary中的键和值可以是任意的Objective-C对象。

Dictionary对象是通过NSDictionary类实现的。NSDictionary是一个不可变的类，一旦创建就不能修改。如果需要修改Dictionary，可以使用NSMutableDictionary类。NSMutableDictionary是可变的，可以在运行时添加、删除或修改键值对。

> 字典具有不可重复性，如果键重复会进行替换


ini 文件的最基本组成单元就是key或者叫property，每个key都有一个名称（name）和对应的值（value）

## 11.为什么static成员变量一定要在类外初始化?
在C++中，类的静态成员（static member）必须在类内声明，在类外初始化。

对于静态成员变量而言，它们的生命周期与类的生命周期相关联，而不是与类的实例的生命周期相关联。编译时在静态数据区分配内存，到程序结束时才释放。这就意味着 static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

静态成员变量**实际上就是类域中的全局变量**，类内声明，类外进行初始化操作。

因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的：

- 如果静态成员变量有默认初始化值，且在多个源文件中都包含了该类的定义，那么编译器会在每个源文件中生成对静态成员变量的初始化代码，从而导致链接时的多重定义错误。
- 此外，静态成员变量的默认初始化值可能会因编译器、平台或环境的不同而产生差异，这会导致程序行为的不确定性。


# RPC

## 1.为什么要有RPC
- http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。
- socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。
- RPC一般配合netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显

## 2.什么是RPC

RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等

## 3.RPC架构组件
一个基本的RPC架构里面应该至少包含以下4个组件：

1、客户端（Client）:服务调用方（服务消费者）

2、客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端

3、服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理

4、服务端（Server）:服务的真正提供者



**具体调用过程：**

- 1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；
- 2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网传输的消息体；
- 3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；
- 4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；
- 5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；
- 6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；
- 7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；
- 8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；
- 9、服务消费方得到最终结果；

而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。


## 4.RPC的实现基础？

- 1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；
- 2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；
- 3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；
- 4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；

## 5.RPC使用了哪些关键技术？

1、动态代理

生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。

2、序列化和反序列化

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。
序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。
反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。

3、NIO通信

出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。

4、服务注册中心

可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。


## 6.主流RPC框架有哪些?

- 1、**RMI** 利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化。
- 2、**Hessian** 是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。
- 3、**protobuf-rpc-pro** 是一个Java类库，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于Netty 底层的 NIO 技术。支持 TCP 重用/keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。
- 4、**Thrift** 是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C++，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。最初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。
- 5、**Avro** 出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。
- 6、**Dubbo** 是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。

## 7.RPC的实现原理架构
[https://juejin.cn/post/7055613735020265479#heading-8](https://juejin.cn/post/7055613735020265479#heading-8)

两台服务器A，B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。

**1、建立通信**

首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。

通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。

**2、服务寻址**

要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。

- **从服务提供者的角度看**：当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。
- **从调用者的角度看**： 服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；服务调用者下线的时候，则取消订阅。

**3、网络传输**

- **序列化**：当 A 机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如 TCP 传输到 B 机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给 B 机器。
- **反序列化**：当 B 机器接收到 A 机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。

4、**服务调用**

B 机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回 A 机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回 A 机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。
通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。


# zookeeper
## 1.ZooKeeper 是什么？
ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 zookeeper 最新的 zxid。

## 2.ZooKeeper 提供了什么？
- 1、文件系统
- 2、通知机制
- 3.Zookeeper文件系统。Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。

## 3.四种类型的 znode

- 1、**PERSISTENT-持久化目录节点**：客户端与zookeeper 断开连接后，该节点依旧存在
- 2、**PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点**：客户端与 zookeeper 断开连接后，该节点依旧存在，只是 Zookeeper 给该节点名称进行顺序编号
- 3、**EPHEMERAL-临时目录节点**：客户端与 zookeeper 断开连接后，该节点被删除
- 4、**EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点**：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper 给该节点名称进行顺序号


## 4.Zookeeper 通知机制
client 端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些 client 会收到 Zookeeper 的通知，然后 client 可以根据 znode 变化来做出业务上的改变等。

## 5.Zookeeper 做了什么？
- 1、命名服务
- 2、配置管理
- 3、集群管理
- 4、分布式锁
- 5、队列管理


## 6.zk 的命名服务（文件系统）
命名服务是指通过指定的名字来获取资源或者服务的地址，利用 zk 创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。

## 7.zk 的配置管理（文件系统、通知机制）
程序分布式的部署在不同的机器上，将程序的配置信息放在 zk 的 znode 下，当有配置发生改变时，也就是 znode 发生变化时，可以通过改变 zk 中某个目录节点的内容，利用 watcher 通知给各个客户端，从而更改配置。

## 8.Zookeeper 集群管理（文件系统、通知机制）
- 所谓集群管理无在乎两点：是否有机器退出和加入、选举 master。
- 对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper 的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了
- 新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount 又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为 master就好。

## 9.Zookeeper 分布式锁（文件系统、通知机制）
- 有了 zookeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。
- 对于第一类，我们将 zookeeper 上的一个 znode 看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 distribute_lock 节点就释放出锁。
- 对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选 master 一样，编号最小的获得锁，用完删除，依次方便。

## 10.zookeeper watch 机制
Watch 机制官方声明：一个 Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们。
Zookeeper 机制的特点：

- 1、一次性触发数据发生改变时，一个watcher event 会被发送到client，但是client 只会收到一次这样的信息。
- 2、watcher event 异步发送 watcher的通知事件从server发送到client是异步的，这就存在一个问题，不同的客户端和服务器之间通过socket进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于Zookeeper本身提供了ordering guarantee，即客户端监听事件后，才会感知它所监视znode发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。Zookeeper 只能保证最终的一致性，而无法保证强一致性。
- 3、数据监视Zookeeper有数据监视和子数据监视getdata() and exists()设置数据监视，getchildren()设置了子节点监视。
- 4、注册 watcher getData、exists、getChildren
- 5、触发 watcher create、delete、setData
- 6、setData()会触发 znode上设置的 data watch（如果 set 成功的话）。一个成功的 create() 操作会触发被创建的 znode上的数据 watch，以及其父节点上的child watch。而一个成功的 delete()操作将会同时触发一个 znode 的 data watch 和 child watch（因为这样就没有子节点了），同时也会触发其父节点的 childwatch。
- 7、当一个客户端连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 client 重新连接时，如果需要的话，所有先前注册过的 watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode 的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。
- 8、Watch 是轻量级的，其实就是本地 JVM 的 Callback，服务器端只是存了是否有设置了 Watcher 的布尔类型


## 线程池
**线程池的基本概念**：在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。

**线程池的设计思想**：为了避免频繁地创建和销毁线程的开销，以及控制并发执行的线程数量，从而提高系统的性能和资源利用率。

**线程池的关键组成部分**：

1. *线程池管理器（ThreadPoolExecutor）*：负责创建、管理和控制线程池。它负责线程的创建、销毁和管理，以及线程池的状态监控和调度任务。
1. *工作队列（BlockingQueue）*：用于存储待执行的任务。当线程池中的线程都在执行任务时，新的任务会被放入工作队列中等待执行。
1. *线程池线程（Worker Thread）*：实际执行任务的线程。线程池中会维护一组线程，这些线程可以被重复使用，从而避免了频繁创建和销毁线程的开销。


**运行机制如下**： 

1. 当任务到达时，线程池管理器会检查线程池中是否有空闲的线程。如果有，则将任务分配给空闲线程执行；如果没有，则进入下一步。
1. 如果线程池中的线程数量未达到最大限制，线程池管理器会创建一个新的线程，并将任务分配给该线程执行。
1. 如果线程池中的线程数量已达到最大限制，并且工作队列未满，则将任务放入工作队列中等待执行。
1. 当线程池中的线程执行完任务后，会从工作队列中获取下一个任务并执行。

**主要优点：**

1. 重用线程：线程池会在内部维护一组可重用的线程，避免了频繁地创建和销毁线程的开销，提高了线程的利用率。
1. 控制并发度：线程池可以限制并发执行的线程数量，防止系统过载。通过调整线程池的大小，可以控制并发度，避免资源消耗过大。
1. 提供线程管理和监控：线程池提供了一些管理和监控机制，例如线程池的创建、销毁、线程状态的监控等，方便开发人员进行线程的管理和调试。
1. 提供任务队列：线程池通常会使用任务队列来存储待执行的任务，这样可以实现任务的缓冲和调度。

**线程池的一些缺点包括**：

- 需要合理配置：线程池的性能和效果受到配置参数的影响，需要根据具体的应用场景和硬件环境来合理配置线程池的大小、任务队列的大小等参数。
- 可能引发资源泄露：如果线程池中的线程长时间闲置而不被使用，可能会导致资源的浪费和泄露。
- 可能引发死锁：在使用线程池时，如果任务之间存在依赖关系，可能会引发死锁问题，需要额外的注意和处理。


## volatile 关键字
volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。volatile **提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。**如 果没有 volatile 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。


销毁线程池时：` volatile uint_t  lock;`

在多线程编程中，有些变量可能会被多个线程访问并修改，如果不使用 volatile 声明，编译器可能会对变量进行一些优化，如缓存变量的值，从而可能导致线程间通信的错误。使用 volatile 声明变量后，编译器会强制要求每次访问该变量时都从内存中读取最新的值，从而确保了线程间通信的正确性。

一个参数既可以是const还可以是 volatile 吗？

可以，例如只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它是 const 因为 程序不应该试图去修改它。

## void* 

如果指针 p1 和 p2 的类型相同，那么我们可以直接在 p1 和 p2 间互相赋值；如果 p1 和 p2 指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。

而 void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换。

但这并不意味着，void * 也可以无需强制类型转换地赋给其它类型的指针。因为"无类型"可以包容"有类型"，而"有类型"则不能包容"无类型"。

## 父类与子类的强转
**1.子类转换为父类**

子类转换为父类之后，不能调用子类独有的函数和成员变量，只能调用子类继承的虚函数，利用多态的特性。

**2.父类转换为子类**

父类转换为子类是会出现异常，因为子类比父类有更多的成员变量和函数。如果访问子类自己独有的成员变量，会访问到未知的地方。

**3.避免不安全的父类转换成子类**

使用强制转换符 dynamic_cast 来避免不安全的强制转换。


## 线程池处理任务的步骤
1. **任务提交**： 将任务提交给线程池管理器。
1. **任务队列**： 任务被放置在线程池的任务队列中等待执行。
1. **线程分配**： 线程池管理器根据任务队列的情况分配线程来执行任务。
1. **任务执行**： 分配的线程从任务队列中取出任务，并执行任务的代码逻辑。
1. **线程复用**： 线程执行完任务后，不会被销毁，而是重新放回线程池，以备下次使用。
1. **异常处理**： 如果任务执行过程中发生异常，线程池可以根据配置进行异常处理，比如记录日志、重启线程等。
1. **线程池关闭**： 当不再需要线程池时，可以关闭线程池，释放资源。


## CPU 密集型和 IO 密集型
CPU密集型和I/O密集型是根据任务对计算资源（CPU和内存）和输入/输出资源（磁盘、网络等）的需求程度来区分的

**CPU密集型**：指计算机程序或任务在执行过程中主要依赖于**中央处理器（CPU）**进行计算和处理的类型。这种类型的任务会占用大量的CPU资源，而相对较少地依赖其他计算机组件，如内存、硬盘或网络带宽。

**CPU密集型任务**:

- 主要依赖于中央处理器（CPU）进行计算和处理的任务。
- 需要大量的计算操作，例如科学计算、数据分析、图像处理、视频编码解码、密码学算法等。
- 对CPU的利用率要求较高，占用大量的计算资源，而对I/O资源的需求相对较低。
- CPU密集型任务通常会占用大量的CPU时间片，使CPU处于高负载状态，产生较高的功耗和热量。



**IO密集型**：与CPU密集型相对的是I/O密集型任务。I/O密集型任务主要依赖于**输入输出操作**，涉及较多的数据读写和网络通信，而CPU的计算和处理需求相对较少。例如，数据库访问、文件传输、网络通信等任务就属于I/O密集型。  

I/O密集型任务：

- 主要依赖于输入/输出操作，涉及较多的数据读写和网络通信的任务。
- 需要频繁地访问磁盘、网络或其他外部设备，例如数据库访问、文件传输、网络通信等。
- 对CPU的计算和处理需求相对较低，而对I/O资源的需求较高。
- I/O密集型任务通常会涉及大量的数据传输和等待时间，因此对磁盘、网络带宽等I/O资源的性能和响应速度要求较高。 

>I/O密集型任务的执行过程中，主要涉及以下几个方面：
>
> 1. **数据读取和写入**：任务需要从磁盘、网络或其他外部设备中读取数据或将数据写入到这些设备中，以完成任务的操作。
> 2. **等待时间**：在进行I/O操作时，任务需要等待设备响应和数据传输，这会占据大量的时间。因此，I/O密集型任务的执行效率往往受到磁盘、网络带宽等I/O资源的影响。
> 3. **缓存机制**：为了提高I/O密集型任务的执行效率，可以采用缓存机制来缓存一部分数据，以减少磁盘或网络访问次数，降低等待时间。
> 4. **并发操作**：为了充分利用I/O设备的性能，可以采用并发操作的方式，同时进行多个I/O任务，以提高I/O密集型任务的执行效率。


<font color = "#F100">一般来说，造成CPU密集型卡顿的原因通常是cpu不够用，使用多进程；而IO密集型卡顿则是由于线程不够用，需要多线程。</font>

**CPU密集型任务主要影响CPU内核的计算性能和负载情况，而I/O密集型任务则主要影响CPU内核的I/O调度和等待情况。**

核心线程数计算公式：

- CPU密集型：核心线程数 = CPU核数 + 1 //+1是为了预防某个线程被阻塞时，cpu可以调用其他线程。
- IO密集型：核心线程数 = CPU核数 / （1-阻塞系数） 
- IO密集型：核心线程数 = CPU核数 * 2


[https://blog.csdn.net/m0_62006803/article/details/134862520](https://blog.csdn.net/m0_62006803/article/details/134862520)


## Reactor 和 Proactor

Reactor 模式也叫 Dispatcher 模式，即 I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。

Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：

- Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；
- 处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：

- Reactor 的数量可以只有一个，也可以有多个；
- 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；

方案：

1.单 Reactor 单进程 / 线程；

- 因为只有一个进程，无法充分利用 多核 CPU 的性能；
- Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；

单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。

2.单 Reactor 多线程 / 进程；

- 单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的能，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。
- 单 Reactor 的模式还有个问题，因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。


3.多 Reactor 多进程 / 线程；



> 进程里有 Reactor、Acceptor、Handler 三个对象：

> - Reactor 对象的作用是监听和分发事件；
> - Acceptor 对象的作用是获取连接；
> - Handler 对象的作用是处理业务；


<font color="#F100">Reactor 是非阻塞同步网络模式，而 **Proactor 是异步网络模式**。</font>


- Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。
- Proactor 是异步网络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。

<font color="#F100">因此，Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。
</font>无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件。

[http://t.csdnimg.cn/RD39y](http://t.csdnimg.cn/RD39y)


## 