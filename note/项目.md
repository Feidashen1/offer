## 1.do{ ... }while(0) 的用途
**1.帮助定义复杂的宏以避免错误**
> do 能确保大括号里的逻辑能被执行，而 while(0) 能确保该逻辑只被执行一次，即与没有循环时一样；
> [https://www.cnblogs.com/lanxuezaipiao/p/3535674.html](https://www.cnblogs.com/lanxuezaipiao/p/3535674.html)


**2.避免使用goto控制程序流**
>由于 goto 不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用 do{}while(0)来进行统一的管理

**3.避免由宏引起的警告**
>由于内核不同体系结构的限制，我们可能需要多次使用空宏。在编译的时候，这些空宏会产生警告，为了避免这种警告，我们可以使用`do{...}while(0)`来定义空宏：`#define EMPTYMICRO do{}while(0) `，这样在编译的时候就不会产生警告。

**4.定义单一的函数块来完成复杂的操作**
>当你的功能很复杂，变量很多你又不愿意增加一个函数的时候，使用`do{}while(0)`;，将你的代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。

## 2.socket accept 发生在三次握手的哪一步？
客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

## 3.没有 accept 或 listen 能建立 TCP 连接吗？
可以。

- accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

- 客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是**没有服务端参与**，也就是没有 listen，就能 TCP 建立连接。

服务端如果只 bind 了 IP 地址和端口，没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。


## 4.程序是如何表示 TCP 发送方和接收方滑动窗口呢？

**发送方**

发送方滑动窗口：| 已发送并收到ACK | 已发送未收到ACK | 未发送但大小在接受方处理范围内 | 未发送大于范围 |

TCP 发送方滑动窗口方案使用**三个指针**来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

1. 指向的是已发送但未收到确认的第一个字节的序列号；
2. 指向的是已发送但未收到确认的第一个字节的序列号；
3. 指向超范围的第一个字节，是个相对指针，利用前两个绝对指针求出。


**接收方**

接收方滑动窗口：| 已成功接收并确认的数据（等待应用进程读取） | 未收到数据但可以接收的数据 | 未收到数据并不可以接收的数据 |

其中三个接收部分，使用两个指针进行划分：

1. 绝对指针，指向期望从发送方发送来的下一个数据字节的序列号；
2. 相对指针，指向未收到数据并不可以接收的数据的第一个字节；



## 5.什么是argc参数和argv参数？
argc和argv是两个用于传递命令行参数的参数。

- argc（argument count）是一个整数，表示传递给程序的命令行参数的数量（包括程序本身）。它至少为1，因为第一个参数始终是程序的名称(argv[0])。
- argv（argument vector）是一个指向字符串数组的指针，每个字符串表示一个命令行参数。第一个元素argv[0]是程序的名称，后续元素argv[1]、argv[2]，以此类推，表示其他命令行参数。

## 6.C++（.）和（-＞）运算符用法
C++中，点运算符（.）用于访问类的成员变量和成员函数，而箭头运算符（->）用于通过指针访问类的成员变量和成员函数。

点运算符用法：

- 访问类的成员变量：对象名.成员变量名
- 访问类的成员函数：对象名.成员函数名(参数列表)

箭头运算符用法：

- 访问指针指向的对象的成员变量：指针->成员变量名
- 访问指针指向的对象的成员函数：指针->成员函数名(参数列表)

需要注意的是**，箭头运算符只能用于指向类对象的指针**，而不能用于普通对象。

[https://blog.csdn.net/weixin_45055461/article/details/132247105](https://blog.csdn.net/weixin_45055461/article/details/132247105)

## 7.C++ 单例模式？
单例 Singleton 是设计模式的一种，其特点是只提供**唯一一个类的实例**，具有**全局变量**的特点，**在任何位置都可以通过接口获取到**那个唯一实例；
具体运用场景如：

- 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动；
- 数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取；
- 日志，需要确保即使多个线程或进程同时打印消息，消息也将按顺序打印，不会出现乱码或交错；

**问题：为什么需要单例模式？**

两个原因：

- 节省资源。一个类只有一个实例，不存在多份实例，节省资源。
- 方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。


但是在实现单例模式时，需要考虑到线程安全的问题。

**问题：单例模式分类？**

单例模式可以分为 懒汉式 和 饿汉式 ，两者之间的区别在于创建实例的时间不同。

- **懒汉式：**
系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。这种方式要考虑线程安全。

- **饿汉式：**
系统一运行，就初始化创建实例，当需要时，直接调用即可。这种方式本身就线程安全，没有多线程的线程安全问题。

**问题：单例类的特点？**

- 构造函数和析构函数为私有类型，目的是禁止外部构造和析构。
- 拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。
- 类中有一个获取实例的静态方法，可以全局访问。

[C++ 单例模式总结（5种单例实现方法）](https://gitcode.csdn.net/65e6e7161a836825ed787677.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6NjI1OTk5LCJleHAiOjE3MTY1MzczMjQsImlhdCI6MTcxNTkzMjUyNCwidXNlcm5hbWUiOiJGRFM5OTk5OSJ9.0AtBexPqRckfTu7996AB0xDbysx_YF6c8Ap3ZEF8Je0)

## 8.单例模式实现？

**静态局部变量的懒汉单例（推荐）**
> C++ 11标准中新增了一个特性叫 Magic Static：如果变量在初始化时，并发线程同时进入到static声明语句，并发线程会阻塞等待初始化结束。
> 
这样可以保证在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性，同时也避免了new对象时指令重排序造成对象初始化不完全的现象。并且相比较与使用智能指针以及 mutex 来保证线程安全和内存安全来说，这样做能够提升效率。

**加锁的懒汉式单例**


- **方法1：返回普通指针**
- **方法2：返回智能指针**


**使用 C++11 std::call_once 实现

> std::call_once的作用是很简单的，　就是保证函数或者一些代码段在并发或者多线程的情况下，始终只会被执行一次。懒汉单例**



**饿汉式单例**

[https://blog.csdn.net/unonoi/article/details/121138176
](https://blog.csdn.net/unonoi/article/details/121138176)

## 9.C++ 日志工具 - Log4cpp 
Log4cpp是一个开源的C++类库，它提供了在C++程序中使用日志和跟踪调试的功能。

Log4cpp有三个主要的组件：日志类别（Category）、输出源（Appender）和布局（Layout）。

1）**日志类别（Category）** 含义是：如果配置文件中设置的级别是 DEBUG，则任意的 log 都能打印出来；但如果配置的级别是 ERROR，则只有高于 ERROR 优先级的日志才可以打印出来。

日志的常用优先级：DEBUG < INFO < WARN < ERROR < FATAL。

2）**输出源（Appender）** 用来输出日志（被layout格式化后）写到什么地方去，比如文件、命令行、内存等。也可以定义自己的 appender 输出日志信息到别的设备上。log4cpp 提供的 appender 如下： FileAppender 输出到文件 RollingFileAppender 输出到回卷文件，即当文件到达某个大小后回卷 ConsoleAppender 输出到控制台。

3）**布局（Layout）**：显示样式 PatternLayout 表示让用户根据类似于C语言printf函数的转换模式来指定输出格式。

三个组件之间的关系：

Category 和 Appender 的关系是：多个 Appender 可以附加到一个 Category 上，这样一个日志消息可以同时输出到多个设备上。
Appender 和 Layout 的关系是：Layout 附加在 Appender 上，appender 调用 layout 处理完日志消息后，记录到某个设备上。


## 10.try-catch
     try{ // 可能抛出异常的语句 }catch(exceptionType variable){ // 处理异常的语句 }

try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。

## 11.INI文件的解析器-inipaerse
Dictionary 是由一组无序的键（keys）和对应的值（values）组成的数据集合。每个键必须是独一无二的，而值可以重复。Dictionary中的键和值可以是任意的Objective-C对象。

Dictionary对象是通过NSDictionary类实现的。NSDictionary是一个不可变的类，一旦创建就不能修改。如果需要修改Dictionary，可以使用NSMutableDictionary类。NSMutableDictionary是可变的，可以在运行时添加、删除或修改键值对。

> 字典具有不可重复性，如果键重复会进行替换


ini 文件的最基本组成单元就是key或者叫property，每个key都有一个名称（name）和对应的值（value）

